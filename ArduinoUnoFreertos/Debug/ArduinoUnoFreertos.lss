
ArduinoUnoFreertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000aa  00800100  00001e36  00001eca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e36  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000648  008001aa  008001aa  00001f74  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001f74  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001fa4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003c8  00000000  00000000  00001fe4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004cfc  00000000  00000000  000023ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000130a  00000000  00000000  000070a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002a6a  00000000  00000000  000083b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bb0  00000000  00000000  0000ae1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000016eb  00000000  00000000  0000b9cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000048dc  00000000  00000000  0000d0b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003d8  00000000  00000000  00011993  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 49 0d 	jmp	0x1a92	; 0x1a92 <__vector_1>
       8:	0c 94 76 0d 	jmp	0x1aec	; 0x1aec <__vector_2>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 80 04 	jmp	0x900	; 0x900 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e6 e3       	ldi	r30, 0x36	; 54
      7c:	fe e1       	ldi	r31, 0x1E	; 30
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	aa 3a       	cpi	r26, 0xAA	; 170
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	aa ea       	ldi	r26, 0xAA	; 170
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a2 3f       	cpi	r26, 0xF2	; 242
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 0d 01 	call	0x21a	; 0x21a <main>
      9e:	0c 94 19 0f 	jmp	0x1e32	; 0x1e32 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <Interrupt_Handler>:
	
	return ADC;
}

void Interrupt_Handler(){
	if(xTaskGetTickCountFromISR() - lastInterrupt > 500){
      a6:	0e 94 86 09 	call	0x130c	; 0x130c <xTaskGetTickCountFromISR>
      aa:	40 91 ee 07 	lds	r20, 0x07EE	; 0x8007ee <lastInterrupt>
      ae:	50 91 ef 07 	lds	r21, 0x07EF	; 0x8007ef <lastInterrupt+0x1>
      b2:	60 91 f0 07 	lds	r22, 0x07F0	; 0x8007f0 <lastInterrupt+0x2>
      b6:	70 91 f1 07 	lds	r23, 0x07F1	; 0x8007f1 <lastInterrupt+0x3>
      ba:	a0 e0       	ldi	r26, 0x00	; 0
      bc:	b0 e0       	ldi	r27, 0x00	; 0
      be:	84 1b       	sub	r24, r20
      c0:	95 0b       	sbc	r25, r21
      c2:	a6 0b       	sbc	r26, r22
      c4:	b7 0b       	sbc	r27, r23
      c6:	85 3f       	cpi	r24, 0xF5	; 245
      c8:	91 40       	sbci	r25, 0x01	; 1
      ca:	a1 05       	cpc	r26, r1
      cc:	b1 05       	cpc	r27, r1
      ce:	68 f0       	brcs	.+26     	; 0xea <Interrupt_Handler+0x44>
		// disable buzzer
		PORTB &= ~(1 << buzzerPinB);
      d0:	2d 98       	cbi	0x05, 5	; 5
		
		lastInterrupt = xTaskGetTickCountFromISR();
      d2:	0e 94 86 09 	call	0x130c	; 0x130c <xTaskGetTickCountFromISR>
      d6:	a0 e0       	ldi	r26, 0x00	; 0
      d8:	b0 e0       	ldi	r27, 0x00	; 0
      da:	80 93 ee 07 	sts	0x07EE, r24	; 0x8007ee <lastInterrupt>
      de:	90 93 ef 07 	sts	0x07EF, r25	; 0x8007ef <lastInterrupt+0x1>
      e2:	a0 93 f0 07 	sts	0x07F0, r26	; 0x8007f0 <lastInterrupt+0x2>
      e6:	b0 93 f1 07 	sts	0x07F1, r27	; 0x8007f1 <lastInterrupt+0x3>
      ea:	08 95       	ret

000000ec <Readings_Handler>:
	}
}

void Readings_Handler(void *pvParameters ){
      ec:	cf 93       	push	r28
      ee:	df 93       	push	r29
      f0:	cd b7       	in	r28, 0x3d	; 61
      f2:	de b7       	in	r29, 0x3e	; 62
      f4:	64 97       	sbiw	r28, 0x14	; 20
      f6:	0f b6       	in	r0, 0x3f	; 63
      f8:	f8 94       	cli
      fa:	de bf       	out	0x3e, r29	; 62
      fc:	0f be       	out	0x3f, r0	; 63
      fe:	cd bf       	out	0x3d, r28	; 61
     100:	1c 01       	movw	r2, r24
	QueueHandle_t* xQueue = (QueueHandle_t *)pvParameters;
	int const numberOfQs = 3;
	
	int Data[]={0,0,0};
     102:	1a 82       	std	Y+2, r1	; 0x02
     104:	19 82       	std	Y+1, r1	; 0x01
     106:	1c 82       	std	Y+4, r1	; 0x04
     108:	1b 82       	std	Y+3, r1	; 0x03
     10a:	1e 82       	std	Y+6, r1	; 0x06
     10c:	1d 82       	std	Y+5, r1	; 0x05
	BaseType_t Status[]={0,0,0};
	int Critical[] = {SMOKE_CRITICAL, TEMP_CRITICAL, WATER_LEVEL_CRITICAL};
     10e:	86 e0       	ldi	r24, 0x06	; 6
     110:	e4 e0       	ldi	r30, 0x04	; 4
     112:	f1 e0       	ldi	r31, 0x01	; 1
     114:	de 01       	movw	r26, r28
     116:	17 96       	adiw	r26, 0x07	; 7
     118:	01 90       	ld	r0, Z+
     11a:	0d 92       	st	X+, r0
     11c:	8a 95       	dec	r24
     11e:	e1 f7       	brne	.-8      	; 0x118 <Readings_Handler+0x2c>
	char* sensorName[] = {"Smoke: ", "Temperature: ", "Water Level: "};
     120:	86 e0       	ldi	r24, 0x06	; 6
     122:	ea e0       	ldi	r30, 0x0A	; 10
     124:	f1 e0       	ldi	r31, 0x01	; 1
     126:	de 01       	movw	r26, r28
     128:	1d 96       	adiw	r26, 0x0d	; 13
     12a:	01 90       	ld	r0, Z+
     12c:	0d 92       	st	X+, r0
     12e:	8a 95       	dec	r24
     130:	e1 f7       	brne	.-8      	; 0x12a <Readings_Handler+0x3e>
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
     132:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <xTaskGetTickCount>
     136:	9c 8b       	std	Y+20, r25	; 0x14
     138:	8b 8b       	std	Y+19, r24	; 0x13
     13a:	41 01       	movw	r8, r2
     13c:	26 e0       	ldi	r18, 0x06	; 6
     13e:	82 0e       	add	r8, r18
     140:	91 1c       	adc	r9, r1
     142:	71 01       	movw	r14, r2
     144:	8e 01       	movw	r16, r28
     146:	0f 5f       	subi	r16, 0xFF	; 255
     148:	1f 4f       	sbci	r17, 0xFF	; 255
     14a:	5e 01       	movw	r10, r28
     14c:	37 e0       	ldi	r19, 0x07	; 7
     14e:	a3 0e       	add	r10, r19
     150:	b1 1c       	adc	r11, r1
     152:	6e 01       	movw	r12, r28
     154:	8d e0       	ldi	r24, 0x0D	; 13
     156:	c8 0e       	add	r12, r24
     158:	d1 1c       	adc	r13, r1
	while(1)
	{
		for(int i = 0; i < numberOfQs; i++){
			Status[i] = xQueueReceive(xQueue[i], Data + i, 0);
     15a:	20 e0       	ldi	r18, 0x00	; 0
     15c:	40 e0       	ldi	r20, 0x00	; 0
     15e:	50 e0       	ldi	r21, 0x00	; 0
     160:	b8 01       	movw	r22, r16
     162:	f7 01       	movw	r30, r14
     164:	81 91       	ld	r24, Z+
     166:	91 91       	ld	r25, Z+
     168:	7f 01       	movw	r14, r30
     16a:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericReceive>
			
			if(Status[i] == pdPASS){
     16e:	81 30       	cpi	r24, 0x01	; 1
     170:	99 f5       	brne	.+102    	; 0x1d8 <Readings_Handler+0xec>
				Clear_LCD();
     172:	0e 94 42 02 	call	0x484	; 0x484 <Clear_LCD>
				byte isCritical = (Data[i] > Critical[i]);
     176:	f8 01       	movw	r30, r16
     178:	60 80       	ld	r6, Z
     17a:	71 80       	ldd	r7, Z+1	; 0x01
     17c:	f5 01       	movw	r30, r10
     17e:	40 80       	ld	r4, Z
     180:	51 80       	ldd	r5, Z+1	; 0x01
				PORTB |= (isCritical << buzzerPinB);
     182:	25 b1       	in	r18, 0x05	; 5
     184:	81 e0       	ldi	r24, 0x01	; 1
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	46 14       	cp	r4, r6
     18a:	57 04       	cpc	r5, r7
     18c:	14 f0       	brlt	.+4      	; 0x192 <Readings_Handler+0xa6>
     18e:	80 e0       	ldi	r24, 0x00	; 0
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	88 0f       	add	r24, r24
     194:	99 1f       	adc	r25, r25
     196:	82 95       	swap	r24
     198:	92 95       	swap	r25
     19a:	90 7f       	andi	r25, 0xF0	; 240
     19c:	98 27       	eor	r25, r24
     19e:	80 7f       	andi	r24, 0xF0	; 240
     1a0:	98 27       	eor	r25, r24
     1a2:	82 2b       	or	r24, r18
     1a4:	85 b9       	out	0x05, r24	; 5
				WriteDataString(sensorName[i]) ;
     1a6:	f6 01       	movw	r30, r12
     1a8:	80 81       	ld	r24, Z
     1aa:	91 81       	ldd	r25, Z+1	; 0x01
     1ac:	0e 94 79 02 	call	0x4f2	; 0x4f2 <WriteDataString>
				WriteDataString(isCritical ? "Critical" : "Normal");
     1b0:	46 14       	cp	r4, r6
     1b2:	57 04       	cpc	r5, r7
     1b4:	2c f0       	brlt	.+10     	; 0x1c0 <Readings_Handler+0xd4>
     1b6:	29 e1       	ldi	r18, 0x19	; 25
     1b8:	31 e0       	ldi	r19, 0x01	; 1
     1ba:	82 2f       	mov	r24, r18
     1bc:	93 2f       	mov	r25, r19
     1be:	04 c0       	rjmp	.+8      	; 0x1c8 <Readings_Handler+0xdc>
     1c0:	e0 e1       	ldi	r30, 0x10	; 16
     1c2:	f1 e0       	ldi	r31, 0x01	; 1
     1c4:	8e 2f       	mov	r24, r30
     1c6:	9f 2f       	mov	r25, r31
     1c8:	0e 94 79 02 	call	0x4f2	; 0x4f2 <WriteDataString>
				vTaskDelayUntil(&xLastWakeTime, (1500 / portTICK_PERIOD_MS));
     1cc:	6c ed       	ldi	r22, 0xDC	; 220
     1ce:	75 e0       	ldi	r23, 0x05	; 5
     1d0:	ce 01       	movw	r24, r28
     1d2:	43 96       	adiw	r24, 0x13	; 19
     1d4:	0e 94 ca 0a 	call	0x1594	; 0x1594 <vTaskDelayUntil>
     1d8:	0e 5f       	subi	r16, 0xFE	; 254
     1da:	1f 4f       	sbci	r17, 0xFF	; 255
     1dc:	f2 e0       	ldi	r31, 0x02	; 2
     1de:	af 0e       	add	r10, r31
     1e0:	b1 1c       	adc	r11, r1
     1e2:	22 e0       	ldi	r18, 0x02	; 2
     1e4:	c2 0e       	add	r12, r18
     1e6:	d1 1c       	adc	r13, r1
	char* sensorName[] = {"Smoke: ", "Temperature: ", "Water Level: "};
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
	while(1)
	{
		for(int i = 0; i < numberOfQs; i++){
     1e8:	e8 14       	cp	r14, r8
     1ea:	f9 04       	cpc	r15, r9
     1ec:	09 f0       	breq	.+2      	; 0x1f0 <Readings_Handler+0x104>
     1ee:	b5 cf       	rjmp	.-150    	; 0x15a <Readings_Handler+0x6e>
     1f0:	a8 cf       	rjmp	.-176    	; 0x142 <Readings_Handler+0x56>

000001f2 <Setup>:
}

void Setup()
{
	// Setup LCD
	LCD_Init();
     1f2:	0e 94 88 02 	call	0x510	; 0x510 <LCD_Init>
	
	// Set ADC
	ADMUX |= (1 << REFS0);
     1f6:	ec e7       	ldi	r30, 0x7C	; 124
     1f8:	f0 e0       	ldi	r31, 0x00	; 0
     1fa:	80 81       	ld	r24, Z
     1fc:	80 64       	ori	r24, 0x40	; 64
     1fe:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) | (1 << ADEN);
     200:	ea e7       	ldi	r30, 0x7A	; 122
     202:	f0 e0       	ldi	r31, 0x00	; 0
     204:	80 81       	ld	r24, Z
     206:	87 68       	ori	r24, 0x87	; 135
     208:	80 83       	st	Z, r24

	// Sensors modes
	DDRB = (1 << buzzerPinB);
     20a:	80 e2       	ldi	r24, 0x20	; 32
     20c:	84 b9       	out	0x04, r24	; 4
	PORTB = 0;
     20e:	15 b8       	out	0x05, r1	; 5
	DDRD = (1 << buttonPinD);
     210:	84 e0       	ldi	r24, 0x04	; 4
     212:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0;
     214:	1b b8       	out	0x0b, r1	; 11
	DDRC = 0;
     216:	17 b8       	out	0x07, r1	; 7
     218:	08 95       	ret

0000021a <main>:
#define TEMP_CRITICAL 50
#define SMOKE_CRITICAL 200
#define WATER_LEVEL_CRITICAL 200

int main(void)
{
     21a:	cf 93       	push	r28
     21c:	df 93       	push	r29
     21e:	00 d0       	rcall	.+0      	; 0x220 <main+0x6>
     220:	00 d0       	rcall	.+0      	; 0x222 <main+0x8>
     222:	00 d0       	rcall	.+0      	; 0x224 <main+0xa>
     224:	cd b7       	in	r28, 0x3d	; 61
     226:	de b7       	in	r29, 0x3e	; 62
	Setup();
     228:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <Setup>
	cli();
     22c:	f8 94       	cli
	attachInterrupt(0, Interrupt_Handler, 1);
     22e:	41 e0       	ldi	r20, 0x01	; 1
     230:	50 e0       	ldi	r21, 0x00	; 0
     232:	63 e5       	ldi	r22, 0x53	; 83
     234:	70 e0       	ldi	r23, 0x00	; 0
     236:	80 e0       	ldi	r24, 0x00	; 0
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <attachInterrupt>
	
	QueueHandle_t xQueue[3] = {0};
     23e:	fe 01       	movw	r30, r28
     240:	31 96       	adiw	r30, 0x01	; 1
     242:	86 e0       	ldi	r24, 0x06	; 6
     244:	df 01       	movw	r26, r30
     246:	1d 92       	st	X+, r1
     248:	8a 95       	dec	r24
     24a:	e9 f7       	brne	.-6      	; 0x246 <main+0x2c>
     24c:	8f 01       	movw	r16, r30
     24e:	7e 01       	movw	r14, r28
     250:	b7 e0       	ldi	r27, 0x07	; 7
     252:	eb 0e       	add	r14, r27
     254:	f1 1c       	adc	r15, r1
	for(int i = 0; i < 3; i++)
	xQueue[i] = xQueueCreate( 3, sizeof( void * ) );
     256:	40 e0       	ldi	r20, 0x00	; 0
     258:	62 e0       	ldi	r22, 0x02	; 2
     25a:	83 e0       	ldi	r24, 0x03	; 3
     25c:	0e 94 53 06 	call	0xca6	; 0xca6 <xQueueGenericCreate>
     260:	f8 01       	movw	r30, r16
     262:	81 93       	st	Z+, r24
     264:	91 93       	st	Z+, r25
     266:	8f 01       	movw	r16, r30
	Setup();
	cli();
	attachInterrupt(0, Interrupt_Handler, 1);
	
	QueueHandle_t xQueue[3] = {0};
	for(int i = 0; i < 3; i++)
     268:	ee 15       	cp	r30, r14
     26a:	ff 05       	cpc	r31, r15
     26c:	a1 f7       	brne	.-24     	; 0x256 <main+0x3c>
	xQueue[i] = xQueueCreate( 3, sizeof( void * ) );
	
	byte isReady = 1;
	for(int i = 0; i < 3; i++)
	isReady &= (xQueue[i] != NULL);
     26e:	91 e0       	ldi	r25, 0x01	; 1
     270:	29 81       	ldd	r18, Y+1	; 0x01
     272:	3a 81       	ldd	r19, Y+2	; 0x02
     274:	23 2b       	or	r18, r19
     276:	09 f4       	brne	.+2      	; 0x27a <main+0x60>
     278:	90 e0       	ldi	r25, 0x00	; 0
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	2b 81       	ldd	r18, Y+3	; 0x03
     27e:	3c 81       	ldd	r19, Y+4	; 0x04
     280:	23 2b       	or	r18, r19
     282:	09 f4       	brne	.+2      	; 0x286 <main+0x6c>
     284:	80 e0       	ldi	r24, 0x00	; 0
     286:	89 23       	and	r24, r25
     288:	91 e0       	ldi	r25, 0x01	; 1
     28a:	2d 81       	ldd	r18, Y+5	; 0x05
     28c:	3e 81       	ldd	r19, Y+6	; 0x06
     28e:	23 2b       	or	r18, r19
     290:	09 f4       	brne	.+2      	; 0x294 <main+0x7a>
     292:	90 e0       	ldi	r25, 0x00	; 0
     294:	89 23       	and	r24, r25
	if( isReady)
     296:	b9 f1       	breq	.+110    	; 0x306 <main+0xec>
	{
		xTaskCreate(Smoke_Sensor_Handler,(const char*)"Smoke Sensor Handler", 256, xQueue, 4, NULL);
     298:	a1 2c       	mov	r10, r1
     29a:	b1 2c       	mov	r11, r1
     29c:	c1 2c       	mov	r12, r1
     29e:	d1 2c       	mov	r13, r1
     2a0:	e1 2c       	mov	r14, r1
     2a2:	f1 2c       	mov	r15, r1
     2a4:	04 e0       	ldi	r16, 0x04	; 4
     2a6:	9e 01       	movw	r18, r28
     2a8:	2f 5f       	subi	r18, 0xFF	; 255
     2aa:	3f 4f       	sbci	r19, 0xFF	; 255
     2ac:	40 e0       	ldi	r20, 0x00	; 0
     2ae:	51 e0       	ldi	r21, 0x01	; 1
     2b0:	64 e4       	ldi	r22, 0x44	; 68
     2b2:	71 e0       	ldi	r23, 0x01	; 1
     2b4:	86 e9       	ldi	r24, 0x96	; 150
     2b6:	91 e0       	ldi	r25, 0x01	; 1
     2b8:	0e 94 39 08 	call	0x1072	; 0x1072 <xTaskGenericCreate>
		xTaskCreate(Temp_Sensor_Handler,(const char*)"Temp Sensor Handler", 256, xQueue + 1, 4, NULL);
     2bc:	9e 01       	movw	r18, r28
     2be:	2d 5f       	subi	r18, 0xFD	; 253
     2c0:	3f 4f       	sbci	r19, 0xFF	; 255
     2c2:	40 e0       	ldi	r20, 0x00	; 0
     2c4:	51 e0       	ldi	r21, 0x01	; 1
     2c6:	69 e5       	ldi	r22, 0x59	; 89
     2c8:	71 e0       	ldi	r23, 0x01	; 1
     2ca:	88 eb       	ldi	r24, 0xB8	; 184
     2cc:	91 e0       	ldi	r25, 0x01	; 1
     2ce:	0e 94 39 08 	call	0x1072	; 0x1072 <xTaskGenericCreate>
		xTaskCreate(Water_Depth_Sensor_Handler,(const char*)"Water Depth Sensor Handler", 240, xQueue + 2, 4, NULL);
     2d2:	9e 01       	movw	r18, r28
     2d4:	2b 5f       	subi	r18, 0xFB	; 251
     2d6:	3f 4f       	sbci	r19, 0xFF	; 255
     2d8:	40 ef       	ldi	r20, 0xF0	; 240
     2da:	50 e0       	ldi	r21, 0x00	; 0
     2dc:	6d e6       	ldi	r22, 0x6D	; 109
     2de:	71 e0       	ldi	r23, 0x01	; 1
     2e0:	8f ee       	ldi	r24, 0xEF	; 239
     2e2:	91 e0       	ldi	r25, 0x01	; 1
     2e4:	0e 94 39 08 	call	0x1072	; 0x1072 <xTaskGenericCreate>
		xTaskCreate(Readings_Handler,(const char*)"Readings Handler", 256 , xQueue, 3, NULL);
     2e8:	03 e0       	ldi	r16, 0x03	; 3
     2ea:	9e 01       	movw	r18, r28
     2ec:	2f 5f       	subi	r18, 0xFF	; 255
     2ee:	3f 4f       	sbci	r19, 0xFF	; 255
     2f0:	40 e0       	ldi	r20, 0x00	; 0
     2f2:	51 e0       	ldi	r21, 0x01	; 1
     2f4:	68 e8       	ldi	r22, 0x88	; 136
     2f6:	71 e0       	ldi	r23, 0x01	; 1
     2f8:	86 e7       	ldi	r24, 0x76	; 118
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	0e 94 39 08 	call	0x1072	; 0x1072 <xTaskGenericCreate>

		sei();
     300:	78 94       	sei

		vTaskStartScheduler();
     302:	0e 94 47 09 	call	0x128e	; 0x128e <vTaskStartScheduler>
     306:	ff cf       	rjmp	.-2      	; 0x306 <main+0xec>

00000308 <Analog_Read>:
	PORTD = 0;
	DDRC = 0;
}

int Analog_Read(uint8_t pin){
	ADMUX |= pin;
     308:	ec e7       	ldi	r30, 0x7C	; 124
     30a:	f0 e0       	ldi	r31, 0x00	; 0
     30c:	90 81       	ld	r25, Z
     30e:	89 2b       	or	r24, r25
     310:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADSC);
     312:	ea e7       	ldi	r30, 0x7A	; 122
     314:	f0 e0       	ldi	r31, 0x00	; 0
     316:	80 81       	ld	r24, Z
     318:	80 64       	ori	r24, 0x40	; 64
     31a:	80 83       	st	Z, r24
	
	while(ADCSRA & (1 << ADSC));
     31c:	80 81       	ld	r24, Z
     31e:	86 fd       	sbrc	r24, 6
     320:	fd cf       	rjmp	.-6      	; 0x31c <Analog_Read+0x14>
	
	return ADC;
     322:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     326:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
}
     32a:	08 95       	ret

0000032c <Smoke_Sensor_Handler>:
				vTaskDelayUntil(&xLastWakeTime, (1500 / portTICK_PERIOD_MS));
			}
		}
	}
}
void Smoke_Sensor_Handler( void *pvParameters){
     32c:	cf 93       	push	r28
     32e:	df 93       	push	r29
     330:	00 d0       	rcall	.+0      	; 0x332 <Smoke_Sensor_Handler+0x6>
     332:	00 d0       	rcall	.+0      	; 0x334 <Smoke_Sensor_Handler+0x8>
     334:	cd b7       	in	r28, 0x3d	; 61
     336:	de b7       	in	r29, 0x3e	; 62
     338:	8c 01       	movw	r16, r24
	QueueHandle_t* xQueue = (QueueHandle_t *)pvParameters;
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
     33a:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <xTaskGetTickCount>
     33e:	9a 83       	std	Y+2, r25	; 0x02
     340:	89 83       	std	Y+1, r24	; 0x01
	int smokeValue;
	while( 1 )
	{
		smokeValue = Analog_Read(smokePinB);
     342:	82 e0       	ldi	r24, 0x02	; 2
     344:	0e 94 84 01 	call	0x308	; 0x308 <Analog_Read>
     348:	9c 83       	std	Y+4, r25	; 0x04
     34a:	8b 83       	std	Y+3, r24	; 0x03
		xQueueSendToBack( *xQueue, &smokeValue, 0 );
     34c:	20 e0       	ldi	r18, 0x00	; 0
     34e:	40 e0       	ldi	r20, 0x00	; 0
     350:	50 e0       	ldi	r21, 0x00	; 0
     352:	be 01       	movw	r22, r28
     354:	6d 5f       	subi	r22, 0xFD	; 253
     356:	7f 4f       	sbci	r23, 0xFF	; 255
     358:	f8 01       	movw	r30, r16
     35a:	80 81       	ld	r24, Z
     35c:	91 81       	ldd	r25, Z+1	; 0x01
     35e:	0e 94 7f 06 	call	0xcfe	; 0xcfe <xQueueGenericSend>
		vTaskDelayUntil(&xLastWakeTime, (2000 / portTICK_PERIOD_MS));
     362:	60 ed       	ldi	r22, 0xD0	; 208
     364:	77 e0       	ldi	r23, 0x07	; 7
     366:	ce 01       	movw	r24, r28
     368:	01 96       	adiw	r24, 0x01	; 1
     36a:	0e 94 ca 0a 	call	0x1594	; 0x1594 <vTaskDelayUntil>
     36e:	e9 cf       	rjmp	.-46     	; 0x342 <Smoke_Sensor_Handler+0x16>

00000370 <Temp_Sensor_Handler>:
	}
}

void Temp_Sensor_Handler( void *pvParameters ){
     370:	cf 93       	push	r28
     372:	df 93       	push	r29
     374:	00 d0       	rcall	.+0      	; 0x376 <Temp_Sensor_Handler+0x6>
     376:	00 d0       	rcall	.+0      	; 0x378 <Temp_Sensor_Handler+0x8>
     378:	00 d0       	rcall	.+0      	; 0x37a <Temp_Sensor_Handler+0xa>
     37a:	cd b7       	in	r28, 0x3d	; 61
     37c:	de b7       	in	r29, 0x3e	; 62
     37e:	8c 01       	movw	r16, r24
	QueueHandle_t* xQueue = (QueueHandle_t *)pvParameters;
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
     380:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <xTaskGetTickCount>
     384:	9a 83       	std	Y+2, r25	; 0x02
     386:	89 83       	std	Y+1, r24	; 0x01
	float tempvalue;
	while( 1 )
	{
		tempvalue = (Analog_Read(tempPinC) * 4.88); /* Convert ADC value to equivalent voltage */
     388:	83 e0       	ldi	r24, 0x03	; 3
     38a:	0e 94 84 01 	call	0x308	; 0x308 <Analog_Read>
		tempvalue = (tempvalue/10); /* LM35 gives output of 10mv/°C */
     38e:	bc 01       	movw	r22, r24
     390:	99 0f       	add	r25, r25
     392:	88 0b       	sbc	r24, r24
     394:	99 0b       	sbc	r25, r25
     396:	0e 94 17 0e 	call	0x1c2e	; 0x1c2e <__floatsisf>
     39a:	26 ef       	ldi	r18, 0xF6	; 246
     39c:	38 e2       	ldi	r19, 0x28	; 40
     39e:	4c e9       	ldi	r20, 0x9C	; 156
     3a0:	50 e4       	ldi	r21, 0x40	; 64
     3a2:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <__mulsf3>
     3a6:	20 e0       	ldi	r18, 0x00	; 0
     3a8:	30 e0       	ldi	r19, 0x00	; 0
     3aa:	40 e2       	ldi	r20, 0x20	; 32
     3ac:	51 e4       	ldi	r21, 0x41	; 65
     3ae:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <__divsf3>
     3b2:	6b 83       	std	Y+3, r22	; 0x03
     3b4:	7c 83       	std	Y+4, r23	; 0x04
     3b6:	8d 83       	std	Y+5, r24	; 0x05
     3b8:	9e 83       	std	Y+6, r25	; 0x06
		xQueueSendToBack( *xQueue, &tempvalue, 0 );
     3ba:	20 e0       	ldi	r18, 0x00	; 0
     3bc:	40 e0       	ldi	r20, 0x00	; 0
     3be:	50 e0       	ldi	r21, 0x00	; 0
     3c0:	be 01       	movw	r22, r28
     3c2:	6d 5f       	subi	r22, 0xFD	; 253
     3c4:	7f 4f       	sbci	r23, 0xFF	; 255
     3c6:	f8 01       	movw	r30, r16
     3c8:	80 81       	ld	r24, Z
     3ca:	91 81       	ldd	r25, Z+1	; 0x01
     3cc:	0e 94 7f 06 	call	0xcfe	; 0xcfe <xQueueGenericSend>
		vTaskDelayUntil(&xLastWakeTime, (2000 / portTICK_PERIOD_MS));
     3d0:	60 ed       	ldi	r22, 0xD0	; 208
     3d2:	77 e0       	ldi	r23, 0x07	; 7
     3d4:	ce 01       	movw	r24, r28
     3d6:	01 96       	adiw	r24, 0x01	; 1
     3d8:	0e 94 ca 0a 	call	0x1594	; 0x1594 <vTaskDelayUntil>
     3dc:	d5 cf       	rjmp	.-86     	; 0x388 <Temp_Sensor_Handler+0x18>

000003de <Water_Depth_Sensor_Handler>:
	}
}
void Water_Depth_Sensor_Handler( void *pvParameters ){
     3de:	cf 93       	push	r28
     3e0:	df 93       	push	r29
     3e2:	00 d0       	rcall	.+0      	; 0x3e4 <Water_Depth_Sensor_Handler+0x6>
     3e4:	00 d0       	rcall	.+0      	; 0x3e6 <Water_Depth_Sensor_Handler+0x8>
     3e6:	cd b7       	in	r28, 0x3d	; 61
     3e8:	de b7       	in	r29, 0x3e	; 62
     3ea:	8c 01       	movw	r16, r24
	int waterDepthValue=0;
     3ec:	1a 82       	std	Y+2, r1	; 0x02
     3ee:	19 82       	std	Y+1, r1	; 0x01
	QueueHandle_t* xQueue = (QueueHandle_t *)pvParameters;
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
     3f0:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <xTaskGetTickCount>
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03
	while( 1 )
	{
		waterDepthValue = Analog_Read(waterPinC);
     3f8:	84 e0       	ldi	r24, 0x04	; 4
     3fa:	0e 94 84 01 	call	0x308	; 0x308 <Analog_Read>
     3fe:	9a 83       	std	Y+2, r25	; 0x02
     400:	89 83       	std	Y+1, r24	; 0x01
		xQueueSendToBack( *xQueue, &waterDepthValue, 0 );
     402:	20 e0       	ldi	r18, 0x00	; 0
     404:	40 e0       	ldi	r20, 0x00	; 0
     406:	50 e0       	ldi	r21, 0x00	; 0
     408:	be 01       	movw	r22, r28
     40a:	6f 5f       	subi	r22, 0xFF	; 255
     40c:	7f 4f       	sbci	r23, 0xFF	; 255
     40e:	f8 01       	movw	r30, r16
     410:	80 81       	ld	r24, Z
     412:	91 81       	ldd	r25, Z+1	; 0x01
     414:	0e 94 7f 06 	call	0xcfe	; 0xcfe <xQueueGenericSend>
		vTaskDelayUntil(&xLastWakeTime, (2000 / portTICK_PERIOD_MS));
     418:	60 ed       	ldi	r22, 0xD0	; 208
     41a:	77 e0       	ldi	r23, 0x07	; 7
     41c:	ce 01       	movw	r24, r28
     41e:	03 96       	adiw	r24, 0x03	; 3
     420:	0e 94 ca 0a 	call	0x1594	; 0x1594 <vTaskDelayUntil>
     424:	e9 cf       	rjmp	.-46     	; 0x3f8 <Water_Depth_Sensor_Handler+0x1a>

00000426 <WriteCommand>:
	//_delay_ms(2);
	WriteCommand (0x80);		/* Cursor at home position */
}
void WriteCommand(char comm)
{
	DDRD = 0xff;//BITDATA
     426:	9f ef       	ldi	r25, 0xFF	; 255
     428:	9a b9       	out	0x0a, r25	; 10
	DDRC = 0xff;//EN,RS
     42a:	97 b9       	out	0x07, r25	; 7
	
	PORTC &= ~ (1<<RS);	
     42c:	41 98       	cbi	0x08, 1	; 8
	PORTD = (PORTD & 0x0F) | (comm & 0xF0);
     42e:	9b b1       	in	r25, 0x0b	; 11
     430:	9f 70       	andi	r25, 0x0F	; 15
     432:	28 2f       	mov	r18, r24
     434:	20 7f       	andi	r18, 0xF0	; 240
     436:	92 2b       	or	r25, r18
     438:	9b b9       	out	0x0b, r25	; 11
		
	PORTC|= (1<<EN);		
     43a:	40 9a       	sbi	0x08, 0	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     43c:	e9 ef       	ldi	r30, 0xF9	; 249
     43e:	f0 e0       	ldi	r31, 0x00	; 0
     440:	31 97       	sbiw	r30, 0x01	; 1
     442:	f1 f7       	brne	.-4      	; 0x440 <WriteCommand+0x1a>
     444:	00 c0       	rjmp	.+0      	; 0x446 <WriteCommand+0x20>
     446:	00 00       	nop
	_delay_ms(1);
	PORTC &= ~ (1<<EN);
     448:	40 98       	cbi	0x08, 0	; 8
     44a:	e3 ef       	ldi	r30, 0xF3	; 243
     44c:	f1 e0       	ldi	r31, 0x01	; 1
     44e:	31 97       	sbiw	r30, 0x01	; 1
     450:	f1 f7       	brne	.-4      	; 0x44e <WriteCommand+0x28>
     452:	00 c0       	rjmp	.+0      	; 0x454 <WriteCommand+0x2e>
     454:	00 00       	nop
	_delay_ms(2);
	PORTD = (PORTD & 0x0F) |( (comm << 4));
     456:	2b b1       	in	r18, 0x0b	; 11
     458:	2f 70       	andi	r18, 0x0F	; 15
     45a:	f0 e1       	ldi	r31, 0x10	; 16
     45c:	8f 9f       	mul	r24, r31
     45e:	c0 01       	movw	r24, r0
     460:	11 24       	eor	r1, r1
     462:	82 2b       	or	r24, r18
     464:	8b b9       	out	0x0b, r24	; 11
	PORTC |= (1<<EN);
     466:	40 9a       	sbi	0x08, 0	; 8
     468:	83 ef       	ldi	r24, 0xF3	; 243
     46a:	91 e0       	ldi	r25, 0x01	; 1
     46c:	01 97       	sbiw	r24, 0x01	; 1
     46e:	f1 f7       	brne	.-4      	; 0x46c <WriteCommand+0x46>
     470:	00 c0       	rjmp	.+0      	; 0x472 <WriteCommand+0x4c>
     472:	00 00       	nop
	_delay_ms(2);
	PORTC&= ~ (1<<EN);
     474:	40 98       	cbi	0x08, 0	; 8
     476:	eb e5       	ldi	r30, 0x5B	; 91
     478:	f4 e4       	ldi	r31, 0x44	; 68
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	f1 f7       	brne	.-4      	; 0x47a <WriteCommand+0x54>
     47e:	00 c0       	rjmp	.+0      	; 0x480 <WriteCommand+0x5a>
     480:	00 00       	nop
     482:	08 95       	ret

00000484 <Clear_LCD>:
#define FirstLine 0x80
#define SecondLine 0xc0

void Clear_LCD()
{
	WriteCommand(0x01);
     484:	81 e0       	ldi	r24, 0x01	; 1
     486:	0e 94 13 02 	call	0x426	; 0x426 <WriteCommand>
	//LCD_Command (0x01);		/* Clear display */
	//_delay_ms(2);
	WriteCommand (0x80);		/* Cursor at home position */
     48a:	80 e8       	ldi	r24, 0x80	; 128
     48c:	0e 94 13 02 	call	0x426	; 0x426 <WriteCommand>
     490:	08 95       	ret

00000492 <WriteDataChar>:
	
}

void WriteDataChar(char data)
{
	DDRD = 0xf0;
     492:	90 ef       	ldi	r25, 0xF0	; 240
     494:	9a b9       	out	0x0a, r25	; 10
	DDRC = 0x03;
     496:	93 e0       	ldi	r25, 0x03	; 3
     498:	97 b9       	out	0x07, r25	; 7
	PORTC|= (1<<RS);
     49a:	41 9a       	sbi	0x08, 1	; 8
	PORTD = (PORTD & 0x0F) | (data & 0xF0);
     49c:	9b b1       	in	r25, 0x0b	; 11
     49e:	9f 70       	andi	r25, 0x0F	; 15
     4a0:	28 2f       	mov	r18, r24
     4a2:	20 7f       	andi	r18, 0xF0	; 240
     4a4:	92 2b       	or	r25, r18
     4a6:	9b b9       	out	0x0b, r25	; 11
			
	PORTC |= (1<<EN);		
     4a8:	40 9a       	sbi	0x08, 0	; 8
     4aa:	e9 ef       	ldi	r30, 0xF9	; 249
     4ac:	f0 e0       	ldi	r31, 0x00	; 0
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	f1 f7       	brne	.-4      	; 0x4ae <WriteDataChar+0x1c>
     4b2:	00 c0       	rjmp	.+0      	; 0x4b4 <WriteDataChar+0x22>
     4b4:	00 00       	nop
	_delay_ms(1);
	PORTC &= ~ (1<<EN);
     4b6:	40 98       	cbi	0x08, 0	; 8
     4b8:	e9 ef       	ldi	r30, 0xF9	; 249
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	f1 f7       	brne	.-4      	; 0x4bc <WriteDataChar+0x2a>
     4c0:	00 c0       	rjmp	.+0      	; 0x4c2 <WriteDataChar+0x30>
     4c2:	00 00       	nop
	_delay_ms(1);
	PORTD = (PORTD & 0x0F) | ((data << 4));
     4c4:	2b b1       	in	r18, 0x0b	; 11
     4c6:	2f 70       	andi	r18, 0x0F	; 15
     4c8:	f0 e1       	ldi	r31, 0x10	; 16
     4ca:	8f 9f       	mul	r24, r31
     4cc:	c0 01       	movw	r24, r0
     4ce:	11 24       	eor	r1, r1
     4d0:	82 2b       	or	r24, r18
     4d2:	8b b9       	out	0x0b, r24	; 11
	PORTC |= (1<<EN);
     4d4:	40 9a       	sbi	0x08, 0	; 8
     4d6:	89 ef       	ldi	r24, 0xF9	; 249
     4d8:	90 e0       	ldi	r25, 0x00	; 0
     4da:	01 97       	sbiw	r24, 0x01	; 1
     4dc:	f1 f7       	brne	.-4      	; 0x4da <WriteDataChar+0x48>
     4de:	00 c0       	rjmp	.+0      	; 0x4e0 <WriteDataChar+0x4e>
     4e0:	00 00       	nop
	_delay_ms(1);
	PORTC &= ~ (1<<EN);
     4e2:	40 98       	cbi	0x08, 0	; 8
     4e4:	e3 ef       	ldi	r30, 0xF3	; 243
     4e6:	f1 e0       	ldi	r31, 0x01	; 1
     4e8:	31 97       	sbiw	r30, 0x01	; 1
     4ea:	f1 f7       	brne	.-4      	; 0x4e8 <WriteDataChar+0x56>
     4ec:	00 c0       	rjmp	.+0      	; 0x4ee <WriteDataChar+0x5c>
     4ee:	00 00       	nop
     4f0:	08 95       	ret

000004f2 <WriteDataString>:
	_delay_ms(2);
	
}
void WriteDataString(char *string_of_characters)
{
     4f2:	cf 93       	push	r28
     4f4:	df 93       	push	r29
     4f6:	ec 01       	movw	r28, r24
	while(*string_of_characters > 0)
     4f8:	88 81       	ld	r24, Y
     4fa:	88 23       	and	r24, r24
     4fc:	31 f0       	breq	.+12     	; 0x50a <WriteDataString+0x18>
     4fe:	21 96       	adiw	r28, 0x01	; 1
	{
		WriteDataChar(*string_of_characters++);
     500:	0e 94 49 02 	call	0x492	; 0x492 <WriteDataChar>
	_delay_ms(2);
	
}
void WriteDataString(char *string_of_characters)
{
	while(*string_of_characters > 0)
     504:	89 91       	ld	r24, Y+
     506:	81 11       	cpse	r24, r1
     508:	fb cf       	rjmp	.-10     	; 0x500 <WriteDataString+0xe>
	{
		WriteDataChar(*string_of_characters++);
	}
}
     50a:	df 91       	pop	r29
     50c:	cf 91       	pop	r28
     50e:	08 95       	ret

00000510 <LCD_Init>:
void LCD_Init()
{
	WriteCommand(0x33);
     510:	83 e3       	ldi	r24, 0x33	; 51
     512:	0e 94 13 02 	call	0x426	; 0x426 <WriteCommand>
	WriteCommand(0x32);	
     516:	82 e3       	ldi	r24, 0x32	; 50
     518:	0e 94 13 02 	call	0x426	; 0x426 <WriteCommand>
	WriteCommand(0x28);	
     51c:	88 e2       	ldi	r24, 0x28	; 40
     51e:	0e 94 13 02 	call	0x426	; 0x426 <WriteCommand>
	WriteCommand(0x0c);	
     522:	8c e0       	ldi	r24, 0x0C	; 12
     524:	0e 94 13 02 	call	0x426	; 0x426 <WriteCommand>
	WriteCommand(0x06);	
     528:	86 e0       	ldi	r24, 0x06	; 6
     52a:	0e 94 13 02 	call	0x426	; 0x426 <WriteCommand>
	WriteCommand(0x01);
     52e:	81 e0       	ldi	r24, 0x01	; 1
     530:	0e 94 13 02 	call	0x426	; 0x426 <WriteCommand>
     534:	08 95       	ret

00000536 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     536:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     538:	03 96       	adiw	r24, 0x03	; 3
     53a:	92 83       	std	Z+2, r25	; 0x02
     53c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     53e:	2f ef       	ldi	r18, 0xFF	; 255
     540:	3f ef       	ldi	r19, 0xFF	; 255
     542:	34 83       	std	Z+4, r19	; 0x04
     544:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     546:	96 83       	std	Z+6, r25	; 0x06
     548:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     54a:	90 87       	std	Z+8, r25	; 0x08
     54c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     54e:	10 82       	st	Z, r1
     550:	08 95       	ret

00000552 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     552:	fc 01       	movw	r30, r24
     554:	11 86       	std	Z+9, r1	; 0x09
     556:	10 86       	std	Z+8, r1	; 0x08
     558:	08 95       	ret

0000055a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     55a:	cf 93       	push	r28
     55c:	df 93       	push	r29
     55e:	9c 01       	movw	r18, r24
     560:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     562:	dc 01       	movw	r26, r24
     564:	11 96       	adiw	r26, 0x01	; 1
     566:	cd 91       	ld	r28, X+
     568:	dc 91       	ld	r29, X
     56a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     56c:	d3 83       	std	Z+3, r29	; 0x03
     56e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     570:	8c 81       	ldd	r24, Y+4	; 0x04
     572:	9d 81       	ldd	r25, Y+5	; 0x05
     574:	95 83       	std	Z+5, r25	; 0x05
     576:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     578:	8c 81       	ldd	r24, Y+4	; 0x04
     57a:	9d 81       	ldd	r25, Y+5	; 0x05
     57c:	dc 01       	movw	r26, r24
     57e:	13 96       	adiw	r26, 0x03	; 3
     580:	7c 93       	st	X, r23
     582:	6e 93       	st	-X, r22
     584:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     586:	7d 83       	std	Y+5, r23	; 0x05
     588:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     58a:	31 87       	std	Z+9, r19	; 0x09
     58c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     58e:	f9 01       	movw	r30, r18
     590:	80 81       	ld	r24, Z
     592:	8f 5f       	subi	r24, 0xFF	; 255
     594:	80 83       	st	Z, r24
}
     596:	df 91       	pop	r29
     598:	cf 91       	pop	r28
     59a:	08 95       	ret

0000059c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     59c:	cf 93       	push	r28
     59e:	df 93       	push	r29
     5a0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     5a2:	48 81       	ld	r20, Y
     5a4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5a6:	4f 3f       	cpi	r20, 0xFF	; 255
     5a8:	2f ef       	ldi	r18, 0xFF	; 255
     5aa:	52 07       	cpc	r21, r18
     5ac:	21 f4       	brne	.+8      	; 0x5b6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5ae:	fc 01       	movw	r30, r24
     5b0:	a7 81       	ldd	r26, Z+7	; 0x07
     5b2:	b0 85       	ldd	r27, Z+8	; 0x08
     5b4:	0d c0       	rjmp	.+26     	; 0x5d0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5b6:	dc 01       	movw	r26, r24
     5b8:	13 96       	adiw	r26, 0x03	; 3
     5ba:	01 c0       	rjmp	.+2      	; 0x5be <vListInsert+0x22>
     5bc:	df 01       	movw	r26, r30
     5be:	12 96       	adiw	r26, 0x02	; 2
     5c0:	ed 91       	ld	r30, X+
     5c2:	fc 91       	ld	r31, X
     5c4:	13 97       	sbiw	r26, 0x03	; 3
     5c6:	20 81       	ld	r18, Z
     5c8:	31 81       	ldd	r19, Z+1	; 0x01
     5ca:	42 17       	cp	r20, r18
     5cc:	53 07       	cpc	r21, r19
     5ce:	b0 f7       	brcc	.-20     	; 0x5bc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5d0:	12 96       	adiw	r26, 0x02	; 2
     5d2:	ed 91       	ld	r30, X+
     5d4:	fc 91       	ld	r31, X
     5d6:	13 97       	sbiw	r26, 0x03	; 3
     5d8:	fb 83       	std	Y+3, r31	; 0x03
     5da:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     5dc:	d5 83       	std	Z+5, r29	; 0x05
     5de:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5e0:	bd 83       	std	Y+5, r27	; 0x05
     5e2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5e4:	13 96       	adiw	r26, 0x03	; 3
     5e6:	dc 93       	st	X, r29
     5e8:	ce 93       	st	-X, r28
     5ea:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5ec:	99 87       	std	Y+9, r25	; 0x09
     5ee:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     5f0:	fc 01       	movw	r30, r24
     5f2:	20 81       	ld	r18, Z
     5f4:	2f 5f       	subi	r18, 0xFF	; 255
     5f6:	20 83       	st	Z, r18
}
     5f8:	df 91       	pop	r29
     5fa:	cf 91       	pop	r28
     5fc:	08 95       	ret

000005fe <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     5fe:	cf 93       	push	r28
     600:	df 93       	push	r29
     602:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     604:	a0 85       	ldd	r26, Z+8	; 0x08
     606:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     608:	c2 81       	ldd	r28, Z+2	; 0x02
     60a:	d3 81       	ldd	r29, Z+3	; 0x03
     60c:	84 81       	ldd	r24, Z+4	; 0x04
     60e:	95 81       	ldd	r25, Z+5	; 0x05
     610:	9d 83       	std	Y+5, r25	; 0x05
     612:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     614:	c4 81       	ldd	r28, Z+4	; 0x04
     616:	d5 81       	ldd	r29, Z+5	; 0x05
     618:	82 81       	ldd	r24, Z+2	; 0x02
     61a:	93 81       	ldd	r25, Z+3	; 0x03
     61c:	9b 83       	std	Y+3, r25	; 0x03
     61e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     620:	11 96       	adiw	r26, 0x01	; 1
     622:	8d 91       	ld	r24, X+
     624:	9c 91       	ld	r25, X
     626:	12 97       	sbiw	r26, 0x02	; 2
     628:	e8 17       	cp	r30, r24
     62a:	f9 07       	cpc	r31, r25
     62c:	31 f4       	brne	.+12     	; 0x63a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     62e:	84 81       	ldd	r24, Z+4	; 0x04
     630:	95 81       	ldd	r25, Z+5	; 0x05
     632:	12 96       	adiw	r26, 0x02	; 2
     634:	9c 93       	st	X, r25
     636:	8e 93       	st	-X, r24
     638:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     63a:	11 86       	std	Z+9, r1	; 0x09
     63c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     63e:	8c 91       	ld	r24, X
     640:	81 50       	subi	r24, 0x01	; 1
     642:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     644:	df 91       	pop	r29
     646:	cf 91       	pop	r28
     648:	08 95       	ret

0000064a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     64a:	31 e1       	ldi	r19, 0x11	; 17
     64c:	fc 01       	movw	r30, r24
     64e:	30 83       	st	Z, r19
     650:	31 97       	sbiw	r30, 0x01	; 1
     652:	22 e2       	ldi	r18, 0x22	; 34
     654:	20 83       	st	Z, r18
     656:	31 97       	sbiw	r30, 0x01	; 1
     658:	a3 e3       	ldi	r26, 0x33	; 51
     65a:	a0 83       	st	Z, r26
     65c:	31 97       	sbiw	r30, 0x01	; 1
     65e:	60 83       	st	Z, r22
     660:	31 97       	sbiw	r30, 0x01	; 1
     662:	70 83       	st	Z, r23
     664:	31 97       	sbiw	r30, 0x01	; 1
     666:	10 82       	st	Z, r1
     668:	31 97       	sbiw	r30, 0x01	; 1
     66a:	60 e8       	ldi	r22, 0x80	; 128
     66c:	60 83       	st	Z, r22
     66e:	31 97       	sbiw	r30, 0x01	; 1
     670:	10 82       	st	Z, r1
     672:	31 97       	sbiw	r30, 0x01	; 1
     674:	62 e0       	ldi	r22, 0x02	; 2
     676:	60 83       	st	Z, r22
     678:	31 97       	sbiw	r30, 0x01	; 1
     67a:	63 e0       	ldi	r22, 0x03	; 3
     67c:	60 83       	st	Z, r22
     67e:	31 97       	sbiw	r30, 0x01	; 1
     680:	64 e0       	ldi	r22, 0x04	; 4
     682:	60 83       	st	Z, r22
     684:	31 97       	sbiw	r30, 0x01	; 1
     686:	65 e0       	ldi	r22, 0x05	; 5
     688:	60 83       	st	Z, r22
     68a:	31 97       	sbiw	r30, 0x01	; 1
     68c:	66 e0       	ldi	r22, 0x06	; 6
     68e:	60 83       	st	Z, r22
     690:	31 97       	sbiw	r30, 0x01	; 1
     692:	67 e0       	ldi	r22, 0x07	; 7
     694:	60 83       	st	Z, r22
     696:	31 97       	sbiw	r30, 0x01	; 1
     698:	68 e0       	ldi	r22, 0x08	; 8
     69a:	60 83       	st	Z, r22
     69c:	31 97       	sbiw	r30, 0x01	; 1
     69e:	69 e0       	ldi	r22, 0x09	; 9
     6a0:	60 83       	st	Z, r22
     6a2:	31 97       	sbiw	r30, 0x01	; 1
     6a4:	60 e1       	ldi	r22, 0x10	; 16
     6a6:	60 83       	st	Z, r22
     6a8:	31 97       	sbiw	r30, 0x01	; 1
     6aa:	30 83       	st	Z, r19
     6ac:	31 97       	sbiw	r30, 0x01	; 1
     6ae:	32 e1       	ldi	r19, 0x12	; 18
     6b0:	30 83       	st	Z, r19
     6b2:	31 97       	sbiw	r30, 0x01	; 1
     6b4:	33 e1       	ldi	r19, 0x13	; 19
     6b6:	30 83       	st	Z, r19
     6b8:	31 97       	sbiw	r30, 0x01	; 1
     6ba:	34 e1       	ldi	r19, 0x14	; 20
     6bc:	30 83       	st	Z, r19
     6be:	31 97       	sbiw	r30, 0x01	; 1
     6c0:	35 e1       	ldi	r19, 0x15	; 21
     6c2:	30 83       	st	Z, r19
     6c4:	31 97       	sbiw	r30, 0x01	; 1
     6c6:	36 e1       	ldi	r19, 0x16	; 22
     6c8:	30 83       	st	Z, r19
     6ca:	31 97       	sbiw	r30, 0x01	; 1
     6cc:	37 e1       	ldi	r19, 0x17	; 23
     6ce:	30 83       	st	Z, r19
     6d0:	31 97       	sbiw	r30, 0x01	; 1
     6d2:	38 e1       	ldi	r19, 0x18	; 24
     6d4:	30 83       	st	Z, r19
     6d6:	31 97       	sbiw	r30, 0x01	; 1
     6d8:	39 e1       	ldi	r19, 0x19	; 25
     6da:	30 83       	st	Z, r19
     6dc:	31 97       	sbiw	r30, 0x01	; 1
     6de:	30 e2       	ldi	r19, 0x20	; 32
     6e0:	30 83       	st	Z, r19
     6e2:	31 97       	sbiw	r30, 0x01	; 1
     6e4:	31 e2       	ldi	r19, 0x21	; 33
     6e6:	30 83       	st	Z, r19
     6e8:	31 97       	sbiw	r30, 0x01	; 1
     6ea:	20 83       	st	Z, r18
     6ec:	31 97       	sbiw	r30, 0x01	; 1
     6ee:	23 e2       	ldi	r18, 0x23	; 35
     6f0:	20 83       	st	Z, r18
     6f2:	31 97       	sbiw	r30, 0x01	; 1
     6f4:	40 83       	st	Z, r20
     6f6:	31 97       	sbiw	r30, 0x01	; 1
     6f8:	50 83       	st	Z, r21
     6fa:	31 97       	sbiw	r30, 0x01	; 1
     6fc:	26 e2       	ldi	r18, 0x26	; 38
     6fe:	20 83       	st	Z, r18
     700:	31 97       	sbiw	r30, 0x01	; 1
     702:	27 e2       	ldi	r18, 0x27	; 39
     704:	20 83       	st	Z, r18
     706:	31 97       	sbiw	r30, 0x01	; 1
     708:	28 e2       	ldi	r18, 0x28	; 40
     70a:	20 83       	st	Z, r18
     70c:	31 97       	sbiw	r30, 0x01	; 1
     70e:	29 e2       	ldi	r18, 0x29	; 41
     710:	20 83       	st	Z, r18
     712:	31 97       	sbiw	r30, 0x01	; 1
     714:	20 e3       	ldi	r18, 0x30	; 48
     716:	20 83       	st	Z, r18
     718:	31 97       	sbiw	r30, 0x01	; 1
     71a:	21 e3       	ldi	r18, 0x31	; 49
     71c:	20 83       	st	Z, r18
     71e:	86 97       	sbiw	r24, 0x26	; 38
     720:	08 95       	ret

00000722 <xPortStartScheduler>:
     722:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
     726:	8c e7       	ldi	r24, 0x7C	; 124
     728:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
     72c:	8b e0       	ldi	r24, 0x0B	; 11
     72e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
     732:	ef e6       	ldi	r30, 0x6F	; 111
     734:	f0 e0       	ldi	r31, 0x00	; 0
     736:	80 81       	ld	r24, Z
     738:	82 60       	ori	r24, 0x02	; 2
     73a:	80 83       	st	Z, r24
     73c:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     740:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     744:	cd 91       	ld	r28, X+
     746:	cd bf       	out	0x3d, r28	; 61
     748:	dd 91       	ld	r29, X+
     74a:	de bf       	out	0x3e, r29	; 62
     74c:	ff 91       	pop	r31
     74e:	ef 91       	pop	r30
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	bf 91       	pop	r27
     756:	af 91       	pop	r26
     758:	9f 91       	pop	r25
     75a:	8f 91       	pop	r24
     75c:	7f 91       	pop	r23
     75e:	6f 91       	pop	r22
     760:	5f 91       	pop	r21
     762:	4f 91       	pop	r20
     764:	3f 91       	pop	r19
     766:	2f 91       	pop	r18
     768:	1f 91       	pop	r17
     76a:	0f 91       	pop	r16
     76c:	ff 90       	pop	r15
     76e:	ef 90       	pop	r14
     770:	df 90       	pop	r13
     772:	cf 90       	pop	r12
     774:	bf 90       	pop	r11
     776:	af 90       	pop	r10
     778:	9f 90       	pop	r9
     77a:	8f 90       	pop	r8
     77c:	7f 90       	pop	r7
     77e:	6f 90       	pop	r6
     780:	5f 90       	pop	r5
     782:	4f 90       	pop	r4
     784:	3f 90       	pop	r3
     786:	2f 90       	pop	r2
     788:	1f 90       	pop	r1
     78a:	0f 90       	pop	r0
     78c:	0f be       	out	0x3f, r0	; 63
     78e:	0f 90       	pop	r0
     790:	08 95       	ret
     792:	81 e0       	ldi	r24, 0x01	; 1
     794:	08 95       	ret

00000796 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     796:	0f 92       	push	r0
     798:	0f b6       	in	r0, 0x3f	; 63
     79a:	f8 94       	cli
     79c:	0f 92       	push	r0
     79e:	1f 92       	push	r1
     7a0:	11 24       	eor	r1, r1
     7a2:	2f 92       	push	r2
     7a4:	3f 92       	push	r3
     7a6:	4f 92       	push	r4
     7a8:	5f 92       	push	r5
     7aa:	6f 92       	push	r6
     7ac:	7f 92       	push	r7
     7ae:	8f 92       	push	r8
     7b0:	9f 92       	push	r9
     7b2:	af 92       	push	r10
     7b4:	bf 92       	push	r11
     7b6:	cf 92       	push	r12
     7b8:	df 92       	push	r13
     7ba:	ef 92       	push	r14
     7bc:	ff 92       	push	r15
     7be:	0f 93       	push	r16
     7c0:	1f 93       	push	r17
     7c2:	2f 93       	push	r18
     7c4:	3f 93       	push	r19
     7c6:	4f 93       	push	r20
     7c8:	5f 93       	push	r21
     7ca:	6f 93       	push	r22
     7cc:	7f 93       	push	r23
     7ce:	8f 93       	push	r24
     7d0:	9f 93       	push	r25
     7d2:	af 93       	push	r26
     7d4:	bf 93       	push	r27
     7d6:	cf 93       	push	r28
     7d8:	df 93       	push	r29
     7da:	ef 93       	push	r30
     7dc:	ff 93       	push	r31
     7de:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     7e2:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     7e6:	0d b6       	in	r0, 0x3d	; 61
     7e8:	0d 92       	st	X+, r0
     7ea:	0e b6       	in	r0, 0x3e	; 62
     7ec:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     7ee:	0e 94 49 0b 	call	0x1692	; 0x1692 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     7f2:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     7f6:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     7fa:	cd 91       	ld	r28, X+
     7fc:	cd bf       	out	0x3d, r28	; 61
     7fe:	dd 91       	ld	r29, X+
     800:	de bf       	out	0x3e, r29	; 62
     802:	ff 91       	pop	r31
     804:	ef 91       	pop	r30
     806:	df 91       	pop	r29
     808:	cf 91       	pop	r28
     80a:	bf 91       	pop	r27
     80c:	af 91       	pop	r26
     80e:	9f 91       	pop	r25
     810:	8f 91       	pop	r24
     812:	7f 91       	pop	r23
     814:	6f 91       	pop	r22
     816:	5f 91       	pop	r21
     818:	4f 91       	pop	r20
     81a:	3f 91       	pop	r19
     81c:	2f 91       	pop	r18
     81e:	1f 91       	pop	r17
     820:	0f 91       	pop	r16
     822:	ff 90       	pop	r15
     824:	ef 90       	pop	r14
     826:	df 90       	pop	r13
     828:	cf 90       	pop	r12
     82a:	bf 90       	pop	r11
     82c:	af 90       	pop	r10
     82e:	9f 90       	pop	r9
     830:	8f 90       	pop	r8
     832:	7f 90       	pop	r7
     834:	6f 90       	pop	r6
     836:	5f 90       	pop	r5
     838:	4f 90       	pop	r4
     83a:	3f 90       	pop	r3
     83c:	2f 90       	pop	r2
     83e:	1f 90       	pop	r1
     840:	0f 90       	pop	r0
     842:	0f be       	out	0x3f, r0	; 63
     844:	0f 90       	pop	r0

	asm volatile ( "ret" );
     846:	08 95       	ret

00000848 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     848:	0f 92       	push	r0
     84a:	0f b6       	in	r0, 0x3f	; 63
     84c:	f8 94       	cli
     84e:	0f 92       	push	r0
     850:	1f 92       	push	r1
     852:	11 24       	eor	r1, r1
     854:	2f 92       	push	r2
     856:	3f 92       	push	r3
     858:	4f 92       	push	r4
     85a:	5f 92       	push	r5
     85c:	6f 92       	push	r6
     85e:	7f 92       	push	r7
     860:	8f 92       	push	r8
     862:	9f 92       	push	r9
     864:	af 92       	push	r10
     866:	bf 92       	push	r11
     868:	cf 92       	push	r12
     86a:	df 92       	push	r13
     86c:	ef 92       	push	r14
     86e:	ff 92       	push	r15
     870:	0f 93       	push	r16
     872:	1f 93       	push	r17
     874:	2f 93       	push	r18
     876:	3f 93       	push	r19
     878:	4f 93       	push	r20
     87a:	5f 93       	push	r21
     87c:	6f 93       	push	r22
     87e:	7f 93       	push	r23
     880:	8f 93       	push	r24
     882:	9f 93       	push	r25
     884:	af 93       	push	r26
     886:	bf 93       	push	r27
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	ef 93       	push	r30
     88e:	ff 93       	push	r31
     890:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     894:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     898:	0d b6       	in	r0, 0x3d	; 61
     89a:	0d 92       	st	X+, r0
     89c:	0e b6       	in	r0, 0x3e	; 62
     89e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     8a0:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskIncrementTick>
     8a4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     8a6:	0e 94 49 0b 	call	0x1692	; 0x1692 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     8aa:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     8ae:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     8b2:	cd 91       	ld	r28, X+
     8b4:	cd bf       	out	0x3d, r28	; 61
     8b6:	dd 91       	ld	r29, X+
     8b8:	de bf       	out	0x3e, r29	; 62
     8ba:	ff 91       	pop	r31
     8bc:	ef 91       	pop	r30
     8be:	df 91       	pop	r29
     8c0:	cf 91       	pop	r28
     8c2:	bf 91       	pop	r27
     8c4:	af 91       	pop	r26
     8c6:	9f 91       	pop	r25
     8c8:	8f 91       	pop	r24
     8ca:	7f 91       	pop	r23
     8cc:	6f 91       	pop	r22
     8ce:	5f 91       	pop	r21
     8d0:	4f 91       	pop	r20
     8d2:	3f 91       	pop	r19
     8d4:	2f 91       	pop	r18
     8d6:	1f 91       	pop	r17
     8d8:	0f 91       	pop	r16
     8da:	ff 90       	pop	r15
     8dc:	ef 90       	pop	r14
     8de:	df 90       	pop	r13
     8e0:	cf 90       	pop	r12
     8e2:	bf 90       	pop	r11
     8e4:	af 90       	pop	r10
     8e6:	9f 90       	pop	r9
     8e8:	8f 90       	pop	r8
     8ea:	7f 90       	pop	r7
     8ec:	6f 90       	pop	r6
     8ee:	5f 90       	pop	r5
     8f0:	4f 90       	pop	r4
     8f2:	3f 90       	pop	r3
     8f4:	2f 90       	pop	r2
     8f6:	1f 90       	pop	r1
     8f8:	0f 90       	pop	r0
     8fa:	0f be       	out	0x3f, r0	; 63
     8fc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8fe:	08 95       	ret

00000900 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
     900:	0e 94 24 04 	call	0x848	; 0x848 <vPortYieldFromTick>
		asm volatile ( "reti" );
     904:	18 95       	reti

00000906 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     906:	0f 93       	push	r16
     908:	1f 93       	push	r17
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
     90e:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     910:	0e 94 76 09 	call	0x12ec	; 0x12ec <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     914:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <__data_end>
     918:	81 11       	cpse	r24, r1
     91a:	1d c0       	rjmp	.+58     	; 0x956 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     91c:	ef ea       	ldi	r30, 0xAF	; 175
     91e:	f1 e0       	ldi	r31, 0x01	; 1
     920:	84 eb       	ldi	r24, 0xB4	; 180
     922:	91 e0       	ldi	r25, 0x01	; 1
     924:	91 83       	std	Z+1, r25	; 0x01
     926:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     928:	13 82       	std	Z+3, r1	; 0x03
     92a:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     92c:	eb ea       	ldi	r30, 0xAB	; 171
     92e:	f1 e0       	ldi	r31, 0x01	; 1
     930:	8b ed       	ldi	r24, 0xDB	; 219
     932:	95 e0       	ldi	r25, 0x05	; 5
     934:	93 83       	std	Z+3, r25	; 0x03
     936:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     938:	11 82       	std	Z+1, r1	; 0x01
     93a:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     93c:	a3 eb       	ldi	r26, 0xB3	; 179
     93e:	b1 e0       	ldi	r27, 0x01	; 1
     940:	14 96       	adiw	r26, 0x04	; 4
     942:	9c 93       	st	X, r25
     944:	8e 93       	st	-X, r24
     946:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     948:	12 96       	adiw	r26, 0x02	; 2
     94a:	fc 93       	st	X, r31
     94c:	ee 93       	st	-X, r30
     94e:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     950:	81 e0       	ldi	r24, 0x01	; 1
     952:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     956:	20 97       	sbiw	r28, 0x00	; 0
     958:	09 f4       	brne	.+2      	; 0x95c <pvPortMalloc+0x56>
     95a:	5f c0       	rjmp	.+190    	; 0xa1a <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     95c:	9e 01       	movw	r18, r28
     95e:	2c 5f       	subi	r18, 0xFC	; 252
     960:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     962:	23 96       	adiw	r28, 0x03	; 3
     964:	ca 3d       	cpi	r28, 0xDA	; 218
     966:	d5 40       	sbci	r29, 0x05	; 5
     968:	08 f0       	brcs	.+2      	; 0x96c <pvPortMalloc+0x66>
     96a:	5a c0       	rjmp	.+180    	; 0xa20 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     96c:	e0 91 af 01 	lds	r30, 0x01AF	; 0x8001af <xStart>
     970:	f0 91 b0 01 	lds	r31, 0x01B0	; 0x8001b0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     974:	af ea       	ldi	r26, 0xAF	; 175
     976:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     978:	02 c0       	rjmp	.+4      	; 0x97e <pvPortMalloc+0x78>
     97a:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     97c:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     97e:	82 81       	ldd	r24, Z+2	; 0x02
     980:	93 81       	ldd	r25, Z+3	; 0x03
     982:	82 17       	cp	r24, r18
     984:	93 07       	cpc	r25, r19
     986:	20 f4       	brcc	.+8      	; 0x990 <pvPortMalloc+0x8a>
     988:	80 81       	ld	r24, Z
     98a:	91 81       	ldd	r25, Z+1	; 0x01
     98c:	00 97       	sbiw	r24, 0x00	; 0
     98e:	a9 f7       	brne	.-22     	; 0x97a <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     990:	c1 e0       	ldi	r28, 0x01	; 1
     992:	eb 3a       	cpi	r30, 0xAB	; 171
     994:	fc 07       	cpc	r31, r28
     996:	09 f4       	brne	.+2      	; 0x99a <pvPortMalloc+0x94>
     998:	46 c0       	rjmp	.+140    	; 0xa26 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     99a:	cd 91       	ld	r28, X+
     99c:	dc 91       	ld	r29, X
     99e:	11 97       	sbiw	r26, 0x01	; 1
     9a0:	8e 01       	movw	r16, r28
     9a2:	0c 5f       	subi	r16, 0xFC	; 252
     9a4:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     9a6:	80 81       	ld	r24, Z
     9a8:	91 81       	ldd	r25, Z+1	; 0x01
     9aa:	8d 93       	st	X+, r24
     9ac:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     9ae:	82 81       	ldd	r24, Z+2	; 0x02
     9b0:	93 81       	ldd	r25, Z+3	; 0x03
     9b2:	82 1b       	sub	r24, r18
     9b4:	93 0b       	sbc	r25, r19
     9b6:	89 30       	cpi	r24, 0x09	; 9
     9b8:	91 05       	cpc	r25, r1
     9ba:	10 f1       	brcs	.+68     	; 0xa00 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     9bc:	bf 01       	movw	r22, r30
     9be:	62 0f       	add	r22, r18
     9c0:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     9c2:	db 01       	movw	r26, r22
     9c4:	13 96       	adiw	r26, 0x03	; 3
     9c6:	9c 93       	st	X, r25
     9c8:	8e 93       	st	-X, r24
     9ca:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     9cc:	33 83       	std	Z+3, r19	; 0x03
     9ce:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     9d0:	12 96       	adiw	r26, 0x02	; 2
     9d2:	4d 91       	ld	r20, X+
     9d4:	5c 91       	ld	r21, X
     9d6:	13 97       	sbiw	r26, 0x03	; 3
     9d8:	8f ea       	ldi	r24, 0xAF	; 175
     9da:	91 e0       	ldi	r25, 0x01	; 1
     9dc:	01 c0       	rjmp	.+2      	; 0x9e0 <pvPortMalloc+0xda>
     9de:	cd 01       	movw	r24, r26
     9e0:	ec 01       	movw	r28, r24
     9e2:	a8 81       	ld	r26, Y
     9e4:	b9 81       	ldd	r27, Y+1	; 0x01
     9e6:	12 96       	adiw	r26, 0x02	; 2
     9e8:	2d 91       	ld	r18, X+
     9ea:	3c 91       	ld	r19, X
     9ec:	13 97       	sbiw	r26, 0x03	; 3
     9ee:	24 17       	cp	r18, r20
     9f0:	35 07       	cpc	r19, r21
     9f2:	a8 f3       	brcs	.-22     	; 0x9de <pvPortMalloc+0xd8>
     9f4:	eb 01       	movw	r28, r22
     9f6:	b9 83       	std	Y+1, r27	; 0x01
     9f8:	a8 83       	st	Y, r26
     9fa:	dc 01       	movw	r26, r24
     9fc:	6d 93       	st	X+, r22
     9fe:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     a00:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     a04:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     a08:	22 81       	ldd	r18, Z+2	; 0x02
     a0a:	33 81       	ldd	r19, Z+3	; 0x03
     a0c:	82 1b       	sub	r24, r18
     a0e:	93 0b       	sbc	r25, r19
     a10:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     a14:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     a18:	08 c0       	rjmp	.+16     	; 0xa2a <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     a1a:	00 e0       	ldi	r16, 0x00	; 0
     a1c:	10 e0       	ldi	r17, 0x00	; 0
     a1e:	05 c0       	rjmp	.+10     	; 0xa2a <pvPortMalloc+0x124>
     a20:	00 e0       	ldi	r16, 0x00	; 0
     a22:	10 e0       	ldi	r17, 0x00	; 0
     a24:	02 c0       	rjmp	.+4      	; 0xa2a <pvPortMalloc+0x124>
     a26:	00 e0       	ldi	r16, 0x00	; 0
     a28:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     a2a:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     a2e:	c8 01       	movw	r24, r16
     a30:	df 91       	pop	r29
     a32:	cf 91       	pop	r28
     a34:	1f 91       	pop	r17
     a36:	0f 91       	pop	r16
     a38:	08 95       	ret

00000a3a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     a3a:	0f 93       	push	r16
     a3c:	1f 93       	push	r17
     a3e:	cf 93       	push	r28
     a40:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     a42:	00 97       	sbiw	r24, 0x00	; 0
     a44:	41 f1       	breq	.+80     	; 0xa96 <vPortFree+0x5c>
     a46:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     a48:	8c 01       	movw	r16, r24
     a4a:	04 50       	subi	r16, 0x04	; 4
     a4c:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     a4e:	0e 94 76 09 	call	0x12ec	; 0x12ec <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     a52:	f8 01       	movw	r30, r16
     a54:	42 81       	ldd	r20, Z+2	; 0x02
     a56:	53 81       	ldd	r21, Z+3	; 0x03
     a58:	af ea       	ldi	r26, 0xAF	; 175
     a5a:	b1 e0       	ldi	r27, 0x01	; 1
     a5c:	01 c0       	rjmp	.+2      	; 0xa60 <vPortFree+0x26>
     a5e:	df 01       	movw	r26, r30
     a60:	ed 91       	ld	r30, X+
     a62:	fc 91       	ld	r31, X
     a64:	11 97       	sbiw	r26, 0x01	; 1
     a66:	22 81       	ldd	r18, Z+2	; 0x02
     a68:	33 81       	ldd	r19, Z+3	; 0x03
     a6a:	24 17       	cp	r18, r20
     a6c:	35 07       	cpc	r19, r21
     a6e:	b8 f3       	brcs	.-18     	; 0xa5e <vPortFree+0x24>
     a70:	24 97       	sbiw	r28, 0x04	; 4
     a72:	f9 83       	std	Y+1, r31	; 0x01
     a74:	e8 83       	st	Y, r30
     a76:	0d 93       	st	X+, r16
     a78:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     a7a:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
     a7e:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
     a82:	8a 81       	ldd	r24, Y+2	; 0x02
     a84:	9b 81       	ldd	r25, Y+3	; 0x03
     a86:	82 0f       	add	r24, r18
     a88:	93 1f       	adc	r25, r19
     a8a:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     a8e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     a92:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
	}
}
     a96:	df 91       	pop	r29
     a98:	cf 91       	pop	r28
     a9a:	1f 91       	pop	r17
     a9c:	0f 91       	pop	r16
     a9e:	08 95       	ret

00000aa0 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     aa0:	1f 93       	push	r17
     aa2:	cf 93       	push	r28
     aa4:	df 93       	push	r29
     aa6:	ec 01       	movw	r28, r24
     aa8:	14 2f       	mov	r17, r20
     aaa:	4c 8d       	ldd	r20, Y+28	; 0x1c
     aac:	41 11       	cpse	r20, r1
     aae:	0c c0       	rjmp	.+24     	; 0xac8 <prvCopyDataToQueue+0x28>
     ab0:	88 81       	ld	r24, Y
     ab2:	99 81       	ldd	r25, Y+1	; 0x01
     ab4:	89 2b       	or	r24, r25
     ab6:	09 f0       	breq	.+2      	; 0xaba <prvCopyDataToQueue+0x1a>
     ab8:	45 c0       	rjmp	.+138    	; 0xb44 <prvCopyDataToQueue+0xa4>
     aba:	8a 81       	ldd	r24, Y+2	; 0x02
     abc:	9b 81       	ldd	r25, Y+3	; 0x03
     abe:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xTaskPriorityDisinherit>
     ac2:	1b 82       	std	Y+3, r1	; 0x03
     ac4:	1a 82       	std	Y+2, r1	; 0x02
     ac6:	45 c0       	rjmp	.+138    	; 0xb52 <prvCopyDataToQueue+0xb2>
     ac8:	11 11       	cpse	r17, r1
     aca:	17 c0       	rjmp	.+46     	; 0xafa <prvCopyDataToQueue+0x5a>
     acc:	50 e0       	ldi	r21, 0x00	; 0
     ace:	8c 81       	ldd	r24, Y+4	; 0x04
     ad0:	9d 81       	ldd	r25, Y+5	; 0x05
     ad2:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <memcpy>
     ad6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ad8:	8c 81       	ldd	r24, Y+4	; 0x04
     ada:	9d 81       	ldd	r25, Y+5	; 0x05
     adc:	82 0f       	add	r24, r18
     ade:	91 1d       	adc	r25, r1
     ae0:	9d 83       	std	Y+5, r25	; 0x05
     ae2:	8c 83       	std	Y+4, r24	; 0x04
     ae4:	2a 81       	ldd	r18, Y+2	; 0x02
     ae6:	3b 81       	ldd	r19, Y+3	; 0x03
     ae8:	82 17       	cp	r24, r18
     aea:	93 07       	cpc	r25, r19
     aec:	68 f1       	brcs	.+90     	; 0xb48 <prvCopyDataToQueue+0xa8>
     aee:	88 81       	ld	r24, Y
     af0:	99 81       	ldd	r25, Y+1	; 0x01
     af2:	9d 83       	std	Y+5, r25	; 0x05
     af4:	8c 83       	std	Y+4, r24	; 0x04
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	2c c0       	rjmp	.+88     	; 0xb52 <prvCopyDataToQueue+0xb2>
     afa:	50 e0       	ldi	r21, 0x00	; 0
     afc:	8e 81       	ldd	r24, Y+6	; 0x06
     afe:	9f 81       	ldd	r25, Y+7	; 0x07
     b00:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <memcpy>
     b04:	8c 8d       	ldd	r24, Y+28	; 0x1c
     b06:	90 e0       	ldi	r25, 0x00	; 0
     b08:	91 95       	neg	r25
     b0a:	81 95       	neg	r24
     b0c:	91 09       	sbc	r25, r1
     b0e:	2e 81       	ldd	r18, Y+6	; 0x06
     b10:	3f 81       	ldd	r19, Y+7	; 0x07
     b12:	28 0f       	add	r18, r24
     b14:	39 1f       	adc	r19, r25
     b16:	3f 83       	std	Y+7, r19	; 0x07
     b18:	2e 83       	std	Y+6, r18	; 0x06
     b1a:	48 81       	ld	r20, Y
     b1c:	59 81       	ldd	r21, Y+1	; 0x01
     b1e:	24 17       	cp	r18, r20
     b20:	35 07       	cpc	r19, r21
     b22:	30 f4       	brcc	.+12     	; 0xb30 <prvCopyDataToQueue+0x90>
     b24:	2a 81       	ldd	r18, Y+2	; 0x02
     b26:	3b 81       	ldd	r19, Y+3	; 0x03
     b28:	82 0f       	add	r24, r18
     b2a:	93 1f       	adc	r25, r19
     b2c:	9f 83       	std	Y+7, r25	; 0x07
     b2e:	8e 83       	std	Y+6, r24	; 0x06
     b30:	12 30       	cpi	r17, 0x02	; 2
     b32:	61 f4       	brne	.+24     	; 0xb4c <prvCopyDataToQueue+0xac>
     b34:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b36:	88 23       	and	r24, r24
     b38:	59 f0       	breq	.+22     	; 0xb50 <prvCopyDataToQueue+0xb0>
     b3a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b3c:	81 50       	subi	r24, 0x01	; 1
     b3e:	8a 8f       	std	Y+26, r24	; 0x1a
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	07 c0       	rjmp	.+14     	; 0xb52 <prvCopyDataToQueue+0xb2>
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	05 c0       	rjmp	.+10     	; 0xb52 <prvCopyDataToQueue+0xb2>
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	03 c0       	rjmp	.+6      	; 0xb52 <prvCopyDataToQueue+0xb2>
     b4c:	80 e0       	ldi	r24, 0x00	; 0
     b4e:	01 c0       	rjmp	.+2      	; 0xb52 <prvCopyDataToQueue+0xb2>
     b50:	80 e0       	ldi	r24, 0x00	; 0
     b52:	9a 8d       	ldd	r25, Y+26	; 0x1a
     b54:	9f 5f       	subi	r25, 0xFF	; 255
     b56:	9a 8f       	std	Y+26, r25	; 0x1a
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	1f 91       	pop	r17
     b5e:	08 95       	ret

00000b60 <prvCopyDataFromQueue>:
     b60:	fc 01       	movw	r30, r24
     b62:	44 8d       	ldd	r20, Z+28	; 0x1c
     b64:	44 23       	and	r20, r20
     b66:	a9 f0       	breq	.+42     	; 0xb92 <prvCopyDataFromQueue+0x32>
     b68:	50 e0       	ldi	r21, 0x00	; 0
     b6a:	26 81       	ldd	r18, Z+6	; 0x06
     b6c:	37 81       	ldd	r19, Z+7	; 0x07
     b6e:	24 0f       	add	r18, r20
     b70:	35 1f       	adc	r19, r21
     b72:	37 83       	std	Z+7, r19	; 0x07
     b74:	26 83       	std	Z+6, r18	; 0x06
     b76:	82 81       	ldd	r24, Z+2	; 0x02
     b78:	93 81       	ldd	r25, Z+3	; 0x03
     b7a:	28 17       	cp	r18, r24
     b7c:	39 07       	cpc	r19, r25
     b7e:	20 f0       	brcs	.+8      	; 0xb88 <prvCopyDataFromQueue+0x28>
     b80:	80 81       	ld	r24, Z
     b82:	91 81       	ldd	r25, Z+1	; 0x01
     b84:	97 83       	std	Z+7, r25	; 0x07
     b86:	86 83       	std	Z+6, r24	; 0x06
     b88:	cb 01       	movw	r24, r22
     b8a:	66 81       	ldd	r22, Z+6	; 0x06
     b8c:	77 81       	ldd	r23, Z+7	; 0x07
     b8e:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <memcpy>
     b92:	08 95       	ret

00000b94 <prvUnlockQueue>:
     b94:	0f 93       	push	r16
     b96:	1f 93       	push	r17
     b98:	cf 93       	push	r28
     b9a:	df 93       	push	r29
     b9c:	ec 01       	movw	r28, r24
     b9e:	0f b6       	in	r0, 0x3f	; 63
     ba0:	f8 94       	cli
     ba2:	0f 92       	push	r0
     ba4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ba6:	18 16       	cp	r1, r24
     ba8:	bc f4       	brge	.+46     	; 0xbd8 <prvUnlockQueue+0x44>
     baa:	89 89       	ldd	r24, Y+17	; 0x11
     bac:	81 11       	cpse	r24, r1
     bae:	05 c0       	rjmp	.+10     	; 0xbba <prvUnlockQueue+0x26>
     bb0:	13 c0       	rjmp	.+38     	; 0xbd8 <prvUnlockQueue+0x44>
     bb2:	89 89       	ldd	r24, Y+17	; 0x11
     bb4:	81 11       	cpse	r24, r1
     bb6:	04 c0       	rjmp	.+8      	; 0xbc0 <prvUnlockQueue+0x2c>
     bb8:	0f c0       	rjmp	.+30     	; 0xbd8 <prvUnlockQueue+0x44>
     bba:	8e 01       	movw	r16, r28
     bbc:	0f 5e       	subi	r16, 0xEF	; 239
     bbe:	1f 4f       	sbci	r17, 0xFF	; 255
     bc0:	c8 01       	movw	r24, r16
     bc2:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskRemoveFromEventList>
     bc6:	81 11       	cpse	r24, r1
     bc8:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <vTaskMissedYield>
     bcc:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bce:	81 50       	subi	r24, 0x01	; 1
     bd0:	8e 8f       	std	Y+30, r24	; 0x1e
     bd2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bd4:	18 16       	cp	r1, r24
     bd6:	6c f3       	brlt	.-38     	; 0xbb2 <prvUnlockQueue+0x1e>
     bd8:	8f ef       	ldi	r24, 0xFF	; 255
     bda:	8e 8f       	std	Y+30, r24	; 0x1e
     bdc:	0f 90       	pop	r0
     bde:	0f be       	out	0x3f, r0	; 63
     be0:	0f b6       	in	r0, 0x3f	; 63
     be2:	f8 94       	cli
     be4:	0f 92       	push	r0
     be6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     be8:	18 16       	cp	r1, r24
     bea:	bc f4       	brge	.+46     	; 0xc1a <prvUnlockQueue+0x86>
     bec:	88 85       	ldd	r24, Y+8	; 0x08
     bee:	81 11       	cpse	r24, r1
     bf0:	05 c0       	rjmp	.+10     	; 0xbfc <prvUnlockQueue+0x68>
     bf2:	13 c0       	rjmp	.+38     	; 0xc1a <prvUnlockQueue+0x86>
     bf4:	88 85       	ldd	r24, Y+8	; 0x08
     bf6:	81 11       	cpse	r24, r1
     bf8:	04 c0       	rjmp	.+8      	; 0xc02 <prvUnlockQueue+0x6e>
     bfa:	0f c0       	rjmp	.+30     	; 0xc1a <prvUnlockQueue+0x86>
     bfc:	8e 01       	movw	r16, r28
     bfe:	08 5f       	subi	r16, 0xF8	; 248
     c00:	1f 4f       	sbci	r17, 0xFF	; 255
     c02:	c8 01       	movw	r24, r16
     c04:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskRemoveFromEventList>
     c08:	81 11       	cpse	r24, r1
     c0a:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <vTaskMissedYield>
     c0e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c10:	81 50       	subi	r24, 0x01	; 1
     c12:	8d 8f       	std	Y+29, r24	; 0x1d
     c14:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c16:	18 16       	cp	r1, r24
     c18:	6c f3       	brlt	.-38     	; 0xbf4 <prvUnlockQueue+0x60>
     c1a:	8f ef       	ldi	r24, 0xFF	; 255
     c1c:	8d 8f       	std	Y+29, r24	; 0x1d
     c1e:	0f 90       	pop	r0
     c20:	0f be       	out	0x3f, r0	; 63
     c22:	df 91       	pop	r29
     c24:	cf 91       	pop	r28
     c26:	1f 91       	pop	r17
     c28:	0f 91       	pop	r16
     c2a:	08 95       	ret

00000c2c <xQueueGenericReset>:
     c2c:	cf 93       	push	r28
     c2e:	df 93       	push	r29
     c30:	ec 01       	movw	r28, r24
     c32:	0f b6       	in	r0, 0x3f	; 63
     c34:	f8 94       	cli
     c36:	0f 92       	push	r0
     c38:	48 81       	ld	r20, Y
     c3a:	59 81       	ldd	r21, Y+1	; 0x01
     c3c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c3e:	30 e0       	ldi	r19, 0x00	; 0
     c40:	7b 8d       	ldd	r23, Y+27	; 0x1b
     c42:	72 9f       	mul	r23, r18
     c44:	c0 01       	movw	r24, r0
     c46:	73 9f       	mul	r23, r19
     c48:	90 0d       	add	r25, r0
     c4a:	11 24       	eor	r1, r1
     c4c:	fa 01       	movw	r30, r20
     c4e:	e8 0f       	add	r30, r24
     c50:	f9 1f       	adc	r31, r25
     c52:	fb 83       	std	Y+3, r31	; 0x03
     c54:	ea 83       	std	Y+2, r30	; 0x02
     c56:	1a 8e       	std	Y+26, r1	; 0x1a
     c58:	5d 83       	std	Y+5, r21	; 0x05
     c5a:	4c 83       	std	Y+4, r20	; 0x04
     c5c:	82 1b       	sub	r24, r18
     c5e:	93 0b       	sbc	r25, r19
     c60:	84 0f       	add	r24, r20
     c62:	95 1f       	adc	r25, r21
     c64:	9f 83       	std	Y+7, r25	; 0x07
     c66:	8e 83       	std	Y+6, r24	; 0x06
     c68:	8f ef       	ldi	r24, 0xFF	; 255
     c6a:	8d 8f       	std	Y+29, r24	; 0x1d
     c6c:	8e 8f       	std	Y+30, r24	; 0x1e
     c6e:	61 11       	cpse	r22, r1
     c70:	0c c0       	rjmp	.+24     	; 0xc8a <xQueueGenericReset+0x5e>
     c72:	88 85       	ldd	r24, Y+8	; 0x08
     c74:	88 23       	and	r24, r24
     c76:	89 f0       	breq	.+34     	; 0xc9a <xQueueGenericReset+0x6e>
     c78:	ce 01       	movw	r24, r28
     c7a:	08 96       	adiw	r24, 0x08	; 8
     c7c:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskRemoveFromEventList>
     c80:	81 30       	cpi	r24, 0x01	; 1
     c82:	59 f4       	brne	.+22     	; 0xc9a <xQueueGenericReset+0x6e>
     c84:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
     c88:	08 c0       	rjmp	.+16     	; 0xc9a <xQueueGenericReset+0x6e>
     c8a:	ce 01       	movw	r24, r28
     c8c:	08 96       	adiw	r24, 0x08	; 8
     c8e:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
     c92:	ce 01       	movw	r24, r28
     c94:	41 96       	adiw	r24, 0x11	; 17
     c96:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
     c9a:	0f 90       	pop	r0
     c9c:	0f be       	out	0x3f, r0	; 63
     c9e:	81 e0       	ldi	r24, 0x01	; 1
     ca0:	df 91       	pop	r29
     ca2:	cf 91       	pop	r28
     ca4:	08 95       	ret

00000ca6 <xQueueGenericCreate>:
     ca6:	0f 93       	push	r16
     ca8:	1f 93       	push	r17
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	08 2f       	mov	r16, r24
     cb0:	16 2f       	mov	r17, r22
     cb2:	66 23       	and	r22, r22
     cb4:	b9 f0       	breq	.+46     	; 0xce4 <xQueueGenericCreate+0x3e>
     cb6:	86 9f       	mul	r24, r22
     cb8:	c0 01       	movw	r24, r0
     cba:	11 24       	eor	r1, r1
     cbc:	80 96       	adiw	r24, 0x20	; 32
     cbe:	0e 94 83 04 	call	0x906	; 0x906 <pvPortMalloc>
     cc2:	ec 01       	movw	r28, r24
     cc4:	00 97       	sbiw	r24, 0x00	; 0
     cc6:	21 f4       	brne	.+8      	; 0xcd0 <xQueueGenericCreate+0x2a>
     cc8:	14 c0       	rjmp	.+40     	; 0xcf2 <xQueueGenericCreate+0x4c>
     cca:	d9 83       	std	Y+1, r29	; 0x01
     ccc:	c8 83       	st	Y, r28
     cce:	03 c0       	rjmp	.+6      	; 0xcd6 <xQueueGenericCreate+0x30>
     cd0:	4f 96       	adiw	r24, 0x1f	; 31
     cd2:	99 83       	std	Y+1, r25	; 0x01
     cd4:	88 83       	st	Y, r24
     cd6:	0b 8f       	std	Y+27, r16	; 0x1b
     cd8:	1c 8f       	std	Y+28, r17	; 0x1c
     cda:	61 e0       	ldi	r22, 0x01	; 1
     cdc:	ce 01       	movw	r24, r28
     cde:	0e 94 16 06 	call	0xc2c	; 0xc2c <xQueueGenericReset>
     ce2:	07 c0       	rjmp	.+14     	; 0xcf2 <xQueueGenericCreate+0x4c>
     ce4:	8f e1       	ldi	r24, 0x1F	; 31
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	0e 94 83 04 	call	0x906	; 0x906 <pvPortMalloc>
     cec:	ec 01       	movw	r28, r24
     cee:	89 2b       	or	r24, r25
     cf0:	61 f7       	brne	.-40     	; 0xcca <xQueueGenericCreate+0x24>
     cf2:	ce 01       	movw	r24, r28
     cf4:	df 91       	pop	r29
     cf6:	cf 91       	pop	r28
     cf8:	1f 91       	pop	r17
     cfa:	0f 91       	pop	r16
     cfc:	08 95       	ret

00000cfe <xQueueGenericSend>:
     cfe:	9f 92       	push	r9
     d00:	af 92       	push	r10
     d02:	bf 92       	push	r11
     d04:	cf 92       	push	r12
     d06:	df 92       	push	r13
     d08:	ef 92       	push	r14
     d0a:	ff 92       	push	r15
     d0c:	0f 93       	push	r16
     d0e:	1f 93       	push	r17
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	00 d0       	rcall	.+0      	; 0xd16 <xQueueGenericSend+0x18>
     d16:	00 d0       	rcall	.+0      	; 0xd18 <xQueueGenericSend+0x1a>
     d18:	1f 92       	push	r1
     d1a:	cd b7       	in	r28, 0x3d	; 61
     d1c:	de b7       	in	r29, 0x3e	; 62
     d1e:	8c 01       	movw	r16, r24
     d20:	6b 01       	movw	r12, r22
     d22:	5d 83       	std	Y+5, r21	; 0x05
     d24:	4c 83       	std	Y+4, r20	; 0x04
     d26:	a2 2e       	mov	r10, r18
     d28:	b1 2c       	mov	r11, r1
     d2a:	99 24       	eor	r9, r9
     d2c:	93 94       	inc	r9
     d2e:	7c 01       	movw	r14, r24
     d30:	88 e0       	ldi	r24, 0x08	; 8
     d32:	e8 0e       	add	r14, r24
     d34:	f1 1c       	adc	r15, r1
     d36:	0f b6       	in	r0, 0x3f	; 63
     d38:	f8 94       	cli
     d3a:	0f 92       	push	r0
     d3c:	f8 01       	movw	r30, r16
     d3e:	92 8d       	ldd	r25, Z+26	; 0x1a
     d40:	83 8d       	ldd	r24, Z+27	; 0x1b
     d42:	98 17       	cp	r25, r24
     d44:	18 f0       	brcs	.+6      	; 0xd4c <xQueueGenericSend+0x4e>
     d46:	f2 e0       	ldi	r31, 0x02	; 2
     d48:	af 12       	cpse	r10, r31
     d4a:	19 c0       	rjmp	.+50     	; 0xd7e <xQueueGenericSend+0x80>
     d4c:	4a 2d       	mov	r20, r10
     d4e:	b6 01       	movw	r22, r12
     d50:	c8 01       	movw	r24, r16
     d52:	0e 94 50 05 	call	0xaa0	; 0xaa0 <prvCopyDataToQueue>
     d56:	f8 01       	movw	r30, r16
     d58:	91 89       	ldd	r25, Z+17	; 0x11
     d5a:	99 23       	and	r25, r25
     d5c:	49 f0       	breq	.+18     	; 0xd70 <xQueueGenericSend+0x72>
     d5e:	c8 01       	movw	r24, r16
     d60:	41 96       	adiw	r24, 0x11	; 17
     d62:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskRemoveFromEventList>
     d66:	81 30       	cpi	r24, 0x01	; 1
     d68:	31 f4       	brne	.+12     	; 0xd76 <xQueueGenericSend+0x78>
     d6a:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
     d6e:	03 c0       	rjmp	.+6      	; 0xd76 <xQueueGenericSend+0x78>
     d70:	81 11       	cpse	r24, r1
     d72:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
     d76:	0f 90       	pop	r0
     d78:	0f be       	out	0x3f, r0	; 63
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	50 c0       	rjmp	.+160    	; 0xe1e <xQueueGenericSend+0x120>
     d7e:	8c 81       	ldd	r24, Y+4	; 0x04
     d80:	9d 81       	ldd	r25, Y+5	; 0x05
     d82:	89 2b       	or	r24, r25
     d84:	21 f4       	brne	.+8      	; 0xd8e <xQueueGenericSend+0x90>
     d86:	0f 90       	pop	r0
     d88:	0f be       	out	0x3f, r0	; 63
     d8a:	80 e0       	ldi	r24, 0x00	; 0
     d8c:	48 c0       	rjmp	.+144    	; 0xe1e <xQueueGenericSend+0x120>
     d8e:	b1 10       	cpse	r11, r1
     d90:	05 c0       	rjmp	.+10     	; 0xd9c <xQueueGenericSend+0x9e>
     d92:	ce 01       	movw	r24, r28
     d94:	01 96       	adiw	r24, 0x01	; 1
     d96:	0e 94 2a 0c 	call	0x1854	; 0x1854 <vTaskSetTimeOutState>
     d9a:	b9 2c       	mov	r11, r9
     d9c:	0f 90       	pop	r0
     d9e:	0f be       	out	0x3f, r0	; 63
     da0:	0e 94 76 09 	call	0x12ec	; 0x12ec <vTaskSuspendAll>
     da4:	0f b6       	in	r0, 0x3f	; 63
     da6:	f8 94       	cli
     da8:	0f 92       	push	r0
     daa:	f8 01       	movw	r30, r16
     dac:	85 8d       	ldd	r24, Z+29	; 0x1d
     dae:	8f 3f       	cpi	r24, 0xFF	; 255
     db0:	09 f4       	brne	.+2      	; 0xdb4 <xQueueGenericSend+0xb6>
     db2:	15 8e       	std	Z+29, r1	; 0x1d
     db4:	f8 01       	movw	r30, r16
     db6:	86 8d       	ldd	r24, Z+30	; 0x1e
     db8:	8f 3f       	cpi	r24, 0xFF	; 255
     dba:	09 f4       	brne	.+2      	; 0xdbe <xQueueGenericSend+0xc0>
     dbc:	16 8e       	std	Z+30, r1	; 0x1e
     dbe:	0f 90       	pop	r0
     dc0:	0f be       	out	0x3f, r0	; 63
     dc2:	be 01       	movw	r22, r28
     dc4:	6c 5f       	subi	r22, 0xFC	; 252
     dc6:	7f 4f       	sbci	r23, 0xFF	; 255
     dc8:	ce 01       	movw	r24, r28
     dca:	01 96       	adiw	r24, 0x01	; 1
     dcc:	0e 94 35 0c 	call	0x186a	; 0x186a <xTaskCheckForTimeOut>
     dd0:	81 11       	cpse	r24, r1
     dd2:	1f c0       	rjmp	.+62     	; 0xe12 <xQueueGenericSend+0x114>
     dd4:	0f b6       	in	r0, 0x3f	; 63
     dd6:	f8 94       	cli
     dd8:	0f 92       	push	r0
     dda:	f8 01       	movw	r30, r16
     ddc:	92 8d       	ldd	r25, Z+26	; 0x1a
     dde:	0f 90       	pop	r0
     de0:	0f be       	out	0x3f, r0	; 63
     de2:	83 8d       	ldd	r24, Z+27	; 0x1b
     de4:	98 13       	cpse	r25, r24
     de6:	0f c0       	rjmp	.+30     	; 0xe06 <xQueueGenericSend+0x108>
     de8:	6c 81       	ldd	r22, Y+4	; 0x04
     dea:	7d 81       	ldd	r23, Y+5	; 0x05
     dec:	c7 01       	movw	r24, r14
     dee:	0e 94 b6 0b 	call	0x176c	; 0x176c <vTaskPlaceOnEventList>
     df2:	c8 01       	movw	r24, r16
     df4:	0e 94 ca 05 	call	0xb94	; 0xb94 <prvUnlockQueue>
     df8:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
     dfc:	81 11       	cpse	r24, r1
     dfe:	9b cf       	rjmp	.-202    	; 0xd36 <xQueueGenericSend+0x38>
     e00:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
     e04:	98 cf       	rjmp	.-208    	; 0xd36 <xQueueGenericSend+0x38>
     e06:	c8 01       	movw	r24, r16
     e08:	0e 94 ca 05 	call	0xb94	; 0xb94 <prvUnlockQueue>
     e0c:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
     e10:	92 cf       	rjmp	.-220    	; 0xd36 <xQueueGenericSend+0x38>
     e12:	c8 01       	movw	r24, r16
     e14:	0e 94 ca 05 	call	0xb94	; 0xb94 <prvUnlockQueue>
     e18:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
     e1c:	80 e0       	ldi	r24, 0x00	; 0
     e1e:	0f 90       	pop	r0
     e20:	0f 90       	pop	r0
     e22:	0f 90       	pop	r0
     e24:	0f 90       	pop	r0
     e26:	0f 90       	pop	r0
     e28:	df 91       	pop	r29
     e2a:	cf 91       	pop	r28
     e2c:	1f 91       	pop	r17
     e2e:	0f 91       	pop	r16
     e30:	ff 90       	pop	r15
     e32:	ef 90       	pop	r14
     e34:	df 90       	pop	r13
     e36:	cf 90       	pop	r12
     e38:	bf 90       	pop	r11
     e3a:	af 90       	pop	r10
     e3c:	9f 90       	pop	r9
     e3e:	08 95       	ret

00000e40 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     e40:	9f 92       	push	r9
     e42:	af 92       	push	r10
     e44:	bf 92       	push	r11
     e46:	cf 92       	push	r12
     e48:	df 92       	push	r13
     e4a:	ef 92       	push	r14
     e4c:	ff 92       	push	r15
     e4e:	0f 93       	push	r16
     e50:	1f 93       	push	r17
     e52:	cf 93       	push	r28
     e54:	df 93       	push	r29
     e56:	00 d0       	rcall	.+0      	; 0xe58 <xQueueGenericReceive+0x18>
     e58:	00 d0       	rcall	.+0      	; 0xe5a <xQueueGenericReceive+0x1a>
     e5a:	1f 92       	push	r1
     e5c:	cd b7       	in	r28, 0x3d	; 61
     e5e:	de b7       	in	r29, 0x3e	; 62
     e60:	8c 01       	movw	r16, r24
     e62:	6b 01       	movw	r12, r22
     e64:	5d 83       	std	Y+5, r21	; 0x05
     e66:	4c 83       	std	Y+4, r20	; 0x04
     e68:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE;
     e6a:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     e6c:	aa 24       	eor	r10, r10
     e6e:	a3 94       	inc	r10
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e70:	7c 01       	movw	r14, r24
     e72:	81 e1       	ldi	r24, 0x11	; 17
     e74:	e8 0e       	add	r14, r24
     e76:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     e78:	0f b6       	in	r0, 0x3f	; 63
     e7a:	f8 94       	cli
     e7c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     e7e:	f8 01       	movw	r30, r16
     e80:	82 8d       	ldd	r24, Z+26	; 0x1a
     e82:	88 23       	and	r24, r24
     e84:	99 f1       	breq	.+102    	; 0xeec <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     e86:	e6 80       	ldd	r14, Z+6	; 0x06
     e88:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     e8a:	b6 01       	movw	r22, r12
     e8c:	c8 01       	movw	r24, r16
     e8e:	0e 94 b0 05 	call	0xb60	; 0xb60 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     e92:	91 10       	cpse	r9, r1
     e94:	1a c0       	rjmp	.+52     	; 0xeca <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     e96:	f8 01       	movw	r30, r16
     e98:	82 8d       	ldd	r24, Z+26	; 0x1a
     e9a:	81 50       	subi	r24, 0x01	; 1
     e9c:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e9e:	80 81       	ld	r24, Z
     ea0:	91 81       	ldd	r25, Z+1	; 0x01
     ea2:	89 2b       	or	r24, r25
     ea4:	29 f4       	brne	.+10     	; 0xeb0 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     ea6:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <pvTaskIncrementMutexHeldCount>
     eaa:	f8 01       	movw	r30, r16
     eac:	93 83       	std	Z+3, r25	; 0x03
     eae:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     eb0:	f8 01       	movw	r30, r16
     eb2:	80 85       	ldd	r24, Z+8	; 0x08
     eb4:	88 23       	and	r24, r24
     eb6:	b1 f0       	breq	.+44     	; 0xee4 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     eb8:	c8 01       	movw	r24, r16
     eba:	08 96       	adiw	r24, 0x08	; 8
     ebc:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskRemoveFromEventList>
     ec0:	81 30       	cpi	r24, 0x01	; 1
     ec2:	81 f4       	brne	.+32     	; 0xee4 <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     ec4:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
     ec8:	0d c0       	rjmp	.+26     	; 0xee4 <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     eca:	f8 01       	movw	r30, r16
     ecc:	f7 82       	std	Z+7, r15	; 0x07
     ece:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ed0:	81 89       	ldd	r24, Z+17	; 0x11
     ed2:	88 23       	and	r24, r24
     ed4:	39 f0       	breq	.+14     	; 0xee4 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ed6:	c8 01       	movw	r24, r16
     ed8:	41 96       	adiw	r24, 0x11	; 17
     eda:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xTaskRemoveFromEventList>
     ede:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     ee0:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     ee4:	0f 90       	pop	r0
     ee6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     ee8:	81 e0       	ldi	r24, 0x01	; 1
     eea:	5c c0       	rjmp	.+184    	; 0xfa4 <xQueueGenericReceive+0x164>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     eec:	8c 81       	ldd	r24, Y+4	; 0x04
     eee:	9d 81       	ldd	r25, Y+5	; 0x05
     ef0:	89 2b       	or	r24, r25
     ef2:	21 f4       	brne	.+8      	; 0xefc <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     ef4:	0f 90       	pop	r0
     ef6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     ef8:	80 e0       	ldi	r24, 0x00	; 0
     efa:	54 c0       	rjmp	.+168    	; 0xfa4 <xQueueGenericReceive+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
     efc:	b1 10       	cpse	r11, r1
     efe:	05 c0       	rjmp	.+10     	; 0xf0a <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f00:	ce 01       	movw	r24, r28
     f02:	01 96       	adiw	r24, 0x01	; 1
     f04:	0e 94 2a 0c 	call	0x1854	; 0x1854 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f08:	ba 2c       	mov	r11, r10
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     f0a:	0f 90       	pop	r0
     f0c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f0e:	0e 94 76 09 	call	0x12ec	; 0x12ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	0f 92       	push	r0
     f18:	f8 01       	movw	r30, r16
     f1a:	85 8d       	ldd	r24, Z+29	; 0x1d
     f1c:	8f 3f       	cpi	r24, 0xFF	; 255
     f1e:	09 f4       	brne	.+2      	; 0xf22 <xQueueGenericReceive+0xe2>
     f20:	15 8e       	std	Z+29, r1	; 0x1d
     f22:	f8 01       	movw	r30, r16
     f24:	86 8d       	ldd	r24, Z+30	; 0x1e
     f26:	8f 3f       	cpi	r24, 0xFF	; 255
     f28:	09 f4       	brne	.+2      	; 0xf2c <xQueueGenericReceive+0xec>
     f2a:	16 8e       	std	Z+30, r1	; 0x1e
     f2c:	0f 90       	pop	r0
     f2e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f30:	be 01       	movw	r22, r28
     f32:	6c 5f       	subi	r22, 0xFC	; 252
     f34:	7f 4f       	sbci	r23, 0xFF	; 255
     f36:	ce 01       	movw	r24, r28
     f38:	01 96       	adiw	r24, 0x01	; 1
     f3a:	0e 94 35 0c 	call	0x186a	; 0x186a <xTaskCheckForTimeOut>
     f3e:	81 11       	cpse	r24, r1
     f40:	2b c0       	rjmp	.+86     	; 0xf98 <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     f42:	0f b6       	in	r0, 0x3f	; 63
     f44:	f8 94       	cli
     f46:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     f48:	f8 01       	movw	r30, r16
     f4a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     f4c:	0f 90       	pop	r0
     f4e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f50:	81 11       	cpse	r24, r1
     f52:	1c c0       	rjmp	.+56     	; 0xf8c <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     f54:	80 81       	ld	r24, Z
     f56:	91 81       	ldd	r25, Z+1	; 0x01
     f58:	89 2b       	or	r24, r25
     f5a:	49 f4       	brne	.+18     	; 0xf6e <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     f62:	82 81       	ldd	r24, Z+2	; 0x02
     f64:	93 81       	ldd	r25, Z+3	; 0x03
     f66:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f6e:	6c 81       	ldd	r22, Y+4	; 0x04
     f70:	7d 81       	ldd	r23, Y+5	; 0x05
     f72:	c7 01       	movw	r24, r14
     f74:	0e 94 b6 0b 	call	0x176c	; 0x176c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     f78:	c8 01       	movw	r24, r16
     f7a:	0e 94 ca 05 	call	0xb94	; 0xb94 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     f7e:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
     f82:	81 11       	cpse	r24, r1
     f84:	79 cf       	rjmp	.-270    	; 0xe78 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     f86:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
     f8a:	76 cf       	rjmp	.-276    	; 0xe78 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f8c:	c8 01       	movw	r24, r16
     f8e:	0e 94 ca 05 	call	0xb94	; 0xb94 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f92:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
     f96:	70 cf       	rjmp	.-288    	; 0xe78 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     f98:	c8 01       	movw	r24, r16
     f9a:	0e 94 ca 05 	call	0xb94	; 0xb94 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f9e:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     fa2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     fa4:	0f 90       	pop	r0
     fa6:	0f 90       	pop	r0
     fa8:	0f 90       	pop	r0
     faa:	0f 90       	pop	r0
     fac:	0f 90       	pop	r0
     fae:	df 91       	pop	r29
     fb0:	cf 91       	pop	r28
     fb2:	1f 91       	pop	r17
     fb4:	0f 91       	pop	r16
     fb6:	ff 90       	pop	r15
     fb8:	ef 90       	pop	r14
     fba:	df 90       	pop	r13
     fbc:	cf 90       	pop	r12
     fbe:	bf 90       	pop	r11
     fc0:	af 90       	pop	r10
     fc2:	9f 90       	pop	r9
     fc4:	08 95       	ret

00000fc6 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     fc6:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
     fca:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
     fce:	80 81       	ld	r24, Z
     fd0:	81 11       	cpse	r24, r1
     fd2:	07 c0       	rjmp	.+14     	; 0xfe2 <prvResetNextTaskUnblockTime+0x1c>
     fd4:	8f ef       	ldi	r24, 0xFF	; 255
     fd6:	9f ef       	ldi	r25, 0xFF	; 255
     fd8:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     fdc:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     fe0:	08 95       	ret
     fe2:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
     fe6:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
     fea:	05 80       	ldd	r0, Z+5	; 0x05
     fec:	f6 81       	ldd	r31, Z+6	; 0x06
     fee:	e0 2d       	mov	r30, r0
     ff0:	06 80       	ldd	r0, Z+6	; 0x06
     ff2:	f7 81       	ldd	r31, Z+7	; 0x07
     ff4:	e0 2d       	mov	r30, r0
     ff6:	82 81       	ldd	r24, Z+2	; 0x02
     ff8:	93 81       	ldd	r25, Z+3	; 0x03
     ffa:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     ffe:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    1002:	08 95       	ret

00001004 <prvAddCurrentTaskToDelayedList>:
    1004:	cf 93       	push	r28
    1006:	df 93       	push	r29
    1008:	ec 01       	movw	r28, r24
    100a:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    100e:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1012:	93 83       	std	Z+3, r25	; 0x03
    1014:	82 83       	std	Z+2, r24	; 0x02
    1016:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
    101a:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
    101e:	c8 17       	cp	r28, r24
    1020:	d9 07       	cpc	r29, r25
    1022:	68 f4       	brcc	.+26     	; 0x103e <prvAddCurrentTaskToDelayedList+0x3a>
    1024:	60 91 e8 07 	lds	r22, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1028:	70 91 e9 07 	lds	r23, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    102c:	80 91 b7 07 	lds	r24, 0x07B7	; 0x8007b7 <pxOverflowDelayedTaskList>
    1030:	90 91 b8 07 	lds	r25, 0x07B8	; 0x8007b8 <pxOverflowDelayedTaskList+0x1>
    1034:	6e 5f       	subi	r22, 0xFE	; 254
    1036:	7f 4f       	sbci	r23, 0xFF	; 255
    1038:	0e 94 ce 02 	call	0x59c	; 0x59c <vListInsert>
    103c:	17 c0       	rjmp	.+46     	; 0x106c <prvAddCurrentTaskToDelayedList+0x68>
    103e:	60 91 e8 07 	lds	r22, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1042:	70 91 e9 07 	lds	r23, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1046:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
    104a:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
    104e:	6e 5f       	subi	r22, 0xFE	; 254
    1050:	7f 4f       	sbci	r23, 0xFF	; 255
    1052:	0e 94 ce 02 	call	0x59c	; 0x59c <vListInsert>
    1056:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
    105a:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
    105e:	c8 17       	cp	r28, r24
    1060:	d9 07       	cpc	r29, r25
    1062:	20 f4       	brcc	.+8      	; 0x106c <prvAddCurrentTaskToDelayedList+0x68>
    1064:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <xNextTaskUnblockTime+0x1>
    1068:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <xNextTaskUnblockTime>
    106c:	df 91       	pop	r29
    106e:	cf 91       	pop	r28
    1070:	08 95       	ret

00001072 <xTaskGenericCreate>:
    1072:	4f 92       	push	r4
    1074:	5f 92       	push	r5
    1076:	6f 92       	push	r6
    1078:	7f 92       	push	r7
    107a:	8f 92       	push	r8
    107c:	9f 92       	push	r9
    107e:	af 92       	push	r10
    1080:	bf 92       	push	r11
    1082:	cf 92       	push	r12
    1084:	df 92       	push	r13
    1086:	ef 92       	push	r14
    1088:	ff 92       	push	r15
    108a:	0f 93       	push	r16
    108c:	1f 93       	push	r17
    108e:	cf 93       	push	r28
    1090:	df 93       	push	r29
    1092:	4c 01       	movw	r8, r24
    1094:	eb 01       	movw	r28, r22
    1096:	5a 01       	movw	r10, r20
    1098:	29 01       	movw	r4, r18
    109a:	c1 14       	cp	r12, r1
    109c:	d1 04       	cpc	r13, r1
    109e:	39 f4       	brne	.+14     	; 0x10ae <xTaskGenericCreate+0x3c>
    10a0:	ca 01       	movw	r24, r20
    10a2:	0e 94 83 04 	call	0x906	; 0x906 <pvPortMalloc>
    10a6:	6c 01       	movw	r12, r24
    10a8:	89 2b       	or	r24, r25
    10aa:	09 f4       	brne	.+2      	; 0x10ae <xTaskGenericCreate+0x3c>
    10ac:	de c0       	rjmp	.+444    	; 0x126a <xTaskGenericCreate+0x1f8>
    10ae:	88 e2       	ldi	r24, 0x28	; 40
    10b0:	90 e0       	ldi	r25, 0x00	; 0
    10b2:	0e 94 83 04 	call	0x906	; 0x906 <pvPortMalloc>
    10b6:	3c 01       	movw	r6, r24
    10b8:	00 97       	sbiw	r24, 0x00	; 0
    10ba:	79 f0       	breq	.+30     	; 0x10da <xTaskGenericCreate+0x68>
    10bc:	fc 01       	movw	r30, r24
    10be:	d0 8e       	std	Z+24, r13	; 0x18
    10c0:	c7 8a       	std	Z+23, r12	; 0x17
    10c2:	f1 e0       	ldi	r31, 0x01	; 1
    10c4:	af 1a       	sub	r10, r31
    10c6:	b1 08       	sbc	r11, r1
    10c8:	ca 0c       	add	r12, r10
    10ca:	db 1c       	adc	r13, r11
    10cc:	88 81       	ld	r24, Y
    10ce:	f3 01       	movw	r30, r6
    10d0:	81 8f       	std	Z+25, r24	; 0x19
    10d2:	88 81       	ld	r24, Y
    10d4:	81 11       	cpse	r24, r1
    10d6:	05 c0       	rjmp	.+10     	; 0x10e2 <xTaskGenericCreate+0x70>
    10d8:	14 c0       	rjmp	.+40     	; 0x1102 <xTaskGenericCreate+0x90>
    10da:	c6 01       	movw	r24, r12
    10dc:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vPortFree>
    10e0:	c4 c0       	rjmp	.+392    	; 0x126a <xTaskGenericCreate+0x1f8>
    10e2:	d3 01       	movw	r26, r6
    10e4:	5a 96       	adiw	r26, 0x1a	; 26
    10e6:	fe 01       	movw	r30, r28
    10e8:	31 96       	adiw	r30, 0x01	; 1
    10ea:	9e 01       	movw	r18, r28
    10ec:	28 5f       	subi	r18, 0xF8	; 248
    10ee:	3f 4f       	sbci	r19, 0xFF	; 255
    10f0:	ef 01       	movw	r28, r30
    10f2:	81 91       	ld	r24, Z+
    10f4:	8d 93       	st	X+, r24
    10f6:	88 81       	ld	r24, Y
    10f8:	88 23       	and	r24, r24
    10fa:	19 f0       	breq	.+6      	; 0x1102 <xTaskGenericCreate+0x90>
    10fc:	e2 17       	cp	r30, r18
    10fe:	f3 07       	cpc	r31, r19
    1100:	b9 f7       	brne	.-18     	; 0x10f0 <xTaskGenericCreate+0x7e>
    1102:	f3 01       	movw	r30, r6
    1104:	10 a2       	std	Z+32, r1	; 0x20
    1106:	10 2f       	mov	r17, r16
    1108:	03 30       	cpi	r16, 0x03	; 3
    110a:	08 f0       	brcs	.+2      	; 0x110e <xTaskGenericCreate+0x9c>
    110c:	12 e0       	ldi	r17, 0x02	; 2
    110e:	f3 01       	movw	r30, r6
    1110:	16 8b       	std	Z+22, r17	; 0x16
    1112:	11 a3       	std	Z+33, r17	; 0x21
    1114:	12 a2       	std	Z+34, r1	; 0x22
    1116:	e3 01       	movw	r28, r6
    1118:	22 96       	adiw	r28, 0x02	; 2
    111a:	ce 01       	movw	r24, r28
    111c:	0e 94 a9 02 	call	0x552	; 0x552 <vListInitialiseItem>
    1120:	c3 01       	movw	r24, r6
    1122:	0c 96       	adiw	r24, 0x0c	; 12
    1124:	0e 94 a9 02 	call	0x552	; 0x552 <vListInitialiseItem>
    1128:	f3 01       	movw	r30, r6
    112a:	71 86       	std	Z+9, r7	; 0x09
    112c:	60 86       	std	Z+8, r6	; 0x08
    112e:	83 e0       	ldi	r24, 0x03	; 3
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	81 1b       	sub	r24, r17
    1134:	91 09       	sbc	r25, r1
    1136:	95 87       	std	Z+13, r25	; 0x0d
    1138:	84 87       	std	Z+12, r24	; 0x0c
    113a:	73 8a       	std	Z+19, r7	; 0x13
    113c:	62 8a       	std	Z+18, r6	; 0x12
    113e:	13 a2       	std	Z+35, r1	; 0x23
    1140:	14 a2       	std	Z+36, r1	; 0x24
    1142:	15 a2       	std	Z+37, r1	; 0x25
    1144:	16 a2       	std	Z+38, r1	; 0x26
    1146:	17 a2       	std	Z+39, r1	; 0x27
    1148:	a2 01       	movw	r20, r4
    114a:	b4 01       	movw	r22, r8
    114c:	c6 01       	movw	r24, r12
    114e:	0e 94 25 03 	call	0x64a	; 0x64a <pxPortInitialiseStack>
    1152:	f3 01       	movw	r30, r6
    1154:	91 83       	std	Z+1, r25	; 0x01
    1156:	80 83       	st	Z, r24
    1158:	e1 14       	cp	r14, r1
    115a:	f1 04       	cpc	r15, r1
    115c:	19 f0       	breq	.+6      	; 0x1164 <xTaskGenericCreate+0xf2>
    115e:	f7 01       	movw	r30, r14
    1160:	71 82       	std	Z+1, r7	; 0x01
    1162:	60 82       	st	Z, r6
    1164:	0f b6       	in	r0, 0x3f	; 63
    1166:	f8 94       	cli
    1168:	0f 92       	push	r0
    116a:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uxCurrentNumberOfTasks>
    116e:	8f 5f       	subi	r24, 0xFF	; 255
    1170:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxCurrentNumberOfTasks>
    1174:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1178:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    117c:	89 2b       	or	r24, r25
    117e:	a9 f5       	brne	.+106    	; 0x11ea <xTaskGenericCreate+0x178>
    1180:	70 92 e9 07 	sts	0x07E9, r7	; 0x8007e9 <pxCurrentTCB+0x1>
    1184:	60 92 e8 07 	sts	0x07E8, r6	; 0x8007e8 <pxCurrentTCB>
    1188:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uxCurrentNumberOfTasks>
    118c:	81 30       	cpi	r24, 0x01	; 1
    118e:	e1 f5       	brne	.+120    	; 0x1208 <xTaskGenericCreate+0x196>
    1190:	8d ec       	ldi	r24, 0xCD	; 205
    1192:	97 e0       	ldi	r25, 0x07	; 7
    1194:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
    1198:	86 ed       	ldi	r24, 0xD6	; 214
    119a:	97 e0       	ldi	r25, 0x07	; 7
    119c:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
    11a0:	8f ed       	ldi	r24, 0xDF	; 223
    11a2:	97 e0       	ldi	r25, 0x07	; 7
    11a4:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
    11a8:	84 ec       	ldi	r24, 0xC4	; 196
    11aa:	97 e0       	ldi	r25, 0x07	; 7
    11ac:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
    11b0:	8b eb       	ldi	r24, 0xBB	; 187
    11b2:	97 e0       	ldi	r25, 0x07	; 7
    11b4:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
    11b8:	8e ea       	ldi	r24, 0xAE	; 174
    11ba:	97 e0       	ldi	r25, 0x07	; 7
    11bc:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
    11c0:	85 ea       	ldi	r24, 0xA5	; 165
    11c2:	97 e0       	ldi	r25, 0x07	; 7
    11c4:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
    11c8:	8b e9       	ldi	r24, 0x9B	; 155
    11ca:	97 e0       	ldi	r25, 0x07	; 7
    11cc:	0e 94 9b 02 	call	0x536	; 0x536 <vListInitialise>
    11d0:	84 ec       	ldi	r24, 0xC4	; 196
    11d2:	97 e0       	ldi	r25, 0x07	; 7
    11d4:	90 93 ba 07 	sts	0x07BA, r25	; 0x8007ba <pxDelayedTaskList+0x1>
    11d8:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <pxDelayedTaskList>
    11dc:	8b eb       	ldi	r24, 0xBB	; 187
    11de:	97 e0       	ldi	r25, 0x07	; 7
    11e0:	90 93 b8 07 	sts	0x07B8, r25	; 0x8007b8 <pxOverflowDelayedTaskList+0x1>
    11e4:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <pxOverflowDelayedTaskList>
    11e8:	0f c0       	rjmp	.+30     	; 0x1208 <xTaskGenericCreate+0x196>
    11ea:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <xSchedulerRunning>
    11ee:	81 11       	cpse	r24, r1
    11f0:	0b c0       	rjmp	.+22     	; 0x1208 <xTaskGenericCreate+0x196>
    11f2:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    11f6:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    11fa:	86 89       	ldd	r24, Z+22	; 0x16
    11fc:	08 17       	cp	r16, r24
    11fe:	20 f0       	brcs	.+8      	; 0x1208 <xTaskGenericCreate+0x196>
    1200:	70 92 e9 07 	sts	0x07E9, r7	; 0x8007e9 <pxCurrentTCB+0x1>
    1204:	60 92 e8 07 	sts	0x07E8, r6	; 0x8007e8 <pxCurrentTCB>
    1208:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <uxTaskNumber>
    120c:	8f 5f       	subi	r24, 0xFF	; 255
    120e:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <uxTaskNumber>
    1212:	f3 01       	movw	r30, r6
    1214:	86 89       	ldd	r24, Z+22	; 0x16
    1216:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    121a:	98 17       	cp	r25, r24
    121c:	10 f4       	brcc	.+4      	; 0x1222 <xTaskGenericCreate+0x1b0>
    121e:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	9c 01       	movw	r18, r24
    1226:	22 0f       	add	r18, r18
    1228:	33 1f       	adc	r19, r19
    122a:	22 0f       	add	r18, r18
    122c:	33 1f       	adc	r19, r19
    122e:	22 0f       	add	r18, r18
    1230:	33 1f       	adc	r19, r19
    1232:	82 0f       	add	r24, r18
    1234:	93 1f       	adc	r25, r19
    1236:	be 01       	movw	r22, r28
    1238:	83 53       	subi	r24, 0x33	; 51
    123a:	98 4f       	sbci	r25, 0xF8	; 248
    123c:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsertEnd>
    1240:	0f 90       	pop	r0
    1242:	0f be       	out	0x3f, r0	; 63
    1244:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <xSchedulerRunning>
    1248:	88 23       	and	r24, r24
    124a:	59 f0       	breq	.+22     	; 0x1262 <xTaskGenericCreate+0x1f0>
    124c:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1250:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1254:	86 89       	ldd	r24, Z+22	; 0x16
    1256:	80 17       	cp	r24, r16
    1258:	30 f4       	brcc	.+12     	; 0x1266 <xTaskGenericCreate+0x1f4>
    125a:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	05 c0       	rjmp	.+10     	; 0x126c <xTaskGenericCreate+0x1fa>
    1262:	81 e0       	ldi	r24, 0x01	; 1
    1264:	03 c0       	rjmp	.+6      	; 0x126c <xTaskGenericCreate+0x1fa>
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	01 c0       	rjmp	.+2      	; 0x126c <xTaskGenericCreate+0x1fa>
    126a:	8f ef       	ldi	r24, 0xFF	; 255
    126c:	df 91       	pop	r29
    126e:	cf 91       	pop	r28
    1270:	1f 91       	pop	r17
    1272:	0f 91       	pop	r16
    1274:	ff 90       	pop	r15
    1276:	ef 90       	pop	r14
    1278:	df 90       	pop	r13
    127a:	cf 90       	pop	r12
    127c:	bf 90       	pop	r11
    127e:	af 90       	pop	r10
    1280:	9f 90       	pop	r9
    1282:	8f 90       	pop	r8
    1284:	7f 90       	pop	r7
    1286:	6f 90       	pop	r6
    1288:	5f 90       	pop	r5
    128a:	4f 90       	pop	r4
    128c:	08 95       	ret

0000128e <vTaskStartScheduler>:
    128e:	af 92       	push	r10
    1290:	bf 92       	push	r11
    1292:	cf 92       	push	r12
    1294:	df 92       	push	r13
    1296:	ef 92       	push	r14
    1298:	ff 92       	push	r15
    129a:	0f 93       	push	r16
    129c:	a1 2c       	mov	r10, r1
    129e:	b1 2c       	mov	r11, r1
    12a0:	c1 2c       	mov	r12, r1
    12a2:	d1 2c       	mov	r13, r1
    12a4:	0f 2e       	mov	r0, r31
    12a6:	f9 e9       	ldi	r31, 0x99	; 153
    12a8:	ef 2e       	mov	r14, r31
    12aa:	f7 e0       	ldi	r31, 0x07	; 7
    12ac:	ff 2e       	mov	r15, r31
    12ae:	f0 2d       	mov	r31, r0
    12b0:	00 e0       	ldi	r16, 0x00	; 0
    12b2:	20 e0       	ldi	r18, 0x00	; 0
    12b4:	30 e0       	ldi	r19, 0x00	; 0
    12b6:	45 e5       	ldi	r20, 0x55	; 85
    12b8:	50 e0       	ldi	r21, 0x00	; 0
    12ba:	64 ea       	ldi	r22, 0xA4	; 164
    12bc:	71 e0       	ldi	r23, 0x01	; 1
    12be:	8c e0       	ldi	r24, 0x0C	; 12
    12c0:	9b e0       	ldi	r25, 0x0B	; 11
    12c2:	0e 94 39 08 	call	0x1072	; 0x1072 <xTaskGenericCreate>
    12c6:	81 30       	cpi	r24, 0x01	; 1
    12c8:	49 f4       	brne	.+18     	; 0x12dc <vTaskStartScheduler+0x4e>
    12ca:	f8 94       	cli
    12cc:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <xSchedulerRunning>
    12d0:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <xTickCount+0x1>
    12d4:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <xTickCount>
    12d8:	0e 94 91 03 	call	0x722	; 0x722 <xPortStartScheduler>
    12dc:	0f 91       	pop	r16
    12de:	ff 90       	pop	r15
    12e0:	ef 90       	pop	r14
    12e2:	df 90       	pop	r13
    12e4:	cf 90       	pop	r12
    12e6:	bf 90       	pop	r11
    12e8:	af 90       	pop	r10
    12ea:	08 95       	ret

000012ec <vTaskSuspendAll>:
    12ec:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    12f0:	8f 5f       	subi	r24, 0xFF	; 255
    12f2:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxSchedulerSuspended>
    12f6:	08 95       	ret

000012f8 <xTaskGetTickCount>:
    12f8:	0f b6       	in	r0, 0x3f	; 63
    12fa:	f8 94       	cli
    12fc:	0f 92       	push	r0
    12fe:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
    1302:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
    1306:	0f 90       	pop	r0
    1308:	0f be       	out	0x3f, r0	; 63
    130a:	08 95       	ret

0000130c <xTaskGetTickCountFromISR>:
    130c:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
    1310:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
    1314:	08 95       	ret

00001316 <xTaskIncrementTick>:
    1316:	cf 92       	push	r12
    1318:	df 92       	push	r13
    131a:	ef 92       	push	r14
    131c:	ff 92       	push	r15
    131e:	0f 93       	push	r16
    1320:	1f 93       	push	r17
    1322:	cf 93       	push	r28
    1324:	df 93       	push	r29
    1326:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    132a:	81 11       	cpse	r24, r1
    132c:	9b c0       	rjmp	.+310    	; 0x1464 <xTaskIncrementTick+0x14e>
    132e:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
    1332:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
    1336:	01 96       	adiw	r24, 0x01	; 1
    1338:	90 93 97 07 	sts	0x0797, r25	; 0x800797 <xTickCount+0x1>
    133c:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <xTickCount>
    1340:	e0 90 96 07 	lds	r14, 0x0796	; 0x800796 <xTickCount>
    1344:	f0 90 97 07 	lds	r15, 0x0797	; 0x800797 <xTickCount+0x1>
    1348:	e1 14       	cp	r14, r1
    134a:	f1 04       	cpc	r15, r1
    134c:	b9 f4       	brne	.+46     	; 0x137c <xTaskIncrementTick+0x66>
    134e:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
    1352:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
    1356:	20 91 b7 07 	lds	r18, 0x07B7	; 0x8007b7 <pxOverflowDelayedTaskList>
    135a:	30 91 b8 07 	lds	r19, 0x07B8	; 0x8007b8 <pxOverflowDelayedTaskList+0x1>
    135e:	30 93 ba 07 	sts	0x07BA, r19	; 0x8007ba <pxDelayedTaskList+0x1>
    1362:	20 93 b9 07 	sts	0x07B9, r18	; 0x8007b9 <pxDelayedTaskList>
    1366:	90 93 b8 07 	sts	0x07B8, r25	; 0x8007b8 <pxOverflowDelayedTaskList+0x1>
    136a:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <pxOverflowDelayedTaskList>
    136e:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <xNumOfOverflows>
    1372:	8f 5f       	subi	r24, 0xFF	; 255
    1374:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNumOfOverflows>
    1378:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <prvResetNextTaskUnblockTime>
    137c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
    1380:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
    1384:	e8 16       	cp	r14, r24
    1386:	f9 06       	cpc	r15, r25
    1388:	10 f4       	brcc	.+4      	; 0x138e <xTaskIncrementTick+0x78>
    138a:	d1 2c       	mov	r13, r1
    138c:	53 c0       	rjmp	.+166    	; 0x1434 <xTaskIncrementTick+0x11e>
    138e:	d1 2c       	mov	r13, r1
    1390:	cc 24       	eor	r12, r12
    1392:	c3 94       	inc	r12
    1394:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
    1398:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
    139c:	80 81       	ld	r24, Z
    139e:	81 11       	cpse	r24, r1
    13a0:	07 c0       	rjmp	.+14     	; 0x13b0 <xTaskIncrementTick+0x9a>
    13a2:	8f ef       	ldi	r24, 0xFF	; 255
    13a4:	9f ef       	ldi	r25, 0xFF	; 255
    13a6:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    13aa:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    13ae:	42 c0       	rjmp	.+132    	; 0x1434 <xTaskIncrementTick+0x11e>
    13b0:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
    13b4:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
    13b8:	05 80       	ldd	r0, Z+5	; 0x05
    13ba:	f6 81       	ldd	r31, Z+6	; 0x06
    13bc:	e0 2d       	mov	r30, r0
    13be:	c6 81       	ldd	r28, Z+6	; 0x06
    13c0:	d7 81       	ldd	r29, Z+7	; 0x07
    13c2:	8a 81       	ldd	r24, Y+2	; 0x02
    13c4:	9b 81       	ldd	r25, Y+3	; 0x03
    13c6:	e8 16       	cp	r14, r24
    13c8:	f9 06       	cpc	r15, r25
    13ca:	28 f4       	brcc	.+10     	; 0x13d6 <xTaskIncrementTick+0xc0>
    13cc:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    13d0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    13d4:	2f c0       	rjmp	.+94     	; 0x1434 <xTaskIncrementTick+0x11e>
    13d6:	8e 01       	movw	r16, r28
    13d8:	0e 5f       	subi	r16, 0xFE	; 254
    13da:	1f 4f       	sbci	r17, 0xFF	; 255
    13dc:	c8 01       	movw	r24, r16
    13de:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    13e2:	8c 89       	ldd	r24, Y+20	; 0x14
    13e4:	9d 89       	ldd	r25, Y+21	; 0x15
    13e6:	89 2b       	or	r24, r25
    13e8:	21 f0       	breq	.+8      	; 0x13f2 <xTaskIncrementTick+0xdc>
    13ea:	ce 01       	movw	r24, r28
    13ec:	0c 96       	adiw	r24, 0x0c	; 12
    13ee:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    13f2:	8e 89       	ldd	r24, Y+22	; 0x16
    13f4:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    13f8:	98 17       	cp	r25, r24
    13fa:	10 f4       	brcc	.+4      	; 0x1400 <xTaskIncrementTick+0xea>
    13fc:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    1400:	90 e0       	ldi	r25, 0x00	; 0
    1402:	9c 01       	movw	r18, r24
    1404:	22 0f       	add	r18, r18
    1406:	33 1f       	adc	r19, r19
    1408:	22 0f       	add	r18, r18
    140a:	33 1f       	adc	r19, r19
    140c:	22 0f       	add	r18, r18
    140e:	33 1f       	adc	r19, r19
    1410:	82 0f       	add	r24, r18
    1412:	93 1f       	adc	r25, r19
    1414:	b8 01       	movw	r22, r16
    1416:	83 53       	subi	r24, 0x33	; 51
    1418:	98 4f       	sbci	r25, 0xF8	; 248
    141a:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsertEnd>
    141e:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1422:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1426:	9e 89       	ldd	r25, Y+22	; 0x16
    1428:	86 89       	ldd	r24, Z+22	; 0x16
    142a:	98 17       	cp	r25, r24
    142c:	08 f4       	brcc	.+2      	; 0x1430 <xTaskIncrementTick+0x11a>
    142e:	b2 cf       	rjmp	.-156    	; 0x1394 <xTaskIncrementTick+0x7e>
    1430:	dc 2c       	mov	r13, r12
    1432:	b0 cf       	rjmp	.-160    	; 0x1394 <xTaskIncrementTick+0x7e>
    1434:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1438:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    143c:	86 89       	ldd	r24, Z+22	; 0x16
    143e:	90 e0       	ldi	r25, 0x00	; 0
    1440:	fc 01       	movw	r30, r24
    1442:	ee 0f       	add	r30, r30
    1444:	ff 1f       	adc	r31, r31
    1446:	ee 0f       	add	r30, r30
    1448:	ff 1f       	adc	r31, r31
    144a:	ee 0f       	add	r30, r30
    144c:	ff 1f       	adc	r31, r31
    144e:	8e 0f       	add	r24, r30
    1450:	9f 1f       	adc	r25, r31
    1452:	fc 01       	movw	r30, r24
    1454:	e3 53       	subi	r30, 0x33	; 51
    1456:	f8 4f       	sbci	r31, 0xF8	; 248
    1458:	80 81       	ld	r24, Z
    145a:	82 30       	cpi	r24, 0x02	; 2
    145c:	48 f0       	brcs	.+18     	; 0x1470 <xTaskIncrementTick+0x15a>
    145e:	dd 24       	eor	r13, r13
    1460:	d3 94       	inc	r13
    1462:	06 c0       	rjmp	.+12     	; 0x1470 <xTaskIncrementTick+0x15a>
    1464:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    1468:	8f 5f       	subi	r24, 0xFF	; 255
    146a:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <uxPendedTicks>
    146e:	d1 2c       	mov	r13, r1
    1470:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <xYieldPending>
    1474:	88 23       	and	r24, r24
    1476:	11 f0       	breq	.+4      	; 0x147c <xTaskIncrementTick+0x166>
    1478:	dd 24       	eor	r13, r13
    147a:	d3 94       	inc	r13
    147c:	8d 2d       	mov	r24, r13
    147e:	df 91       	pop	r29
    1480:	cf 91       	pop	r28
    1482:	1f 91       	pop	r17
    1484:	0f 91       	pop	r16
    1486:	ff 90       	pop	r15
    1488:	ef 90       	pop	r14
    148a:	df 90       	pop	r13
    148c:	cf 90       	pop	r12
    148e:	08 95       	ret

00001490 <xTaskResumeAll>:
    1490:	df 92       	push	r13
    1492:	ef 92       	push	r14
    1494:	ff 92       	push	r15
    1496:	0f 93       	push	r16
    1498:	1f 93       	push	r17
    149a:	cf 93       	push	r28
    149c:	df 93       	push	r29
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	f8 94       	cli
    14a2:	0f 92       	push	r0
    14a4:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    14a8:	81 50       	subi	r24, 0x01	; 1
    14aa:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxSchedulerSuspended>
    14ae:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    14b2:	81 11       	cpse	r24, r1
    14b4:	62 c0       	rjmp	.+196    	; 0x157a <xTaskResumeAll+0xea>
    14b6:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uxCurrentNumberOfTasks>
    14ba:	81 11       	cpse	r24, r1
    14bc:	33 c0       	rjmp	.+102    	; 0x1524 <xTaskResumeAll+0x94>
    14be:	60 c0       	rjmp	.+192    	; 0x1580 <xTaskResumeAll+0xf0>
    14c0:	d7 01       	movw	r26, r14
    14c2:	15 96       	adiw	r26, 0x05	; 5
    14c4:	ed 91       	ld	r30, X+
    14c6:	fc 91       	ld	r31, X
    14c8:	16 97       	sbiw	r26, 0x06	; 6
    14ca:	c6 81       	ldd	r28, Z+6	; 0x06
    14cc:	d7 81       	ldd	r29, Z+7	; 0x07
    14ce:	ce 01       	movw	r24, r28
    14d0:	0c 96       	adiw	r24, 0x0c	; 12
    14d2:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    14d6:	8e 01       	movw	r16, r28
    14d8:	0e 5f       	subi	r16, 0xFE	; 254
    14da:	1f 4f       	sbci	r17, 0xFF	; 255
    14dc:	c8 01       	movw	r24, r16
    14de:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    14e2:	8e 89       	ldd	r24, Y+22	; 0x16
    14e4:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    14e8:	98 17       	cp	r25, r24
    14ea:	10 f4       	brcc	.+4      	; 0x14f0 <xTaskResumeAll+0x60>
    14ec:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	9c 01       	movw	r18, r24
    14f4:	22 0f       	add	r18, r18
    14f6:	33 1f       	adc	r19, r19
    14f8:	22 0f       	add	r18, r18
    14fa:	33 1f       	adc	r19, r19
    14fc:	22 0f       	add	r18, r18
    14fe:	33 1f       	adc	r19, r19
    1500:	82 0f       	add	r24, r18
    1502:	93 1f       	adc	r25, r19
    1504:	b8 01       	movw	r22, r16
    1506:	83 53       	subi	r24, 0x33	; 51
    1508:	98 4f       	sbci	r25, 0xF8	; 248
    150a:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsertEnd>
    150e:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1512:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1516:	9e 89       	ldd	r25, Y+22	; 0x16
    1518:	86 89       	ldd	r24, Z+22	; 0x16
    151a:	98 17       	cp	r25, r24
    151c:	58 f0       	brcs	.+22     	; 0x1534 <xTaskResumeAll+0xa4>
    151e:	d0 92 92 07 	sts	0x0792, r13	; 0x800792 <xYieldPending>
    1522:	08 c0       	rjmp	.+16     	; 0x1534 <xTaskResumeAll+0xa4>
    1524:	0f 2e       	mov	r0, r31
    1526:	fe ea       	ldi	r31, 0xAE	; 174
    1528:	ef 2e       	mov	r14, r31
    152a:	f7 e0       	ldi	r31, 0x07	; 7
    152c:	ff 2e       	mov	r15, r31
    152e:	f0 2d       	mov	r31, r0
    1530:	dd 24       	eor	r13, r13
    1532:	d3 94       	inc	r13
    1534:	f7 01       	movw	r30, r14
    1536:	80 81       	ld	r24, Z
    1538:	81 11       	cpse	r24, r1
    153a:	c2 cf       	rjmp	.-124    	; 0x14c0 <xTaskResumeAll+0x30>
    153c:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    1540:	88 23       	and	r24, r24
    1542:	99 f0       	breq	.+38     	; 0x156a <xTaskResumeAll+0xda>
    1544:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    1548:	88 23       	and	r24, r24
    154a:	79 f0       	breq	.+30     	; 0x156a <xTaskResumeAll+0xda>
    154c:	c1 e0       	ldi	r28, 0x01	; 1
    154e:	0e 94 8b 09 	call	0x1316	; 0x1316 <xTaskIncrementTick>
    1552:	81 11       	cpse	r24, r1
    1554:	c0 93 92 07 	sts	0x0792, r28	; 0x800792 <xYieldPending>
    1558:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    155c:	81 50       	subi	r24, 0x01	; 1
    155e:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <uxPendedTicks>
    1562:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    1566:	81 11       	cpse	r24, r1
    1568:	f2 cf       	rjmp	.-28     	; 0x154e <xTaskResumeAll+0xbe>
    156a:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <xYieldPending>
    156e:	81 30       	cpi	r24, 0x01	; 1
    1570:	31 f4       	brne	.+12     	; 0x157e <xTaskResumeAll+0xee>
    1572:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
    1576:	81 e0       	ldi	r24, 0x01	; 1
    1578:	03 c0       	rjmp	.+6      	; 0x1580 <xTaskResumeAll+0xf0>
    157a:	80 e0       	ldi	r24, 0x00	; 0
    157c:	01 c0       	rjmp	.+2      	; 0x1580 <xTaskResumeAll+0xf0>
    157e:	80 e0       	ldi	r24, 0x00	; 0
    1580:	0f 90       	pop	r0
    1582:	0f be       	out	0x3f, r0	; 63
    1584:	df 91       	pop	r29
    1586:	cf 91       	pop	r28
    1588:	1f 91       	pop	r17
    158a:	0f 91       	pop	r16
    158c:	ff 90       	pop	r15
    158e:	ef 90       	pop	r14
    1590:	df 90       	pop	r13
    1592:	08 95       	ret

00001594 <vTaskDelayUntil>:
    1594:	0f 93       	push	r16
    1596:	1f 93       	push	r17
    1598:	cf 93       	push	r28
    159a:	df 93       	push	r29
    159c:	8c 01       	movw	r16, r24
    159e:	eb 01       	movw	r28, r22
    15a0:	0e 94 76 09 	call	0x12ec	; 0x12ec <vTaskSuspendAll>
    15a4:	20 91 96 07 	lds	r18, 0x0796	; 0x800796 <xTickCount>
    15a8:	30 91 97 07 	lds	r19, 0x0797	; 0x800797 <xTickCount+0x1>
    15ac:	f8 01       	movw	r30, r16
    15ae:	80 81       	ld	r24, Z
    15b0:	91 81       	ldd	r25, Z+1	; 0x01
    15b2:	c8 0f       	add	r28, r24
    15b4:	d9 1f       	adc	r29, r25
    15b6:	28 17       	cp	r18, r24
    15b8:	39 07       	cpc	r19, r25
    15ba:	48 f4       	brcc	.+18     	; 0x15ce <vTaskDelayUntil+0x3a>
    15bc:	c8 17       	cp	r28, r24
    15be:	d9 07       	cpc	r29, r25
    15c0:	10 f5       	brcc	.+68     	; 0x1606 <vTaskDelayUntil+0x72>
    15c2:	d1 83       	std	Z+1, r29	; 0x01
    15c4:	c0 83       	st	Z, r28
    15c6:	2c 17       	cp	r18, r28
    15c8:	3d 07       	cpc	r19, r29
    15ca:	90 f4       	brcc	.+36     	; 0x15f0 <vTaskDelayUntil+0x5c>
    15cc:	07 c0       	rjmp	.+14     	; 0x15dc <vTaskDelayUntil+0x48>
    15ce:	c8 17       	cp	r28, r24
    15d0:	d9 07       	cpc	r29, r25
    15d2:	a8 f0       	brcs	.+42     	; 0x15fe <vTaskDelayUntil+0x6a>
    15d4:	2c 17       	cp	r18, r28
    15d6:	3d 07       	cpc	r19, r29
    15d8:	90 f0       	brcs	.+36     	; 0x15fe <vTaskDelayUntil+0x6a>
    15da:	15 c0       	rjmp	.+42     	; 0x1606 <vTaskDelayUntil+0x72>
    15dc:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    15e0:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    15e4:	02 96       	adiw	r24, 0x02	; 2
    15e6:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    15ea:	ce 01       	movw	r24, r28
    15ec:	0e 94 02 08 	call	0x1004	; 0x1004 <prvAddCurrentTaskToDelayedList>
    15f0:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
    15f4:	81 11       	cpse	r24, r1
    15f6:	0b c0       	rjmp	.+22     	; 0x160e <vTaskDelayUntil+0x7a>
    15f8:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
    15fc:	08 c0       	rjmp	.+16     	; 0x160e <vTaskDelayUntil+0x7a>
    15fe:	f8 01       	movw	r30, r16
    1600:	d1 83       	std	Z+1, r29	; 0x01
    1602:	c0 83       	st	Z, r28
    1604:	eb cf       	rjmp	.-42     	; 0x15dc <vTaskDelayUntil+0x48>
    1606:	f8 01       	movw	r30, r16
    1608:	d1 83       	std	Z+1, r29	; 0x01
    160a:	c0 83       	st	Z, r28
    160c:	f1 cf       	rjmp	.-30     	; 0x15f0 <vTaskDelayUntil+0x5c>
    160e:	df 91       	pop	r29
    1610:	cf 91       	pop	r28
    1612:	1f 91       	pop	r17
    1614:	0f 91       	pop	r16
    1616:	08 95       	ret

00001618 <prvIdleTask>:
    1618:	05 ea       	ldi	r16, 0xA5	; 165
    161a:	17 e0       	ldi	r17, 0x07	; 7
    161c:	0f 2e       	mov	r0, r31
    161e:	fd ec       	ldi	r31, 0xCD	; 205
    1620:	ef 2e       	mov	r14, r31
    1622:	f7 e0       	ldi	r31, 0x07	; 7
    1624:	ff 2e       	mov	r15, r31
    1626:	f0 2d       	mov	r31, r0
    1628:	29 c0       	rjmp	.+82     	; 0x167c <prvIdleTask+0x64>
    162a:	0e 94 76 09 	call	0x12ec	; 0x12ec <vTaskSuspendAll>
    162e:	d8 01       	movw	r26, r16
    1630:	cc 91       	ld	r28, X
    1632:	0e 94 48 0a 	call	0x1490	; 0x1490 <xTaskResumeAll>
    1636:	cc 23       	and	r28, r28
    1638:	09 f1       	breq	.+66     	; 0x167c <prvIdleTask+0x64>
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	0f 92       	push	r0
    1640:	d8 01       	movw	r26, r16
    1642:	15 96       	adiw	r26, 0x05	; 5
    1644:	ed 91       	ld	r30, X+
    1646:	fc 91       	ld	r31, X
    1648:	16 97       	sbiw	r26, 0x06	; 6
    164a:	c6 81       	ldd	r28, Z+6	; 0x06
    164c:	d7 81       	ldd	r29, Z+7	; 0x07
    164e:	ce 01       	movw	r24, r28
    1650:	02 96       	adiw	r24, 0x02	; 2
    1652:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    1656:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uxCurrentNumberOfTasks>
    165a:	81 50       	subi	r24, 0x01	; 1
    165c:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxCurrentNumberOfTasks>
    1660:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <uxTasksDeleted>
    1664:	81 50       	subi	r24, 0x01	; 1
    1666:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <uxTasksDeleted>
    166a:	0f 90       	pop	r0
    166c:	0f be       	out	0x3f, r0	; 63
    166e:	8f 89       	ldd	r24, Y+23	; 0x17
    1670:	98 8d       	ldd	r25, Y+24	; 0x18
    1672:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vPortFree>
    1676:	ce 01       	movw	r24, r28
    1678:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vPortFree>
    167c:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <uxTasksDeleted>
    1680:	81 11       	cpse	r24, r1
    1682:	d3 cf       	rjmp	.-90     	; 0x162a <prvIdleTask+0x12>
    1684:	f7 01       	movw	r30, r14
    1686:	80 81       	ld	r24, Z
    1688:	82 30       	cpi	r24, 0x02	; 2
    168a:	c0 f3       	brcs	.-16     	; 0x167c <prvIdleTask+0x64>
    168c:	0e 94 cb 03 	call	0x796	; 0x796 <vPortYield>
    1690:	f5 cf       	rjmp	.-22     	; 0x167c <prvIdleTask+0x64>

00001692 <vTaskSwitchContext>:
    1692:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    1696:	88 23       	and	r24, r24
    1698:	21 f0       	breq	.+8      	; 0x16a2 <vTaskSwitchContext+0x10>
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xYieldPending>
    16a0:	08 95       	ret
    16a2:	10 92 92 07 	sts	0x0792, r1	; 0x800792 <xYieldPending>
    16a6:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uxTopReadyPriority>
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	fc 01       	movw	r30, r24
    16ae:	ee 0f       	add	r30, r30
    16b0:	ff 1f       	adc	r31, r31
    16b2:	ee 0f       	add	r30, r30
    16b4:	ff 1f       	adc	r31, r31
    16b6:	ee 0f       	add	r30, r30
    16b8:	ff 1f       	adc	r31, r31
    16ba:	8e 0f       	add	r24, r30
    16bc:	9f 1f       	adc	r25, r31
    16be:	fc 01       	movw	r30, r24
    16c0:	e3 53       	subi	r30, 0x33	; 51
    16c2:	f8 4f       	sbci	r31, 0xF8	; 248
    16c4:	80 81       	ld	r24, Z
    16c6:	81 11       	cpse	r24, r1
    16c8:	17 c0       	rjmp	.+46     	; 0x16f8 <vTaskSwitchContext+0x66>
    16ca:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uxTopReadyPriority>
    16ce:	81 50       	subi	r24, 0x01	; 1
    16d0:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    16d4:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uxTopReadyPriority>
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	fc 01       	movw	r30, r24
    16dc:	ee 0f       	add	r30, r30
    16de:	ff 1f       	adc	r31, r31
    16e0:	ee 0f       	add	r30, r30
    16e2:	ff 1f       	adc	r31, r31
    16e4:	ee 0f       	add	r30, r30
    16e6:	ff 1f       	adc	r31, r31
    16e8:	8e 0f       	add	r24, r30
    16ea:	9f 1f       	adc	r25, r31
    16ec:	fc 01       	movw	r30, r24
    16ee:	e3 53       	subi	r30, 0x33	; 51
    16f0:	f8 4f       	sbci	r31, 0xF8	; 248
    16f2:	80 81       	ld	r24, Z
    16f4:	88 23       	and	r24, r24
    16f6:	49 f3       	breq	.-46     	; 0x16ca <vTaskSwitchContext+0x38>
    16f8:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uxTopReadyPriority>
    16fc:	90 e0       	ldi	r25, 0x00	; 0
    16fe:	9c 01       	movw	r18, r24
    1700:	22 0f       	add	r18, r18
    1702:	33 1f       	adc	r19, r19
    1704:	22 0f       	add	r18, r18
    1706:	33 1f       	adc	r19, r19
    1708:	22 0f       	add	r18, r18
    170a:	33 1f       	adc	r19, r19
    170c:	28 0f       	add	r18, r24
    170e:	39 1f       	adc	r19, r25
    1710:	d9 01       	movw	r26, r18
    1712:	a3 53       	subi	r26, 0x33	; 51
    1714:	b8 4f       	sbci	r27, 0xF8	; 248
    1716:	11 96       	adiw	r26, 0x01	; 1
    1718:	ed 91       	ld	r30, X+
    171a:	fc 91       	ld	r31, X
    171c:	12 97       	sbiw	r26, 0x02	; 2
    171e:	02 80       	ldd	r0, Z+2	; 0x02
    1720:	f3 81       	ldd	r31, Z+3	; 0x03
    1722:	e0 2d       	mov	r30, r0
    1724:	12 96       	adiw	r26, 0x02	; 2
    1726:	fc 93       	st	X, r31
    1728:	ee 93       	st	-X, r30
    172a:	11 97       	sbiw	r26, 0x01	; 1
    172c:	20 53       	subi	r18, 0x30	; 48
    172e:	38 4f       	sbci	r19, 0xF8	; 248
    1730:	e2 17       	cp	r30, r18
    1732:	f3 07       	cpc	r31, r19
    1734:	29 f4       	brne	.+10     	; 0x1740 <vTaskSwitchContext+0xae>
    1736:	22 81       	ldd	r18, Z+2	; 0x02
    1738:	33 81       	ldd	r19, Z+3	; 0x03
    173a:	fd 01       	movw	r30, r26
    173c:	32 83       	std	Z+2, r19	; 0x02
    173e:	21 83       	std	Z+1, r18	; 0x01
    1740:	fc 01       	movw	r30, r24
    1742:	ee 0f       	add	r30, r30
    1744:	ff 1f       	adc	r31, r31
    1746:	ee 0f       	add	r30, r30
    1748:	ff 1f       	adc	r31, r31
    174a:	ee 0f       	add	r30, r30
    174c:	ff 1f       	adc	r31, r31
    174e:	8e 0f       	add	r24, r30
    1750:	9f 1f       	adc	r25, r31
    1752:	fc 01       	movw	r30, r24
    1754:	e3 53       	subi	r30, 0x33	; 51
    1756:	f8 4f       	sbci	r31, 0xF8	; 248
    1758:	01 80       	ldd	r0, Z+1	; 0x01
    175a:	f2 81       	ldd	r31, Z+2	; 0x02
    175c:	e0 2d       	mov	r30, r0
    175e:	86 81       	ldd	r24, Z+6	; 0x06
    1760:	97 81       	ldd	r25, Z+7	; 0x07
    1762:	90 93 e9 07 	sts	0x07E9, r25	; 0x8007e9 <pxCurrentTCB+0x1>
    1766:	80 93 e8 07 	sts	0x07E8, r24	; 0x8007e8 <pxCurrentTCB>
    176a:	08 95       	ret

0000176c <vTaskPlaceOnEventList>:
    176c:	cf 93       	push	r28
    176e:	df 93       	push	r29
    1770:	eb 01       	movw	r28, r22
    1772:	60 91 e8 07 	lds	r22, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1776:	70 91 e9 07 	lds	r23, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    177a:	64 5f       	subi	r22, 0xF4	; 244
    177c:	7f 4f       	sbci	r23, 0xFF	; 255
    177e:	0e 94 ce 02 	call	0x59c	; 0x59c <vListInsert>
    1782:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1786:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    178a:	02 96       	adiw	r24, 0x02	; 2
    178c:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    1790:	cf 3f       	cpi	r28, 0xFF	; 255
    1792:	8f ef       	ldi	r24, 0xFF	; 255
    1794:	d8 07       	cpc	r29, r24
    1796:	59 f4       	brne	.+22     	; 0x17ae <vTaskPlaceOnEventList+0x42>
    1798:	60 91 e8 07 	lds	r22, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    179c:	70 91 e9 07 	lds	r23, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    17a0:	6e 5f       	subi	r22, 0xFE	; 254
    17a2:	7f 4f       	sbci	r23, 0xFF	; 255
    17a4:	8b e9       	ldi	r24, 0x9B	; 155
    17a6:	97 e0       	ldi	r25, 0x07	; 7
    17a8:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsertEnd>
    17ac:	08 c0       	rjmp	.+16     	; 0x17be <vTaskPlaceOnEventList+0x52>
    17ae:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
    17b2:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
    17b6:	8c 0f       	add	r24, r28
    17b8:	9d 1f       	adc	r25, r29
    17ba:	0e 94 02 08 	call	0x1004	; 0x1004 <prvAddCurrentTaskToDelayedList>
    17be:	df 91       	pop	r29
    17c0:	cf 91       	pop	r28
    17c2:	08 95       	ret

000017c4 <xTaskRemoveFromEventList>:
    17c4:	0f 93       	push	r16
    17c6:	1f 93       	push	r17
    17c8:	cf 93       	push	r28
    17ca:	df 93       	push	r29
    17cc:	dc 01       	movw	r26, r24
    17ce:	15 96       	adiw	r26, 0x05	; 5
    17d0:	ed 91       	ld	r30, X+
    17d2:	fc 91       	ld	r31, X
    17d4:	16 97       	sbiw	r26, 0x06	; 6
    17d6:	c6 81       	ldd	r28, Z+6	; 0x06
    17d8:	d7 81       	ldd	r29, Z+7	; 0x07
    17da:	8e 01       	movw	r16, r28
    17dc:	04 5f       	subi	r16, 0xF4	; 244
    17de:	1f 4f       	sbci	r17, 0xFF	; 255
    17e0:	c8 01       	movw	r24, r16
    17e2:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    17e6:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    17ea:	81 11       	cpse	r24, r1
    17ec:	1c c0       	rjmp	.+56     	; 0x1826 <xTaskRemoveFromEventList+0x62>
    17ee:	0a 50       	subi	r16, 0x0A	; 10
    17f0:	11 09       	sbc	r17, r1
    17f2:	c8 01       	movw	r24, r16
    17f4:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    17f8:	8e 89       	ldd	r24, Y+22	; 0x16
    17fa:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    17fe:	98 17       	cp	r25, r24
    1800:	10 f4       	brcc	.+4      	; 0x1806 <xTaskRemoveFromEventList+0x42>
    1802:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    1806:	90 e0       	ldi	r25, 0x00	; 0
    1808:	9c 01       	movw	r18, r24
    180a:	22 0f       	add	r18, r18
    180c:	33 1f       	adc	r19, r19
    180e:	22 0f       	add	r18, r18
    1810:	33 1f       	adc	r19, r19
    1812:	22 0f       	add	r18, r18
    1814:	33 1f       	adc	r19, r19
    1816:	82 0f       	add	r24, r18
    1818:	93 1f       	adc	r25, r19
    181a:	b8 01       	movw	r22, r16
    181c:	83 53       	subi	r24, 0x33	; 51
    181e:	98 4f       	sbci	r25, 0xF8	; 248
    1820:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsertEnd>
    1824:	05 c0       	rjmp	.+10     	; 0x1830 <xTaskRemoveFromEventList+0x6c>
    1826:	b8 01       	movw	r22, r16
    1828:	8e ea       	ldi	r24, 0xAE	; 174
    182a:	97 e0       	ldi	r25, 0x07	; 7
    182c:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsertEnd>
    1830:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1834:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1838:	9e 89       	ldd	r25, Y+22	; 0x16
    183a:	86 89       	ldd	r24, Z+22	; 0x16
    183c:	89 17       	cp	r24, r25
    183e:	20 f4       	brcc	.+8      	; 0x1848 <xTaskRemoveFromEventList+0x84>
    1840:	81 e0       	ldi	r24, 0x01	; 1
    1842:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xYieldPending>
    1846:	01 c0       	rjmp	.+2      	; 0x184a <xTaskRemoveFromEventList+0x86>
    1848:	80 e0       	ldi	r24, 0x00	; 0
    184a:	df 91       	pop	r29
    184c:	cf 91       	pop	r28
    184e:	1f 91       	pop	r17
    1850:	0f 91       	pop	r16
    1852:	08 95       	ret

00001854 <vTaskSetTimeOutState>:
    1854:	20 91 91 07 	lds	r18, 0x0791	; 0x800791 <xNumOfOverflows>
    1858:	fc 01       	movw	r30, r24
    185a:	20 83       	st	Z, r18
    185c:	20 91 96 07 	lds	r18, 0x0796	; 0x800796 <xTickCount>
    1860:	30 91 97 07 	lds	r19, 0x0797	; 0x800797 <xTickCount+0x1>
    1864:	32 83       	std	Z+2, r19	; 0x02
    1866:	21 83       	std	Z+1, r18	; 0x01
    1868:	08 95       	ret

0000186a <xTaskCheckForTimeOut>:
    186a:	0f b6       	in	r0, 0x3f	; 63
    186c:	f8 94       	cli
    186e:	0f 92       	push	r0
    1870:	40 91 96 07 	lds	r20, 0x0796	; 0x800796 <xTickCount>
    1874:	50 91 97 07 	lds	r21, 0x0797	; 0x800797 <xTickCount+0x1>
    1878:	db 01       	movw	r26, r22
    187a:	2d 91       	ld	r18, X+
    187c:	3c 91       	ld	r19, X
    187e:	2f 3f       	cpi	r18, 0xFF	; 255
    1880:	bf ef       	ldi	r27, 0xFF	; 255
    1882:	3b 07       	cpc	r19, r27
    1884:	19 f1       	breq	.+70     	; 0x18cc <xTaskCheckForTimeOut+0x62>
    1886:	e0 91 91 07 	lds	r30, 0x0791	; 0x800791 <xNumOfOverflows>
    188a:	dc 01       	movw	r26, r24
    188c:	fc 91       	ld	r31, X
    188e:	fe 17       	cp	r31, r30
    1890:	39 f0       	breq	.+14     	; 0x18a0 <xTaskCheckForTimeOut+0x36>
    1892:	11 96       	adiw	r26, 0x01	; 1
    1894:	ed 91       	ld	r30, X+
    1896:	fc 91       	ld	r31, X
    1898:	12 97       	sbiw	r26, 0x02	; 2
    189a:	4e 17       	cp	r20, r30
    189c:	5f 07       	cpc	r21, r31
    189e:	c0 f4       	brcc	.+48     	; 0x18d0 <xTaskCheckForTimeOut+0x66>
    18a0:	dc 01       	movw	r26, r24
    18a2:	11 96       	adiw	r26, 0x01	; 1
    18a4:	ed 91       	ld	r30, X+
    18a6:	fc 91       	ld	r31, X
    18a8:	12 97       	sbiw	r26, 0x02	; 2
    18aa:	da 01       	movw	r26, r20
    18ac:	ae 1b       	sub	r26, r30
    18ae:	bf 0b       	sbc	r27, r31
    18b0:	a2 17       	cp	r26, r18
    18b2:	b3 07       	cpc	r27, r19
    18b4:	78 f4       	brcc	.+30     	; 0x18d4 <xTaskCheckForTimeOut+0x6a>
    18b6:	db 01       	movw	r26, r22
    18b8:	e4 1b       	sub	r30, r20
    18ba:	f5 0b       	sbc	r31, r21
    18bc:	2e 0f       	add	r18, r30
    18be:	3f 1f       	adc	r19, r31
    18c0:	2d 93       	st	X+, r18
    18c2:	3c 93       	st	X, r19
    18c4:	0e 94 2a 0c 	call	0x1854	; 0x1854 <vTaskSetTimeOutState>
    18c8:	80 e0       	ldi	r24, 0x00	; 0
    18ca:	05 c0       	rjmp	.+10     	; 0x18d6 <xTaskCheckForTimeOut+0x6c>
    18cc:	80 e0       	ldi	r24, 0x00	; 0
    18ce:	03 c0       	rjmp	.+6      	; 0x18d6 <xTaskCheckForTimeOut+0x6c>
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	01 c0       	rjmp	.+2      	; 0x18d6 <xTaskCheckForTimeOut+0x6c>
    18d4:	81 e0       	ldi	r24, 0x01	; 1
    18d6:	0f 90       	pop	r0
    18d8:	0f be       	out	0x3f, r0	; 63
    18da:	08 95       	ret

000018dc <vTaskMissedYield>:
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xYieldPending>
    18e2:	08 95       	ret

000018e4 <vTaskPriorityInherit>:
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	cf 93       	push	r28
    18ea:	df 93       	push	r29
    18ec:	fc 01       	movw	r30, r24
    18ee:	89 2b       	or	r24, r25
    18f0:	09 f4       	brne	.+2      	; 0x18f4 <vTaskPriorityInherit+0x10>
    18f2:	55 c0       	rjmp	.+170    	; 0x199e <vTaskPriorityInherit+0xba>
    18f4:	26 89       	ldd	r18, Z+22	; 0x16
    18f6:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    18fa:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    18fe:	56 96       	adiw	r26, 0x16	; 22
    1900:	8c 91       	ld	r24, X
    1902:	28 17       	cp	r18, r24
    1904:	08 f0       	brcs	.+2      	; 0x1908 <vTaskPriorityInherit+0x24>
    1906:	4b c0       	rjmp	.+150    	; 0x199e <vTaskPriorityInherit+0xba>
    1908:	84 85       	ldd	r24, Z+12	; 0x0c
    190a:	95 85       	ldd	r25, Z+13	; 0x0d
    190c:	99 23       	and	r25, r25
    190e:	64 f0       	brlt	.+24     	; 0x1928 <vTaskPriorityInherit+0x44>
    1910:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1914:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1918:	56 96       	adiw	r26, 0x16	; 22
    191a:	3c 91       	ld	r19, X
    191c:	83 e0       	ldi	r24, 0x03	; 3
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	83 1b       	sub	r24, r19
    1922:	91 09       	sbc	r25, r1
    1924:	95 87       	std	Z+13, r25	; 0x0d
    1926:	84 87       	std	Z+12, r24	; 0x0c
    1928:	30 e0       	ldi	r19, 0x00	; 0
    192a:	c9 01       	movw	r24, r18
    192c:	88 0f       	add	r24, r24
    192e:	99 1f       	adc	r25, r25
    1930:	88 0f       	add	r24, r24
    1932:	99 1f       	adc	r25, r25
    1934:	88 0f       	add	r24, r24
    1936:	99 1f       	adc	r25, r25
    1938:	28 0f       	add	r18, r24
    193a:	39 1f       	adc	r19, r25
    193c:	23 53       	subi	r18, 0x33	; 51
    193e:	38 4f       	sbci	r19, 0xF8	; 248
    1940:	82 85       	ldd	r24, Z+10	; 0x0a
    1942:	93 85       	ldd	r25, Z+11	; 0x0b
    1944:	82 17       	cp	r24, r18
    1946:	93 07       	cpc	r25, r19
    1948:	19 f5       	brne	.+70     	; 0x1990 <vTaskPriorityInherit+0xac>
    194a:	8f 01       	movw	r16, r30
    194c:	ef 01       	movw	r28, r30
    194e:	22 96       	adiw	r28, 0x02	; 2
    1950:	ce 01       	movw	r24, r28
    1952:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    1956:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    195a:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    195e:	86 89       	ldd	r24, Z+22	; 0x16
    1960:	f8 01       	movw	r30, r16
    1962:	86 8b       	std	Z+22, r24	; 0x16
    1964:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    1968:	98 17       	cp	r25, r24
    196a:	10 f4       	brcc	.+4      	; 0x1970 <vTaskPriorityInherit+0x8c>
    196c:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	9c 01       	movw	r18, r24
    1974:	22 0f       	add	r18, r18
    1976:	33 1f       	adc	r19, r19
    1978:	22 0f       	add	r18, r18
    197a:	33 1f       	adc	r19, r19
    197c:	22 0f       	add	r18, r18
    197e:	33 1f       	adc	r19, r19
    1980:	82 0f       	add	r24, r18
    1982:	93 1f       	adc	r25, r19
    1984:	be 01       	movw	r22, r28
    1986:	83 53       	subi	r24, 0x33	; 51
    1988:	98 4f       	sbci	r25, 0xF8	; 248
    198a:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsertEnd>
    198e:	07 c0       	rjmp	.+14     	; 0x199e <vTaskPriorityInherit+0xba>
    1990:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1994:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1998:	56 96       	adiw	r26, 0x16	; 22
    199a:	8c 91       	ld	r24, X
    199c:	86 8b       	std	Z+22, r24	; 0x16
    199e:	df 91       	pop	r29
    19a0:	cf 91       	pop	r28
    19a2:	1f 91       	pop	r17
    19a4:	0f 91       	pop	r16
    19a6:	08 95       	ret

000019a8 <xTaskPriorityDisinherit>:
    19a8:	0f 93       	push	r16
    19aa:	1f 93       	push	r17
    19ac:	cf 93       	push	r28
    19ae:	df 93       	push	r29
    19b0:	fc 01       	movw	r30, r24
    19b2:	89 2b       	or	r24, r25
    19b4:	79 f1       	breq	.+94     	; 0x1a14 <xTaskPriorityDisinherit+0x6c>
    19b6:	82 a1       	ldd	r24, Z+34	; 0x22
    19b8:	81 50       	subi	r24, 0x01	; 1
    19ba:	82 a3       	std	Z+34, r24	; 0x22
    19bc:	26 89       	ldd	r18, Z+22	; 0x16
    19be:	91 a1       	ldd	r25, Z+33	; 0x21
    19c0:	29 17       	cp	r18, r25
    19c2:	51 f1       	breq	.+84     	; 0x1a18 <xTaskPriorityDisinherit+0x70>
    19c4:	81 11       	cpse	r24, r1
    19c6:	2a c0       	rjmp	.+84     	; 0x1a1c <xTaskPriorityDisinherit+0x74>
    19c8:	ef 01       	movw	r28, r30
    19ca:	8f 01       	movw	r16, r30
    19cc:	0e 5f       	subi	r16, 0xFE	; 254
    19ce:	1f 4f       	sbci	r17, 0xFF	; 255
    19d0:	c8 01       	movw	r24, r16
    19d2:	0e 94 ff 02 	call	0x5fe	; 0x5fe <uxListRemove>
    19d6:	89 a1       	ldd	r24, Y+33	; 0x21
    19d8:	8e 8b       	std	Y+22, r24	; 0x16
    19da:	23 e0       	ldi	r18, 0x03	; 3
    19dc:	30 e0       	ldi	r19, 0x00	; 0
    19de:	28 1b       	sub	r18, r24
    19e0:	31 09       	sbc	r19, r1
    19e2:	3d 87       	std	Y+13, r19	; 0x0d
    19e4:	2c 87       	std	Y+12, r18	; 0x0c
    19e6:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    19ea:	98 17       	cp	r25, r24
    19ec:	10 f4       	brcc	.+4      	; 0x19f2 <xTaskPriorityDisinherit+0x4a>
    19ee:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    19f2:	90 e0       	ldi	r25, 0x00	; 0
    19f4:	9c 01       	movw	r18, r24
    19f6:	22 0f       	add	r18, r18
    19f8:	33 1f       	adc	r19, r19
    19fa:	22 0f       	add	r18, r18
    19fc:	33 1f       	adc	r19, r19
    19fe:	22 0f       	add	r18, r18
    1a00:	33 1f       	adc	r19, r19
    1a02:	82 0f       	add	r24, r18
    1a04:	93 1f       	adc	r25, r19
    1a06:	b8 01       	movw	r22, r16
    1a08:	83 53       	subi	r24, 0x33	; 51
    1a0a:	98 4f       	sbci	r25, 0xF8	; 248
    1a0c:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsertEnd>
    1a10:	81 e0       	ldi	r24, 0x01	; 1
    1a12:	05 c0       	rjmp	.+10     	; 0x1a1e <xTaskPriorityDisinherit+0x76>
    1a14:	80 e0       	ldi	r24, 0x00	; 0
    1a16:	03 c0       	rjmp	.+6      	; 0x1a1e <xTaskPriorityDisinherit+0x76>
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	01 c0       	rjmp	.+2      	; 0x1a1e <xTaskPriorityDisinherit+0x76>
    1a1c:	80 e0       	ldi	r24, 0x00	; 0
    1a1e:	df 91       	pop	r29
    1a20:	cf 91       	pop	r28
    1a22:	1f 91       	pop	r17
    1a24:	0f 91       	pop	r16
    1a26:	08 95       	ret

00001a28 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1a28:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1a2c:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1a30:	89 2b       	or	r24, r25
    1a32:	39 f0       	breq	.+14     	; 0x1a42 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1a34:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1a38:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1a3c:	82 a1       	ldd	r24, Z+34	; 0x22
    1a3e:	8f 5f       	subi	r24, 0xFF	; 255
    1a40:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1a42:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1a46:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
	}
    1a4a:	08 95       	ret

00001a4c <attachInterrupt>:
    #endif
      break;
#endif
    }
      
    intFunc[interruptNum] = 0;
    1a4c:	82 30       	cpi	r24, 0x02	; 2
    1a4e:	00 f5       	brcc	.+64     	; 0x1a90 <attachInterrupt+0x44>
    1a50:	e8 2f       	mov	r30, r24
    1a52:	f0 e0       	ldi	r31, 0x00	; 0
    1a54:	ee 0f       	add	r30, r30
    1a56:	ff 1f       	adc	r31, r31
    1a58:	e6 51       	subi	r30, 0x16	; 22
    1a5a:	f8 4f       	sbci	r31, 0xF8	; 248
    1a5c:	71 83       	std	Z+1, r23	; 0x01
    1a5e:	60 83       	st	Z, r22
    1a60:	88 23       	and	r24, r24
    1a62:	19 f0       	breq	.+6      	; 0x1a6a <attachInterrupt+0x1e>
    1a64:	81 30       	cpi	r24, 0x01	; 1
    1a66:	49 f0       	breq	.+18     	; 0x1a7a <attachInterrupt+0x2e>
    1a68:	08 95       	ret
    1a6a:	e9 e6       	ldi	r30, 0x69	; 105
    1a6c:	f0 e0       	ldi	r31, 0x00	; 0
    1a6e:	80 81       	ld	r24, Z
    1a70:	8c 7f       	andi	r24, 0xFC	; 252
    1a72:	48 2b       	or	r20, r24
    1a74:	40 83       	st	Z, r20
    1a76:	e8 9a       	sbi	0x1d, 0	; 29
    1a78:	08 95       	ret
    1a7a:	e9 e6       	ldi	r30, 0x69	; 105
    1a7c:	f0 e0       	ldi	r31, 0x00	; 0
    1a7e:	80 81       	ld	r24, Z
    1a80:	83 7f       	andi	r24, 0xF3	; 243
    1a82:	44 0f       	add	r20, r20
    1a84:	55 1f       	adc	r21, r21
    1a86:	44 0f       	add	r20, r20
    1a88:	55 1f       	adc	r21, r21
    1a8a:	48 2b       	or	r20, r24
    1a8c:	40 83       	st	Z, r20
    1a8e:	e9 9a       	sbi	0x1d, 1	; 29
    1a90:	08 95       	ret

00001a92 <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

ISR(INT0_vect) {
    1a92:	1f 92       	push	r1
    1a94:	0f 92       	push	r0
    1a96:	0f b6       	in	r0, 0x3f	; 63
    1a98:	0f 92       	push	r0
    1a9a:	11 24       	eor	r1, r1
    1a9c:	2f 93       	push	r18
    1a9e:	3f 93       	push	r19
    1aa0:	4f 93       	push	r20
    1aa2:	5f 93       	push	r21
    1aa4:	6f 93       	push	r22
    1aa6:	7f 93       	push	r23
    1aa8:	8f 93       	push	r24
    1aaa:	9f 93       	push	r25
    1aac:	af 93       	push	r26
    1aae:	bf 93       	push	r27
    1ab0:	ef 93       	push	r30
    1ab2:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_0])
    1ab4:	80 91 ea 07 	lds	r24, 0x07EA	; 0x8007ea <intFunc>
    1ab8:	90 91 eb 07 	lds	r25, 0x07EB	; 0x8007eb <intFunc+0x1>
    1abc:	89 2b       	or	r24, r25
    1abe:	29 f0       	breq	.+10     	; 0x1aca <__vector_1+0x38>
    intFunc[EXTERNAL_INT_0]();
    1ac0:	e0 91 ea 07 	lds	r30, 0x07EA	; 0x8007ea <intFunc>
    1ac4:	f0 91 eb 07 	lds	r31, 0x07EB	; 0x8007eb <intFunc+0x1>
    1ac8:	09 95       	icall
}
    1aca:	ff 91       	pop	r31
    1acc:	ef 91       	pop	r30
    1ace:	bf 91       	pop	r27
    1ad0:	af 91       	pop	r26
    1ad2:	9f 91       	pop	r25
    1ad4:	8f 91       	pop	r24
    1ad6:	7f 91       	pop	r23
    1ad8:	6f 91       	pop	r22
    1ada:	5f 91       	pop	r21
    1adc:	4f 91       	pop	r20
    1ade:	3f 91       	pop	r19
    1ae0:	2f 91       	pop	r18
    1ae2:	0f 90       	pop	r0
    1ae4:	0f be       	out	0x3f, r0	; 63
    1ae6:	0f 90       	pop	r0
    1ae8:	1f 90       	pop	r1
    1aea:	18 95       	reti

00001aec <__vector_2>:

ISR(INT1_vect) {
    1aec:	1f 92       	push	r1
    1aee:	0f 92       	push	r0
    1af0:	0f b6       	in	r0, 0x3f	; 63
    1af2:	0f 92       	push	r0
    1af4:	11 24       	eor	r1, r1
    1af6:	2f 93       	push	r18
    1af8:	3f 93       	push	r19
    1afa:	4f 93       	push	r20
    1afc:	5f 93       	push	r21
    1afe:	6f 93       	push	r22
    1b00:	7f 93       	push	r23
    1b02:	8f 93       	push	r24
    1b04:	9f 93       	push	r25
    1b06:	af 93       	push	r26
    1b08:	bf 93       	push	r27
    1b0a:	ef 93       	push	r30
    1b0c:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_1])
    1b0e:	80 91 ec 07 	lds	r24, 0x07EC	; 0x8007ec <intFunc+0x2>
    1b12:	90 91 ed 07 	lds	r25, 0x07ED	; 0x8007ed <intFunc+0x3>
    1b16:	89 2b       	or	r24, r25
    1b18:	29 f0       	breq	.+10     	; 0x1b24 <__vector_2+0x38>
    intFunc[EXTERNAL_INT_1]();
    1b1a:	e0 91 ec 07 	lds	r30, 0x07EC	; 0x8007ec <intFunc+0x2>
    1b1e:	f0 91 ed 07 	lds	r31, 0x07ED	; 0x8007ed <intFunc+0x3>
    1b22:	09 95       	icall
}
    1b24:	ff 91       	pop	r31
    1b26:	ef 91       	pop	r30
    1b28:	bf 91       	pop	r27
    1b2a:	af 91       	pop	r26
    1b2c:	9f 91       	pop	r25
    1b2e:	8f 91       	pop	r24
    1b30:	7f 91       	pop	r23
    1b32:	6f 91       	pop	r22
    1b34:	5f 91       	pop	r21
    1b36:	4f 91       	pop	r20
    1b38:	3f 91       	pop	r19
    1b3a:	2f 91       	pop	r18
    1b3c:	0f 90       	pop	r0
    1b3e:	0f be       	out	0x3f, r0	; 63
    1b40:	0f 90       	pop	r0
    1b42:	1f 90       	pop	r1
    1b44:	18 95       	reti

00001b46 <__divsf3>:
    1b46:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <__divsf3x>
    1b4a:	0c 94 69 0e 	jmp	0x1cd2	; 0x1cd2 <__fp_round>
    1b4e:	0e 94 62 0e 	call	0x1cc4	; 0x1cc4 <__fp_pscB>
    1b52:	58 f0       	brcs	.+22     	; 0x1b6a <__divsf3+0x24>
    1b54:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <__fp_pscA>
    1b58:	40 f0       	brcs	.+16     	; 0x1b6a <__divsf3+0x24>
    1b5a:	29 f4       	brne	.+10     	; 0x1b66 <__divsf3+0x20>
    1b5c:	5f 3f       	cpi	r21, 0xFF	; 255
    1b5e:	29 f0       	breq	.+10     	; 0x1b6a <__divsf3+0x24>
    1b60:	0c 94 52 0e 	jmp	0x1ca4	; 0x1ca4 <__fp_inf>
    1b64:	51 11       	cpse	r21, r1
    1b66:	0c 94 9d 0e 	jmp	0x1d3a	; 0x1d3a <__fp_szero>
    1b6a:	0c 94 58 0e 	jmp	0x1cb0	; 0x1cb0 <__fp_nan>

00001b6e <__divsf3x>:
    1b6e:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <__fp_split3>
    1b72:	68 f3       	brcs	.-38     	; 0x1b4e <__divsf3+0x8>

00001b74 <__divsf3_pse>:
    1b74:	99 23       	and	r25, r25
    1b76:	b1 f3       	breq	.-20     	; 0x1b64 <__divsf3+0x1e>
    1b78:	55 23       	and	r21, r21
    1b7a:	91 f3       	breq	.-28     	; 0x1b60 <__divsf3+0x1a>
    1b7c:	95 1b       	sub	r25, r21
    1b7e:	55 0b       	sbc	r21, r21
    1b80:	bb 27       	eor	r27, r27
    1b82:	aa 27       	eor	r26, r26
    1b84:	62 17       	cp	r22, r18
    1b86:	73 07       	cpc	r23, r19
    1b88:	84 07       	cpc	r24, r20
    1b8a:	38 f0       	brcs	.+14     	; 0x1b9a <__divsf3_pse+0x26>
    1b8c:	9f 5f       	subi	r25, 0xFF	; 255
    1b8e:	5f 4f       	sbci	r21, 0xFF	; 255
    1b90:	22 0f       	add	r18, r18
    1b92:	33 1f       	adc	r19, r19
    1b94:	44 1f       	adc	r20, r20
    1b96:	aa 1f       	adc	r26, r26
    1b98:	a9 f3       	breq	.-22     	; 0x1b84 <__divsf3_pse+0x10>
    1b9a:	35 d0       	rcall	.+106    	; 0x1c06 <__divsf3_pse+0x92>
    1b9c:	0e 2e       	mov	r0, r30
    1b9e:	3a f0       	brmi	.+14     	; 0x1bae <__divsf3_pse+0x3a>
    1ba0:	e0 e8       	ldi	r30, 0x80	; 128
    1ba2:	32 d0       	rcall	.+100    	; 0x1c08 <__divsf3_pse+0x94>
    1ba4:	91 50       	subi	r25, 0x01	; 1
    1ba6:	50 40       	sbci	r21, 0x00	; 0
    1ba8:	e6 95       	lsr	r30
    1baa:	00 1c       	adc	r0, r0
    1bac:	ca f7       	brpl	.-14     	; 0x1ba0 <__divsf3_pse+0x2c>
    1bae:	2b d0       	rcall	.+86     	; 0x1c06 <__divsf3_pse+0x92>
    1bb0:	fe 2f       	mov	r31, r30
    1bb2:	29 d0       	rcall	.+82     	; 0x1c06 <__divsf3_pse+0x92>
    1bb4:	66 0f       	add	r22, r22
    1bb6:	77 1f       	adc	r23, r23
    1bb8:	88 1f       	adc	r24, r24
    1bba:	bb 1f       	adc	r27, r27
    1bbc:	26 17       	cp	r18, r22
    1bbe:	37 07       	cpc	r19, r23
    1bc0:	48 07       	cpc	r20, r24
    1bc2:	ab 07       	cpc	r26, r27
    1bc4:	b0 e8       	ldi	r27, 0x80	; 128
    1bc6:	09 f0       	breq	.+2      	; 0x1bca <__divsf3_pse+0x56>
    1bc8:	bb 0b       	sbc	r27, r27
    1bca:	80 2d       	mov	r24, r0
    1bcc:	bf 01       	movw	r22, r30
    1bce:	ff 27       	eor	r31, r31
    1bd0:	93 58       	subi	r25, 0x83	; 131
    1bd2:	5f 4f       	sbci	r21, 0xFF	; 255
    1bd4:	3a f0       	brmi	.+14     	; 0x1be4 <__divsf3_pse+0x70>
    1bd6:	9e 3f       	cpi	r25, 0xFE	; 254
    1bd8:	51 05       	cpc	r21, r1
    1bda:	78 f0       	brcs	.+30     	; 0x1bfa <__divsf3_pse+0x86>
    1bdc:	0c 94 52 0e 	jmp	0x1ca4	; 0x1ca4 <__fp_inf>
    1be0:	0c 94 9d 0e 	jmp	0x1d3a	; 0x1d3a <__fp_szero>
    1be4:	5f 3f       	cpi	r21, 0xFF	; 255
    1be6:	e4 f3       	brlt	.-8      	; 0x1be0 <__divsf3_pse+0x6c>
    1be8:	98 3e       	cpi	r25, 0xE8	; 232
    1bea:	d4 f3       	brlt	.-12     	; 0x1be0 <__divsf3_pse+0x6c>
    1bec:	86 95       	lsr	r24
    1bee:	77 95       	ror	r23
    1bf0:	67 95       	ror	r22
    1bf2:	b7 95       	ror	r27
    1bf4:	f7 95       	ror	r31
    1bf6:	9f 5f       	subi	r25, 0xFF	; 255
    1bf8:	c9 f7       	brne	.-14     	; 0x1bec <__divsf3_pse+0x78>
    1bfa:	88 0f       	add	r24, r24
    1bfc:	91 1d       	adc	r25, r1
    1bfe:	96 95       	lsr	r25
    1c00:	87 95       	ror	r24
    1c02:	97 f9       	bld	r25, 7
    1c04:	08 95       	ret
    1c06:	e1 e0       	ldi	r30, 0x01	; 1
    1c08:	66 0f       	add	r22, r22
    1c0a:	77 1f       	adc	r23, r23
    1c0c:	88 1f       	adc	r24, r24
    1c0e:	bb 1f       	adc	r27, r27
    1c10:	62 17       	cp	r22, r18
    1c12:	73 07       	cpc	r23, r19
    1c14:	84 07       	cpc	r24, r20
    1c16:	ba 07       	cpc	r27, r26
    1c18:	20 f0       	brcs	.+8      	; 0x1c22 <__divsf3_pse+0xae>
    1c1a:	62 1b       	sub	r22, r18
    1c1c:	73 0b       	sbc	r23, r19
    1c1e:	84 0b       	sbc	r24, r20
    1c20:	ba 0b       	sbc	r27, r26
    1c22:	ee 1f       	adc	r30, r30
    1c24:	88 f7       	brcc	.-30     	; 0x1c08 <__divsf3_pse+0x94>
    1c26:	e0 95       	com	r30
    1c28:	08 95       	ret

00001c2a <__floatunsisf>:
    1c2a:	e8 94       	clt
    1c2c:	09 c0       	rjmp	.+18     	; 0x1c40 <__floatsisf+0x12>

00001c2e <__floatsisf>:
    1c2e:	97 fb       	bst	r25, 7
    1c30:	3e f4       	brtc	.+14     	; 0x1c40 <__floatsisf+0x12>
    1c32:	90 95       	com	r25
    1c34:	80 95       	com	r24
    1c36:	70 95       	com	r23
    1c38:	61 95       	neg	r22
    1c3a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3c:	8f 4f       	sbci	r24, 0xFF	; 255
    1c3e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c40:	99 23       	and	r25, r25
    1c42:	a9 f0       	breq	.+42     	; 0x1c6e <__floatsisf+0x40>
    1c44:	f9 2f       	mov	r31, r25
    1c46:	96 e9       	ldi	r25, 0x96	; 150
    1c48:	bb 27       	eor	r27, r27
    1c4a:	93 95       	inc	r25
    1c4c:	f6 95       	lsr	r31
    1c4e:	87 95       	ror	r24
    1c50:	77 95       	ror	r23
    1c52:	67 95       	ror	r22
    1c54:	b7 95       	ror	r27
    1c56:	f1 11       	cpse	r31, r1
    1c58:	f8 cf       	rjmp	.-16     	; 0x1c4a <__floatsisf+0x1c>
    1c5a:	fa f4       	brpl	.+62     	; 0x1c9a <__floatsisf+0x6c>
    1c5c:	bb 0f       	add	r27, r27
    1c5e:	11 f4       	brne	.+4      	; 0x1c64 <__floatsisf+0x36>
    1c60:	60 ff       	sbrs	r22, 0
    1c62:	1b c0       	rjmp	.+54     	; 0x1c9a <__floatsisf+0x6c>
    1c64:	6f 5f       	subi	r22, 0xFF	; 255
    1c66:	7f 4f       	sbci	r23, 0xFF	; 255
    1c68:	8f 4f       	sbci	r24, 0xFF	; 255
    1c6a:	9f 4f       	sbci	r25, 0xFF	; 255
    1c6c:	16 c0       	rjmp	.+44     	; 0x1c9a <__floatsisf+0x6c>
    1c6e:	88 23       	and	r24, r24
    1c70:	11 f0       	breq	.+4      	; 0x1c76 <__floatsisf+0x48>
    1c72:	96 e9       	ldi	r25, 0x96	; 150
    1c74:	11 c0       	rjmp	.+34     	; 0x1c98 <__floatsisf+0x6a>
    1c76:	77 23       	and	r23, r23
    1c78:	21 f0       	breq	.+8      	; 0x1c82 <__floatsisf+0x54>
    1c7a:	9e e8       	ldi	r25, 0x8E	; 142
    1c7c:	87 2f       	mov	r24, r23
    1c7e:	76 2f       	mov	r23, r22
    1c80:	05 c0       	rjmp	.+10     	; 0x1c8c <__floatsisf+0x5e>
    1c82:	66 23       	and	r22, r22
    1c84:	71 f0       	breq	.+28     	; 0x1ca2 <__floatsisf+0x74>
    1c86:	96 e8       	ldi	r25, 0x86	; 134
    1c88:	86 2f       	mov	r24, r22
    1c8a:	70 e0       	ldi	r23, 0x00	; 0
    1c8c:	60 e0       	ldi	r22, 0x00	; 0
    1c8e:	2a f0       	brmi	.+10     	; 0x1c9a <__floatsisf+0x6c>
    1c90:	9a 95       	dec	r25
    1c92:	66 0f       	add	r22, r22
    1c94:	77 1f       	adc	r23, r23
    1c96:	88 1f       	adc	r24, r24
    1c98:	da f7       	brpl	.-10     	; 0x1c90 <__floatsisf+0x62>
    1c9a:	88 0f       	add	r24, r24
    1c9c:	96 95       	lsr	r25
    1c9e:	87 95       	ror	r24
    1ca0:	97 f9       	bld	r25, 7
    1ca2:	08 95       	ret

00001ca4 <__fp_inf>:
    1ca4:	97 f9       	bld	r25, 7
    1ca6:	9f 67       	ori	r25, 0x7F	; 127
    1ca8:	80 e8       	ldi	r24, 0x80	; 128
    1caa:	70 e0       	ldi	r23, 0x00	; 0
    1cac:	60 e0       	ldi	r22, 0x00	; 0
    1cae:	08 95       	ret

00001cb0 <__fp_nan>:
    1cb0:	9f ef       	ldi	r25, 0xFF	; 255
    1cb2:	80 ec       	ldi	r24, 0xC0	; 192
    1cb4:	08 95       	ret

00001cb6 <__fp_pscA>:
    1cb6:	00 24       	eor	r0, r0
    1cb8:	0a 94       	dec	r0
    1cba:	16 16       	cp	r1, r22
    1cbc:	17 06       	cpc	r1, r23
    1cbe:	18 06       	cpc	r1, r24
    1cc0:	09 06       	cpc	r0, r25
    1cc2:	08 95       	ret

00001cc4 <__fp_pscB>:
    1cc4:	00 24       	eor	r0, r0
    1cc6:	0a 94       	dec	r0
    1cc8:	12 16       	cp	r1, r18
    1cca:	13 06       	cpc	r1, r19
    1ccc:	14 06       	cpc	r1, r20
    1cce:	05 06       	cpc	r0, r21
    1cd0:	08 95       	ret

00001cd2 <__fp_round>:
    1cd2:	09 2e       	mov	r0, r25
    1cd4:	03 94       	inc	r0
    1cd6:	00 0c       	add	r0, r0
    1cd8:	11 f4       	brne	.+4      	; 0x1cde <__fp_round+0xc>
    1cda:	88 23       	and	r24, r24
    1cdc:	52 f0       	brmi	.+20     	; 0x1cf2 <__fp_round+0x20>
    1cde:	bb 0f       	add	r27, r27
    1ce0:	40 f4       	brcc	.+16     	; 0x1cf2 <__fp_round+0x20>
    1ce2:	bf 2b       	or	r27, r31
    1ce4:	11 f4       	brne	.+4      	; 0x1cea <__fp_round+0x18>
    1ce6:	60 ff       	sbrs	r22, 0
    1ce8:	04 c0       	rjmp	.+8      	; 0x1cf2 <__fp_round+0x20>
    1cea:	6f 5f       	subi	r22, 0xFF	; 255
    1cec:	7f 4f       	sbci	r23, 0xFF	; 255
    1cee:	8f 4f       	sbci	r24, 0xFF	; 255
    1cf0:	9f 4f       	sbci	r25, 0xFF	; 255
    1cf2:	08 95       	ret

00001cf4 <__fp_split3>:
    1cf4:	57 fd       	sbrc	r21, 7
    1cf6:	90 58       	subi	r25, 0x80	; 128
    1cf8:	44 0f       	add	r20, r20
    1cfa:	55 1f       	adc	r21, r21
    1cfc:	59 f0       	breq	.+22     	; 0x1d14 <__fp_splitA+0x10>
    1cfe:	5f 3f       	cpi	r21, 0xFF	; 255
    1d00:	71 f0       	breq	.+28     	; 0x1d1e <__fp_splitA+0x1a>
    1d02:	47 95       	ror	r20

00001d04 <__fp_splitA>:
    1d04:	88 0f       	add	r24, r24
    1d06:	97 fb       	bst	r25, 7
    1d08:	99 1f       	adc	r25, r25
    1d0a:	61 f0       	breq	.+24     	; 0x1d24 <__fp_splitA+0x20>
    1d0c:	9f 3f       	cpi	r25, 0xFF	; 255
    1d0e:	79 f0       	breq	.+30     	; 0x1d2e <__fp_splitA+0x2a>
    1d10:	87 95       	ror	r24
    1d12:	08 95       	ret
    1d14:	12 16       	cp	r1, r18
    1d16:	13 06       	cpc	r1, r19
    1d18:	14 06       	cpc	r1, r20
    1d1a:	55 1f       	adc	r21, r21
    1d1c:	f2 cf       	rjmp	.-28     	; 0x1d02 <__fp_split3+0xe>
    1d1e:	46 95       	lsr	r20
    1d20:	f1 df       	rcall	.-30     	; 0x1d04 <__fp_splitA>
    1d22:	08 c0       	rjmp	.+16     	; 0x1d34 <__fp_splitA+0x30>
    1d24:	16 16       	cp	r1, r22
    1d26:	17 06       	cpc	r1, r23
    1d28:	18 06       	cpc	r1, r24
    1d2a:	99 1f       	adc	r25, r25
    1d2c:	f1 cf       	rjmp	.-30     	; 0x1d10 <__fp_splitA+0xc>
    1d2e:	86 95       	lsr	r24
    1d30:	71 05       	cpc	r23, r1
    1d32:	61 05       	cpc	r22, r1
    1d34:	08 94       	sec
    1d36:	08 95       	ret

00001d38 <__fp_zero>:
    1d38:	e8 94       	clt

00001d3a <__fp_szero>:
    1d3a:	bb 27       	eor	r27, r27
    1d3c:	66 27       	eor	r22, r22
    1d3e:	77 27       	eor	r23, r23
    1d40:	cb 01       	movw	r24, r22
    1d42:	97 f9       	bld	r25, 7
    1d44:	08 95       	ret

00001d46 <__mulsf3>:
    1d46:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <__mulsf3x>
    1d4a:	0c 94 69 0e 	jmp	0x1cd2	; 0x1cd2 <__fp_round>
    1d4e:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <__fp_pscA>
    1d52:	38 f0       	brcs	.+14     	; 0x1d62 <__mulsf3+0x1c>
    1d54:	0e 94 62 0e 	call	0x1cc4	; 0x1cc4 <__fp_pscB>
    1d58:	20 f0       	brcs	.+8      	; 0x1d62 <__mulsf3+0x1c>
    1d5a:	95 23       	and	r25, r21
    1d5c:	11 f0       	breq	.+4      	; 0x1d62 <__mulsf3+0x1c>
    1d5e:	0c 94 52 0e 	jmp	0x1ca4	; 0x1ca4 <__fp_inf>
    1d62:	0c 94 58 0e 	jmp	0x1cb0	; 0x1cb0 <__fp_nan>
    1d66:	11 24       	eor	r1, r1
    1d68:	0c 94 9d 0e 	jmp	0x1d3a	; 0x1d3a <__fp_szero>

00001d6c <__mulsf3x>:
    1d6c:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <__fp_split3>
    1d70:	70 f3       	brcs	.-36     	; 0x1d4e <__mulsf3+0x8>

00001d72 <__mulsf3_pse>:
    1d72:	95 9f       	mul	r25, r21
    1d74:	c1 f3       	breq	.-16     	; 0x1d66 <__mulsf3+0x20>
    1d76:	95 0f       	add	r25, r21
    1d78:	50 e0       	ldi	r21, 0x00	; 0
    1d7a:	55 1f       	adc	r21, r21
    1d7c:	62 9f       	mul	r22, r18
    1d7e:	f0 01       	movw	r30, r0
    1d80:	72 9f       	mul	r23, r18
    1d82:	bb 27       	eor	r27, r27
    1d84:	f0 0d       	add	r31, r0
    1d86:	b1 1d       	adc	r27, r1
    1d88:	63 9f       	mul	r22, r19
    1d8a:	aa 27       	eor	r26, r26
    1d8c:	f0 0d       	add	r31, r0
    1d8e:	b1 1d       	adc	r27, r1
    1d90:	aa 1f       	adc	r26, r26
    1d92:	64 9f       	mul	r22, r20
    1d94:	66 27       	eor	r22, r22
    1d96:	b0 0d       	add	r27, r0
    1d98:	a1 1d       	adc	r26, r1
    1d9a:	66 1f       	adc	r22, r22
    1d9c:	82 9f       	mul	r24, r18
    1d9e:	22 27       	eor	r18, r18
    1da0:	b0 0d       	add	r27, r0
    1da2:	a1 1d       	adc	r26, r1
    1da4:	62 1f       	adc	r22, r18
    1da6:	73 9f       	mul	r23, r19
    1da8:	b0 0d       	add	r27, r0
    1daa:	a1 1d       	adc	r26, r1
    1dac:	62 1f       	adc	r22, r18
    1dae:	83 9f       	mul	r24, r19
    1db0:	a0 0d       	add	r26, r0
    1db2:	61 1d       	adc	r22, r1
    1db4:	22 1f       	adc	r18, r18
    1db6:	74 9f       	mul	r23, r20
    1db8:	33 27       	eor	r19, r19
    1dba:	a0 0d       	add	r26, r0
    1dbc:	61 1d       	adc	r22, r1
    1dbe:	23 1f       	adc	r18, r19
    1dc0:	84 9f       	mul	r24, r20
    1dc2:	60 0d       	add	r22, r0
    1dc4:	21 1d       	adc	r18, r1
    1dc6:	82 2f       	mov	r24, r18
    1dc8:	76 2f       	mov	r23, r22
    1dca:	6a 2f       	mov	r22, r26
    1dcc:	11 24       	eor	r1, r1
    1dce:	9f 57       	subi	r25, 0x7F	; 127
    1dd0:	50 40       	sbci	r21, 0x00	; 0
    1dd2:	9a f0       	brmi	.+38     	; 0x1dfa <__mulsf3_pse+0x88>
    1dd4:	f1 f0       	breq	.+60     	; 0x1e12 <__mulsf3_pse+0xa0>
    1dd6:	88 23       	and	r24, r24
    1dd8:	4a f0       	brmi	.+18     	; 0x1dec <__mulsf3_pse+0x7a>
    1dda:	ee 0f       	add	r30, r30
    1ddc:	ff 1f       	adc	r31, r31
    1dde:	bb 1f       	adc	r27, r27
    1de0:	66 1f       	adc	r22, r22
    1de2:	77 1f       	adc	r23, r23
    1de4:	88 1f       	adc	r24, r24
    1de6:	91 50       	subi	r25, 0x01	; 1
    1de8:	50 40       	sbci	r21, 0x00	; 0
    1dea:	a9 f7       	brne	.-22     	; 0x1dd6 <__mulsf3_pse+0x64>
    1dec:	9e 3f       	cpi	r25, 0xFE	; 254
    1dee:	51 05       	cpc	r21, r1
    1df0:	80 f0       	brcs	.+32     	; 0x1e12 <__mulsf3_pse+0xa0>
    1df2:	0c 94 52 0e 	jmp	0x1ca4	; 0x1ca4 <__fp_inf>
    1df6:	0c 94 9d 0e 	jmp	0x1d3a	; 0x1d3a <__fp_szero>
    1dfa:	5f 3f       	cpi	r21, 0xFF	; 255
    1dfc:	e4 f3       	brlt	.-8      	; 0x1df6 <__mulsf3_pse+0x84>
    1dfe:	98 3e       	cpi	r25, 0xE8	; 232
    1e00:	d4 f3       	brlt	.-12     	; 0x1df6 <__mulsf3_pse+0x84>
    1e02:	86 95       	lsr	r24
    1e04:	77 95       	ror	r23
    1e06:	67 95       	ror	r22
    1e08:	b7 95       	ror	r27
    1e0a:	f7 95       	ror	r31
    1e0c:	e7 95       	ror	r30
    1e0e:	9f 5f       	subi	r25, 0xFF	; 255
    1e10:	c1 f7       	brne	.-16     	; 0x1e02 <__mulsf3_pse+0x90>
    1e12:	fe 2b       	or	r31, r30
    1e14:	88 0f       	add	r24, r24
    1e16:	91 1d       	adc	r25, r1
    1e18:	96 95       	lsr	r25
    1e1a:	87 95       	ror	r24
    1e1c:	97 f9       	bld	r25, 7
    1e1e:	08 95       	ret

00001e20 <memcpy>:
    1e20:	fb 01       	movw	r30, r22
    1e22:	dc 01       	movw	r26, r24
    1e24:	02 c0       	rjmp	.+4      	; 0x1e2a <memcpy+0xa>
    1e26:	01 90       	ld	r0, Z+
    1e28:	0d 92       	st	X+, r0
    1e2a:	41 50       	subi	r20, 0x01	; 1
    1e2c:	50 40       	sbci	r21, 0x00	; 0
    1e2e:	d8 f7       	brcc	.-10     	; 0x1e26 <memcpy+0x6>
    1e30:	08 95       	ret

00001e32 <_exit>:
    1e32:	f8 94       	cli

00001e34 <__stop_program>:
    1e34:	ff cf       	rjmp	.-2      	; 0x1e34 <__stop_program>
