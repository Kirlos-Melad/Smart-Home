
ArduinoUnoFreertos_6_1(2).elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000aa  00800100  00001dea  00001e7e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001dea  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000644  008001aa  008001aa  00001f28  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001f28  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001f58  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003c8  00000000  00000000  00001f98  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004cc0  00000000  00000000  00002360  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001308  00000000  00000000  00007020  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002a5e  00000000  00000000  00008328  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bb0  00000000  00000000  0000ad88  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000016dd  00000000  00000000  0000b938  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000048dc  00000000  00000000  0000d015  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003d8  00000000  00000000  000118f1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 23 0d 	jmp	0x1a46	; 0x1a46 <__vector_1>
       8:	0c 94 50 0d 	jmp	0x1aa0	; 0x1aa0 <__vector_2>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 5f 04 	jmp	0x8be	; 0x8be <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ea ee       	ldi	r30, 0xEA	; 234
      7c:	fd e1       	ldi	r31, 0x1D	; 29
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	aa 3a       	cpi	r26, 0xAA	; 170
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	aa ea       	ldi	r26, 0xAA	; 170
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ae 3e       	cpi	r26, 0xEE	; 238
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <main>
      9e:	0c 94 f3 0e 	jmp	0x1de6	; 0x1de6 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <Interrupt_Handler>:
	return ADC;
}

void Interrupt_Handler(){
	// disable buzzer
	PORTB &= ~(1 << buzzerPinB);
      a6:	2d 98       	cbi	0x05, 5	; 5
      a8:	08 95       	ret

000000aa <Readings_Handler>:
}

void Readings_Handler(void *pvParameters ){
      aa:	cf 93       	push	r28
      ac:	df 93       	push	r29
      ae:	cd b7       	in	r28, 0x3d	; 61
      b0:	de b7       	in	r29, 0x3e	; 62
      b2:	64 97       	sbiw	r28, 0x14	; 20
      b4:	0f b6       	in	r0, 0x3f	; 63
      b6:	f8 94       	cli
      b8:	de bf       	out	0x3e, r29	; 62
      ba:	0f be       	out	0x3f, r0	; 63
      bc:	cd bf       	out	0x3d, r28	; 61
      be:	1c 01       	movw	r2, r24
	QueueHandle_t* xQueue = (QueueHandle_t *)pvParameters;
	int const numberOfQs = 3;
	
	int Data[]={0,0,0};
      c0:	1a 82       	std	Y+2, r1	; 0x02
      c2:	19 82       	std	Y+1, r1	; 0x01
      c4:	1c 82       	std	Y+4, r1	; 0x04
      c6:	1b 82       	std	Y+3, r1	; 0x03
      c8:	1e 82       	std	Y+6, r1	; 0x06
      ca:	1d 82       	std	Y+5, r1	; 0x05
	BaseType_t Status[]={0,0,0};
	int Critical[] = {SMOKE_CRITICAL, TEMP_CRITICAL, WATER_LEVEL_CRITICAL};
      cc:	86 e0       	ldi	r24, 0x06	; 6
      ce:	e4 e0       	ldi	r30, 0x04	; 4
      d0:	f1 e0       	ldi	r31, 0x01	; 1
      d2:	de 01       	movw	r26, r28
      d4:	17 96       	adiw	r26, 0x07	; 7
      d6:	01 90       	ld	r0, Z+
      d8:	0d 92       	st	X+, r0
      da:	8a 95       	dec	r24
      dc:	e1 f7       	brne	.-8      	; 0xd6 <Readings_Handler+0x2c>
	char* sensorName[] = {"Smoke: ", "Temperature: ", "Water Level: "};
      de:	86 e0       	ldi	r24, 0x06	; 6
      e0:	ea e0       	ldi	r30, 0x0A	; 10
      e2:	f1 e0       	ldi	r31, 0x01	; 1
      e4:	de 01       	movw	r26, r28
      e6:	1d 96       	adiw	r26, 0x0d	; 13
      e8:	01 90       	ld	r0, Z+
      ea:	0d 92       	st	X+, r0
      ec:	8a 95       	dec	r24
      ee:	e1 f7       	brne	.-8      	; 0xe8 <Readings_Handler+0x3e>
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
      f0:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <xTaskGetTickCount>
      f4:	9c 8b       	std	Y+20, r25	; 0x14
      f6:	8b 8b       	std	Y+19, r24	; 0x13
      f8:	41 01       	movw	r8, r2
      fa:	26 e0       	ldi	r18, 0x06	; 6
      fc:	82 0e       	add	r8, r18
      fe:	91 1c       	adc	r9, r1
     100:	71 01       	movw	r14, r2
     102:	8e 01       	movw	r16, r28
     104:	0f 5f       	subi	r16, 0xFF	; 255
     106:	1f 4f       	sbci	r17, 0xFF	; 255
     108:	5e 01       	movw	r10, r28
     10a:	37 e0       	ldi	r19, 0x07	; 7
     10c:	a3 0e       	add	r10, r19
     10e:	b1 1c       	adc	r11, r1
     110:	6e 01       	movw	r12, r28
     112:	8d e0       	ldi	r24, 0x0D	; 13
     114:	c8 0e       	add	r12, r24
     116:	d1 1c       	adc	r13, r1
	while(1)
	{
		for(int i = 0; i < numberOfQs; i++){
			Status[i] = xQueueReceive(xQueue[i], Data + i, 0);
     118:	20 e0       	ldi	r18, 0x00	; 0
     11a:	40 e0       	ldi	r20, 0x00	; 0
     11c:	50 e0       	ldi	r21, 0x00	; 0
     11e:	b8 01       	movw	r22, r16
     120:	f7 01       	movw	r30, r14
     122:	81 91       	ld	r24, Z+
     124:	91 91       	ld	r25, Z+
     126:	7f 01       	movw	r14, r30
     128:	0e 94 ff 06 	call	0xdfe	; 0xdfe <xQueueGenericReceive>
			
			if(Status[i] == pdPASS){
     12c:	81 30       	cpi	r24, 0x01	; 1
     12e:	99 f5       	brne	.+102    	; 0x196 <Readings_Handler+0xec>
				Clear_LCD();
     130:	0e 94 21 02 	call	0x442	; 0x442 <Clear_LCD>
				byte isCritical = (Data[i] > Critical[i]);
     134:	f8 01       	movw	r30, r16
     136:	60 80       	ld	r6, Z
     138:	71 80       	ldd	r7, Z+1	; 0x01
     13a:	f5 01       	movw	r30, r10
     13c:	40 80       	ld	r4, Z
     13e:	51 80       	ldd	r5, Z+1	; 0x01
				PORTB |= (isCritical << buzzerPinB);
     140:	25 b1       	in	r18, 0x05	; 5
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	90 e0       	ldi	r25, 0x00	; 0
     146:	46 14       	cp	r4, r6
     148:	57 04       	cpc	r5, r7
     14a:	14 f0       	brlt	.+4      	; 0x150 <Readings_Handler+0xa6>
     14c:	80 e0       	ldi	r24, 0x00	; 0
     14e:	90 e0       	ldi	r25, 0x00	; 0
     150:	88 0f       	add	r24, r24
     152:	99 1f       	adc	r25, r25
     154:	82 95       	swap	r24
     156:	92 95       	swap	r25
     158:	90 7f       	andi	r25, 0xF0	; 240
     15a:	98 27       	eor	r25, r24
     15c:	80 7f       	andi	r24, 0xF0	; 240
     15e:	98 27       	eor	r25, r24
     160:	82 2b       	or	r24, r18
     162:	85 b9       	out	0x05, r24	; 5
				WriteDataString(sensorName[i]) ;
     164:	f6 01       	movw	r30, r12
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
     16a:	0e 94 58 02 	call	0x4b0	; 0x4b0 <WriteDataString>
				WriteDataString(isCritical ? "Critical" : "Normal");
     16e:	46 14       	cp	r4, r6
     170:	57 04       	cpc	r5, r7
     172:	2c f0       	brlt	.+10     	; 0x17e <Readings_Handler+0xd4>
     174:	29 e1       	ldi	r18, 0x19	; 25
     176:	31 e0       	ldi	r19, 0x01	; 1
     178:	82 2f       	mov	r24, r18
     17a:	93 2f       	mov	r25, r19
     17c:	04 c0       	rjmp	.+8      	; 0x186 <Readings_Handler+0xdc>
     17e:	e0 e1       	ldi	r30, 0x10	; 16
     180:	f1 e0       	ldi	r31, 0x01	; 1
     182:	8e 2f       	mov	r24, r30
     184:	9f 2f       	mov	r25, r31
     186:	0e 94 58 02 	call	0x4b0	; 0x4b0 <WriteDataString>
				vTaskDelayUntil(&xLastWakeTime, (1500 / portTICK_PERIOD_MS));
     18a:	6c ed       	ldi	r22, 0xDC	; 220
     18c:	75 e0       	ldi	r23, 0x05	; 5
     18e:	ce 01       	movw	r24, r28
     190:	43 96       	adiw	r24, 0x13	; 19
     192:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vTaskDelayUntil>
     196:	0e 5f       	subi	r16, 0xFE	; 254
     198:	1f 4f       	sbci	r17, 0xFF	; 255
     19a:	f2 e0       	ldi	r31, 0x02	; 2
     19c:	af 0e       	add	r10, r31
     19e:	b1 1c       	adc	r11, r1
     1a0:	22 e0       	ldi	r18, 0x02	; 2
     1a2:	c2 0e       	add	r12, r18
     1a4:	d1 1c       	adc	r13, r1
	char* sensorName[] = {"Smoke: ", "Temperature: ", "Water Level: "};
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
	while(1)
	{
		for(int i = 0; i < numberOfQs; i++){
     1a6:	e8 14       	cp	r14, r8
     1a8:	f9 04       	cpc	r15, r9
     1aa:	09 f0       	breq	.+2      	; 0x1ae <Readings_Handler+0x104>
     1ac:	b5 cf       	rjmp	.-150    	; 0x118 <Readings_Handler+0x6e>
     1ae:	a8 cf       	rjmp	.-176    	; 0x100 <Readings_Handler+0x56>

000001b0 <Setup>:
}

void Setup()
{
	// Setup LCD
	LCD_Init();
     1b0:	0e 94 67 02 	call	0x4ce	; 0x4ce <LCD_Init>
	
	// Set ADC
	ADMUX |= (1 << REFS0);
     1b4:	ec e7       	ldi	r30, 0x7C	; 124
     1b6:	f0 e0       	ldi	r31, 0x00	; 0
     1b8:	80 81       	ld	r24, Z
     1ba:	80 64       	ori	r24, 0x40	; 64
     1bc:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) | (1 << ADEN);
     1be:	ea e7       	ldi	r30, 0x7A	; 122
     1c0:	f0 e0       	ldi	r31, 0x00	; 0
     1c2:	80 81       	ld	r24, Z
     1c4:	87 68       	ori	r24, 0x87	; 135
     1c6:	80 83       	st	Z, r24

	// Sensors modes
	DDRB = (1 << buzzerPinB);
     1c8:	80 e2       	ldi	r24, 0x20	; 32
     1ca:	84 b9       	out	0x04, r24	; 4
	PORTB = 0;
     1cc:	15 b8       	out	0x05, r1	; 5
	DDRD = (1 << buttonPinD);
     1ce:	84 e0       	ldi	r24, 0x04	; 4
     1d0:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0;
     1d2:	1b b8       	out	0x0b, r1	; 11
	DDRC = 0;
     1d4:	17 b8       	out	0x07, r1	; 7
     1d6:	08 95       	ret

000001d8 <main>:
#define TEMP_CRITICAL 50
#define SMOKE_CRITICAL 200
#define WATER_LEVEL_CRITICAL 200

int main(void)
{
     1d8:	cf 93       	push	r28
     1da:	df 93       	push	r29
     1dc:	00 d0       	rcall	.+0      	; 0x1de <main+0x6>
     1de:	00 d0       	rcall	.+0      	; 0x1e0 <main+0x8>
     1e0:	00 d0       	rcall	.+0      	; 0x1e2 <main+0xa>
     1e2:	cd b7       	in	r28, 0x3d	; 61
     1e4:	de b7       	in	r29, 0x3e	; 62
	Setup();
     1e6:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <Setup>
	cli();
     1ea:	f8 94       	cli
	attachInterrupt(0, Interrupt_Handler, 1);
     1ec:	41 e0       	ldi	r20, 0x01	; 1
     1ee:	50 e0       	ldi	r21, 0x00	; 0
     1f0:	63 e5       	ldi	r22, 0x53	; 83
     1f2:	70 e0       	ldi	r23, 0x00	; 0
     1f4:	80 e0       	ldi	r24, 0x00	; 0
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <attachInterrupt>
	
	QueueHandle_t xQueue[3] = {0};
     1fc:	fe 01       	movw	r30, r28
     1fe:	31 96       	adiw	r30, 0x01	; 1
     200:	86 e0       	ldi	r24, 0x06	; 6
     202:	df 01       	movw	r26, r30
     204:	1d 92       	st	X+, r1
     206:	8a 95       	dec	r24
     208:	e9 f7       	brne	.-6      	; 0x204 <main+0x2c>
     20a:	8f 01       	movw	r16, r30
     20c:	7e 01       	movw	r14, r28
     20e:	b7 e0       	ldi	r27, 0x07	; 7
     210:	eb 0e       	add	r14, r27
     212:	f1 1c       	adc	r15, r1
	for(int i = 0; i < 3; i++)
	xQueue[i] = xQueueCreate( 3, sizeof( void * ) );
     214:	40 e0       	ldi	r20, 0x00	; 0
     216:	62 e0       	ldi	r22, 0x02	; 2
     218:	83 e0       	ldi	r24, 0x03	; 3
     21a:	0e 94 32 06 	call	0xc64	; 0xc64 <xQueueGenericCreate>
     21e:	f8 01       	movw	r30, r16
     220:	81 93       	st	Z+, r24
     222:	91 93       	st	Z+, r25
     224:	8f 01       	movw	r16, r30
	Setup();
	cli();
	attachInterrupt(0, Interrupt_Handler, 1);
	
	QueueHandle_t xQueue[3] = {0};
	for(int i = 0; i < 3; i++)
     226:	ee 15       	cp	r30, r14
     228:	ff 05       	cpc	r31, r15
     22a:	a1 f7       	brne	.-24     	; 0x214 <main+0x3c>
	xQueue[i] = xQueueCreate( 3, sizeof( void * ) );
	
	byte isReady = 1;
	for(int i = 0; i < 3; i++)
	isReady &= (xQueue[i] != NULL);
     22c:	91 e0       	ldi	r25, 0x01	; 1
     22e:	29 81       	ldd	r18, Y+1	; 0x01
     230:	3a 81       	ldd	r19, Y+2	; 0x02
     232:	23 2b       	or	r18, r19
     234:	09 f4       	brne	.+2      	; 0x238 <main+0x60>
     236:	90 e0       	ldi	r25, 0x00	; 0
     238:	81 e0       	ldi	r24, 0x01	; 1
     23a:	2b 81       	ldd	r18, Y+3	; 0x03
     23c:	3c 81       	ldd	r19, Y+4	; 0x04
     23e:	23 2b       	or	r18, r19
     240:	09 f4       	brne	.+2      	; 0x244 <main+0x6c>
     242:	80 e0       	ldi	r24, 0x00	; 0
     244:	89 23       	and	r24, r25
     246:	91 e0       	ldi	r25, 0x01	; 1
     248:	2d 81       	ldd	r18, Y+5	; 0x05
     24a:	3e 81       	ldd	r19, Y+6	; 0x06
     24c:	23 2b       	or	r18, r19
     24e:	09 f4       	brne	.+2      	; 0x252 <main+0x7a>
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	89 23       	and	r24, r25
	if( isReady)
     254:	b9 f1       	breq	.+110    	; 0x2c4 <main+0xec>
	{
		xTaskCreate(Smoke_Sensor_Handler,(const char*)"Smoke Sensor Handler", 256, xQueue, 4, NULL);
     256:	a1 2c       	mov	r10, r1
     258:	b1 2c       	mov	r11, r1
     25a:	c1 2c       	mov	r12, r1
     25c:	d1 2c       	mov	r13, r1
     25e:	e1 2c       	mov	r14, r1
     260:	f1 2c       	mov	r15, r1
     262:	04 e0       	ldi	r16, 0x04	; 4
     264:	9e 01       	movw	r18, r28
     266:	2f 5f       	subi	r18, 0xFF	; 255
     268:	3f 4f       	sbci	r19, 0xFF	; 255
     26a:	40 e0       	ldi	r20, 0x00	; 0
     26c:	51 e0       	ldi	r21, 0x01	; 1
     26e:	64 e4       	ldi	r22, 0x44	; 68
     270:	71 e0       	ldi	r23, 0x01	; 1
     272:	85 e7       	ldi	r24, 0x75	; 117
     274:	91 e0       	ldi	r25, 0x01	; 1
     276:	0e 94 18 08 	call	0x1030	; 0x1030 <xTaskGenericCreate>
		xTaskCreate(Temp_Sensor_Handler,(const char*)"Temp Sensor Handler", 256, xQueue + 1, 4, NULL);
     27a:	9e 01       	movw	r18, r28
     27c:	2d 5f       	subi	r18, 0xFD	; 253
     27e:	3f 4f       	sbci	r19, 0xFF	; 255
     280:	40 e0       	ldi	r20, 0x00	; 0
     282:	51 e0       	ldi	r21, 0x01	; 1
     284:	69 e5       	ldi	r22, 0x59	; 89
     286:	71 e0       	ldi	r23, 0x01	; 1
     288:	87 e9       	ldi	r24, 0x97	; 151
     28a:	91 e0       	ldi	r25, 0x01	; 1
     28c:	0e 94 18 08 	call	0x1030	; 0x1030 <xTaskGenericCreate>
		xTaskCreate(Water_Depth_Sensor_Handler,(const char*)"Water Depth Sensor Handler", 240, xQueue + 2, 4, NULL);
     290:	9e 01       	movw	r18, r28
     292:	2b 5f       	subi	r18, 0xFB	; 251
     294:	3f 4f       	sbci	r19, 0xFF	; 255
     296:	40 ef       	ldi	r20, 0xF0	; 240
     298:	50 e0       	ldi	r21, 0x00	; 0
     29a:	6d e6       	ldi	r22, 0x6D	; 109
     29c:	71 e0       	ldi	r23, 0x01	; 1
     29e:	8e ec       	ldi	r24, 0xCE	; 206
     2a0:	91 e0       	ldi	r25, 0x01	; 1
     2a2:	0e 94 18 08 	call	0x1030	; 0x1030 <xTaskGenericCreate>
		xTaskCreate(Readings_Handler,(const char*)"Readings Handler", 256 , xQueue, 3, NULL);
     2a6:	03 e0       	ldi	r16, 0x03	; 3
     2a8:	9e 01       	movw	r18, r28
     2aa:	2f 5f       	subi	r18, 0xFF	; 255
     2ac:	3f 4f       	sbci	r19, 0xFF	; 255
     2ae:	40 e0       	ldi	r20, 0x00	; 0
     2b0:	51 e0       	ldi	r21, 0x01	; 1
     2b2:	68 e8       	ldi	r22, 0x88	; 136
     2b4:	71 e0       	ldi	r23, 0x01	; 1
     2b6:	85 e5       	ldi	r24, 0x55	; 85
     2b8:	90 e0       	ldi	r25, 0x00	; 0
     2ba:	0e 94 18 08 	call	0x1030	; 0x1030 <xTaskGenericCreate>

		sei();
     2be:	78 94       	sei

		vTaskStartScheduler();
     2c0:	0e 94 26 09 	call	0x124c	; 0x124c <vTaskStartScheduler>
     2c4:	ff cf       	rjmp	.-2      	; 0x2c4 <main+0xec>

000002c6 <Analog_Read>:
	PORTD = 0;
	DDRC = 0;
}

int Analog_Read(uint8_t pin){
	ADMUX |= pin;
     2c6:	ec e7       	ldi	r30, 0x7C	; 124
     2c8:	f0 e0       	ldi	r31, 0x00	; 0
     2ca:	90 81       	ld	r25, Z
     2cc:	89 2b       	or	r24, r25
     2ce:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADSC);
     2d0:	ea e7       	ldi	r30, 0x7A	; 122
     2d2:	f0 e0       	ldi	r31, 0x00	; 0
     2d4:	80 81       	ld	r24, Z
     2d6:	80 64       	ori	r24, 0x40	; 64
     2d8:	80 83       	st	Z, r24
	
	while(ADCSRA & (1 << ADSC));
     2da:	80 81       	ld	r24, Z
     2dc:	86 fd       	sbrc	r24, 6
     2de:	fd cf       	rjmp	.-6      	; 0x2da <Analog_Read+0x14>
	
	return ADC;
     2e0:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     2e4:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
}
     2e8:	08 95       	ret

000002ea <Smoke_Sensor_Handler>:
				vTaskDelayUntil(&xLastWakeTime, (1500 / portTICK_PERIOD_MS));
			}
		}
	}
}
void Smoke_Sensor_Handler( void *pvParameters){
     2ea:	cf 93       	push	r28
     2ec:	df 93       	push	r29
     2ee:	00 d0       	rcall	.+0      	; 0x2f0 <Smoke_Sensor_Handler+0x6>
     2f0:	00 d0       	rcall	.+0      	; 0x2f2 <Smoke_Sensor_Handler+0x8>
     2f2:	cd b7       	in	r28, 0x3d	; 61
     2f4:	de b7       	in	r29, 0x3e	; 62
     2f6:	8c 01       	movw	r16, r24
	QueueHandle_t* xQueue = (QueueHandle_t *)pvParameters;
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
     2f8:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <xTaskGetTickCount>
     2fc:	9a 83       	std	Y+2, r25	; 0x02
     2fe:	89 83       	std	Y+1, r24	; 0x01
	int smokeValue;
	while( 1 )
	{
		smokeValue = Analog_Read(smokePinB);
     300:	82 e0       	ldi	r24, 0x02	; 2
     302:	0e 94 63 01 	call	0x2c6	; 0x2c6 <Analog_Read>
     306:	9c 83       	std	Y+4, r25	; 0x04
     308:	8b 83       	std	Y+3, r24	; 0x03
		xQueueSendToBack( *xQueue, &smokeValue, 0 );
     30a:	20 e0       	ldi	r18, 0x00	; 0
     30c:	40 e0       	ldi	r20, 0x00	; 0
     30e:	50 e0       	ldi	r21, 0x00	; 0
     310:	be 01       	movw	r22, r28
     312:	6d 5f       	subi	r22, 0xFD	; 253
     314:	7f 4f       	sbci	r23, 0xFF	; 255
     316:	f8 01       	movw	r30, r16
     318:	80 81       	ld	r24, Z
     31a:	91 81       	ldd	r25, Z+1	; 0x01
     31c:	0e 94 5e 06 	call	0xcbc	; 0xcbc <xQueueGenericSend>
		vTaskDelayUntil(&xLastWakeTime, (2000 / portTICK_PERIOD_MS));
     320:	60 ed       	ldi	r22, 0xD0	; 208
     322:	77 e0       	ldi	r23, 0x07	; 7
     324:	ce 01       	movw	r24, r28
     326:	01 96       	adiw	r24, 0x01	; 1
     328:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vTaskDelayUntil>
     32c:	e9 cf       	rjmp	.-46     	; 0x300 <Smoke_Sensor_Handler+0x16>

0000032e <Temp_Sensor_Handler>:
	}
}

void Temp_Sensor_Handler( void *pvParameters ){
     32e:	cf 93       	push	r28
     330:	df 93       	push	r29
     332:	00 d0       	rcall	.+0      	; 0x334 <Temp_Sensor_Handler+0x6>
     334:	00 d0       	rcall	.+0      	; 0x336 <Temp_Sensor_Handler+0x8>
     336:	00 d0       	rcall	.+0      	; 0x338 <Temp_Sensor_Handler+0xa>
     338:	cd b7       	in	r28, 0x3d	; 61
     33a:	de b7       	in	r29, 0x3e	; 62
     33c:	8c 01       	movw	r16, r24
	QueueHandle_t* xQueue = (QueueHandle_t *)pvParameters;
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
     33e:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <xTaskGetTickCount>
     342:	9a 83       	std	Y+2, r25	; 0x02
     344:	89 83       	std	Y+1, r24	; 0x01
	float tempvalue;
	while( 1 )
	{
		tempvalue = (Analog_Read(tempPinC) * 4.88); /* Convert ADC value to equivalent voltage */
     346:	83 e0       	ldi	r24, 0x03	; 3
     348:	0e 94 63 01 	call	0x2c6	; 0x2c6 <Analog_Read>
		tempvalue = (tempvalue/10); /* LM35 gives output of 10mv/°C */
     34c:	bc 01       	movw	r22, r24
     34e:	99 0f       	add	r25, r25
     350:	88 0b       	sbc	r24, r24
     352:	99 0b       	sbc	r25, r25
     354:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <__floatsisf>
     358:	26 ef       	ldi	r18, 0xF6	; 246
     35a:	38 e2       	ldi	r19, 0x28	; 40
     35c:	4c e9       	ldi	r20, 0x9C	; 156
     35e:	50 e4       	ldi	r21, 0x40	; 64
     360:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <__mulsf3>
     364:	20 e0       	ldi	r18, 0x00	; 0
     366:	30 e0       	ldi	r19, 0x00	; 0
     368:	40 e2       	ldi	r20, 0x20	; 32
     36a:	51 e4       	ldi	r21, 0x41	; 65
     36c:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <__divsf3>
     370:	6b 83       	std	Y+3, r22	; 0x03
     372:	7c 83       	std	Y+4, r23	; 0x04
     374:	8d 83       	std	Y+5, r24	; 0x05
     376:	9e 83       	std	Y+6, r25	; 0x06
		xQueueSendToBack( *xQueue, &tempvalue, 0 );
     378:	20 e0       	ldi	r18, 0x00	; 0
     37a:	40 e0       	ldi	r20, 0x00	; 0
     37c:	50 e0       	ldi	r21, 0x00	; 0
     37e:	be 01       	movw	r22, r28
     380:	6d 5f       	subi	r22, 0xFD	; 253
     382:	7f 4f       	sbci	r23, 0xFF	; 255
     384:	f8 01       	movw	r30, r16
     386:	80 81       	ld	r24, Z
     388:	91 81       	ldd	r25, Z+1	; 0x01
     38a:	0e 94 5e 06 	call	0xcbc	; 0xcbc <xQueueGenericSend>
		vTaskDelayUntil(&xLastWakeTime, (2000 / portTICK_PERIOD_MS));
     38e:	60 ed       	ldi	r22, 0xD0	; 208
     390:	77 e0       	ldi	r23, 0x07	; 7
     392:	ce 01       	movw	r24, r28
     394:	01 96       	adiw	r24, 0x01	; 1
     396:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vTaskDelayUntil>
     39a:	d5 cf       	rjmp	.-86     	; 0x346 <Temp_Sensor_Handler+0x18>

0000039c <Water_Depth_Sensor_Handler>:
	}
}
void Water_Depth_Sensor_Handler( void *pvParameters ){
     39c:	cf 93       	push	r28
     39e:	df 93       	push	r29
     3a0:	00 d0       	rcall	.+0      	; 0x3a2 <Water_Depth_Sensor_Handler+0x6>
     3a2:	00 d0       	rcall	.+0      	; 0x3a4 <Water_Depth_Sensor_Handler+0x8>
     3a4:	cd b7       	in	r28, 0x3d	; 61
     3a6:	de b7       	in	r29, 0x3e	; 62
     3a8:	8c 01       	movw	r16, r24
	int waterDepthValue=0;
     3aa:	1a 82       	std	Y+2, r1	; 0x02
     3ac:	19 82       	std	Y+1, r1	; 0x01
	QueueHandle_t* xQueue = (QueueHandle_t *)pvParameters;
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
     3ae:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <xTaskGetTickCount>
     3b2:	9c 83       	std	Y+4, r25	; 0x04
     3b4:	8b 83       	std	Y+3, r24	; 0x03
	while( 1 )
	{
		waterDepthValue = Analog_Read(waterPinC);
     3b6:	84 e0       	ldi	r24, 0x04	; 4
     3b8:	0e 94 63 01 	call	0x2c6	; 0x2c6 <Analog_Read>
     3bc:	9a 83       	std	Y+2, r25	; 0x02
     3be:	89 83       	std	Y+1, r24	; 0x01
		xQueueSendToBack( *xQueue, &waterDepthValue, 0 );
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	40 e0       	ldi	r20, 0x00	; 0
     3c4:	50 e0       	ldi	r21, 0x00	; 0
     3c6:	be 01       	movw	r22, r28
     3c8:	6f 5f       	subi	r22, 0xFF	; 255
     3ca:	7f 4f       	sbci	r23, 0xFF	; 255
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 81       	ld	r24, Z
     3d0:	91 81       	ldd	r25, Z+1	; 0x01
     3d2:	0e 94 5e 06 	call	0xcbc	; 0xcbc <xQueueGenericSend>
		vTaskDelayUntil(&xLastWakeTime, (2000 / portTICK_PERIOD_MS));
     3d6:	60 ed       	ldi	r22, 0xD0	; 208
     3d8:	77 e0       	ldi	r23, 0x07	; 7
     3da:	ce 01       	movw	r24, r28
     3dc:	03 96       	adiw	r24, 0x03	; 3
     3de:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vTaskDelayUntil>
     3e2:	e9 cf       	rjmp	.-46     	; 0x3b6 <Water_Depth_Sensor_Handler+0x1a>

000003e4 <WriteCommand>:
	//_delay_ms(2);
	WriteCommand (0x80);		/* Cursor at home position */
}
void WriteCommand(char comm)
{
	DDRD = 0xff;//BITDATA
     3e4:	9f ef       	ldi	r25, 0xFF	; 255
     3e6:	9a b9       	out	0x0a, r25	; 10
	DDRC = 0xff;//EN,RS
     3e8:	97 b9       	out	0x07, r25	; 7
	
	PORTC &= ~ (1<<RS);	
     3ea:	41 98       	cbi	0x08, 1	; 8
	PORTD = (PORTD & 0x0F) | (comm & 0xF0);
     3ec:	9b b1       	in	r25, 0x0b	; 11
     3ee:	9f 70       	andi	r25, 0x0F	; 15
     3f0:	28 2f       	mov	r18, r24
     3f2:	20 7f       	andi	r18, 0xF0	; 240
     3f4:	92 2b       	or	r25, r18
     3f6:	9b b9       	out	0x0b, r25	; 11
		
	PORTC|= (1<<EN);		
     3f8:	40 9a       	sbi	0x08, 0	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3fa:	e9 ef       	ldi	r30, 0xF9	; 249
     3fc:	f0 e0       	ldi	r31, 0x00	; 0
     3fe:	31 97       	sbiw	r30, 0x01	; 1
     400:	f1 f7       	brne	.-4      	; 0x3fe <WriteCommand+0x1a>
     402:	00 c0       	rjmp	.+0      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     404:	00 00       	nop
	_delay_ms(1);
	PORTC &= ~ (1<<EN);
     406:	40 98       	cbi	0x08, 0	; 8
     408:	e3 ef       	ldi	r30, 0xF3	; 243
     40a:	f1 e0       	ldi	r31, 0x01	; 1
     40c:	31 97       	sbiw	r30, 0x01	; 1
     40e:	f1 f7       	brne	.-4      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     410:	00 c0       	rjmp	.+0      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
     412:	00 00       	nop
	_delay_ms(2);
	PORTD = (PORTD & 0x0F) |( (comm << 4));
     414:	2b b1       	in	r18, 0x0b	; 11
     416:	2f 70       	andi	r18, 0x0F	; 15
     418:	f0 e1       	ldi	r31, 0x10	; 16
     41a:	8f 9f       	mul	r24, r31
     41c:	c0 01       	movw	r24, r0
     41e:	11 24       	eor	r1, r1
     420:	82 2b       	or	r24, r18
     422:	8b b9       	out	0x0b, r24	; 11
	PORTC |= (1<<EN);
     424:	40 9a       	sbi	0x08, 0	; 8
     426:	83 ef       	ldi	r24, 0xF3	; 243
     428:	91 e0       	ldi	r25, 0x01	; 1
     42a:	01 97       	sbiw	r24, 0x01	; 1
     42c:	f1 f7       	brne	.-4      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     42e:	00 c0       	rjmp	.+0      	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
     430:	00 00       	nop
	_delay_ms(2);
	PORTC&= ~ (1<<EN);
     432:	40 98       	cbi	0x08, 0	; 8
     434:	eb e5       	ldi	r30, 0x5B	; 91
     436:	f4 e4       	ldi	r31, 0x44	; 68
     438:	31 97       	sbiw	r30, 0x01	; 1
     43a:	f1 f7       	brne	.-4      	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
     43c:	00 c0       	rjmp	.+0      	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
     43e:	00 00       	nop
     440:	08 95       	ret

00000442 <Clear_LCD>:
#define FirstLine 0x80
#define SecondLine 0xc0

void Clear_LCD()
{
	WriteCommand(0x01);
     442:	81 e0       	ldi	r24, 0x01	; 1
     444:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <WriteCommand>
	//LCD_Command (0x01);		/* Clear display */
	//_delay_ms(2);
	WriteCommand (0x80);		/* Cursor at home position */
     448:	80 e8       	ldi	r24, 0x80	; 128
     44a:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <WriteCommand>
     44e:	08 95       	ret

00000450 <WriteDataChar>:
	
}

void WriteDataChar(char data)
{
	DDRD = 0xf0;
     450:	90 ef       	ldi	r25, 0xF0	; 240
     452:	9a b9       	out	0x0a, r25	; 10
	DDRC = 0x03;
     454:	93 e0       	ldi	r25, 0x03	; 3
     456:	97 b9       	out	0x07, r25	; 7
	PORTC|= (1<<RS);
     458:	41 9a       	sbi	0x08, 1	; 8
	PORTD = (PORTD & 0x0F) | (data & 0xF0);
     45a:	9b b1       	in	r25, 0x0b	; 11
     45c:	9f 70       	andi	r25, 0x0F	; 15
     45e:	28 2f       	mov	r18, r24
     460:	20 7f       	andi	r18, 0xF0	; 240
     462:	92 2b       	or	r25, r18
     464:	9b b9       	out	0x0b, r25	; 11
			
	PORTC |= (1<<EN);		
     466:	40 9a       	sbi	0x08, 0	; 8
     468:	e9 ef       	ldi	r30, 0xF9	; 249
     46a:	f0 e0       	ldi	r31, 0x00	; 0
     46c:	31 97       	sbiw	r30, 0x01	; 1
     46e:	f1 f7       	brne	.-4      	; 0x46c <WriteDataChar+0x1c>
     470:	00 c0       	rjmp	.+0      	; 0x472 <WriteDataChar+0x22>
     472:	00 00       	nop
	_delay_ms(1);
	PORTC &= ~ (1<<EN);
     474:	40 98       	cbi	0x08, 0	; 8
     476:	e9 ef       	ldi	r30, 0xF9	; 249
     478:	f0 e0       	ldi	r31, 0x00	; 0
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	f1 f7       	brne	.-4      	; 0x47a <WriteDataChar+0x2a>
     47e:	00 c0       	rjmp	.+0      	; 0x480 <WriteDataChar+0x30>
     480:	00 00       	nop
	_delay_ms(1);
	PORTD = (PORTD & 0x0F) | ((data << 4));
     482:	2b b1       	in	r18, 0x0b	; 11
     484:	2f 70       	andi	r18, 0x0F	; 15
     486:	f0 e1       	ldi	r31, 0x10	; 16
     488:	8f 9f       	mul	r24, r31
     48a:	c0 01       	movw	r24, r0
     48c:	11 24       	eor	r1, r1
     48e:	82 2b       	or	r24, r18
     490:	8b b9       	out	0x0b, r24	; 11
	PORTC |= (1<<EN);
     492:	40 9a       	sbi	0x08, 0	; 8
     494:	89 ef       	ldi	r24, 0xF9	; 249
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	01 97       	sbiw	r24, 0x01	; 1
     49a:	f1 f7       	brne	.-4      	; 0x498 <WriteDataChar+0x48>
     49c:	00 c0       	rjmp	.+0      	; 0x49e <WriteDataChar+0x4e>
     49e:	00 00       	nop
	_delay_ms(1);
	PORTC &= ~ (1<<EN);
     4a0:	40 98       	cbi	0x08, 0	; 8
     4a2:	e3 ef       	ldi	r30, 0xF3	; 243
     4a4:	f1 e0       	ldi	r31, 0x01	; 1
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	f1 f7       	brne	.-4      	; 0x4a6 <WriteDataChar+0x56>
     4aa:	00 c0       	rjmp	.+0      	; 0x4ac <WriteDataChar+0x5c>
     4ac:	00 00       	nop
     4ae:	08 95       	ret

000004b0 <WriteDataString>:
	_delay_ms(2);
	
}
void WriteDataString(char *string_of_characters)
{
     4b0:	cf 93       	push	r28
     4b2:	df 93       	push	r29
     4b4:	ec 01       	movw	r28, r24
	while(*string_of_characters > 0)
     4b6:	88 81       	ld	r24, Y
     4b8:	88 23       	and	r24, r24
     4ba:	31 f0       	breq	.+12     	; 0x4c8 <WriteDataString+0x18>
     4bc:	21 96       	adiw	r28, 0x01	; 1
	{
		WriteDataChar(*string_of_characters++);
     4be:	0e 94 28 02 	call	0x450	; 0x450 <WriteDataChar>
	_delay_ms(2);
	
}
void WriteDataString(char *string_of_characters)
{
	while(*string_of_characters > 0)
     4c2:	89 91       	ld	r24, Y+
     4c4:	81 11       	cpse	r24, r1
     4c6:	fb cf       	rjmp	.-10     	; 0x4be <WriteDataString+0xe>
	{
		WriteDataChar(*string_of_characters++);
	}
}
     4c8:	df 91       	pop	r29
     4ca:	cf 91       	pop	r28
     4cc:	08 95       	ret

000004ce <LCD_Init>:
void LCD_Init()
{
	WriteCommand(0x33);
     4ce:	83 e3       	ldi	r24, 0x33	; 51
     4d0:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <WriteCommand>
	WriteCommand(0x32);	
     4d4:	82 e3       	ldi	r24, 0x32	; 50
     4d6:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <WriteCommand>
	WriteCommand(0x28);	
     4da:	88 e2       	ldi	r24, 0x28	; 40
     4dc:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <WriteCommand>
	WriteCommand(0x0c);	
     4e0:	8c e0       	ldi	r24, 0x0C	; 12
     4e2:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <WriteCommand>
	WriteCommand(0x06);	
     4e6:	86 e0       	ldi	r24, 0x06	; 6
     4e8:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <WriteCommand>
	WriteCommand(0x01);
     4ec:	81 e0       	ldi	r24, 0x01	; 1
     4ee:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <WriteCommand>
     4f2:	08 95       	ret

000004f4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     4f4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4f6:	03 96       	adiw	r24, 0x03	; 3
     4f8:	92 83       	std	Z+2, r25	; 0x02
     4fa:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     4fc:	2f ef       	ldi	r18, 0xFF	; 255
     4fe:	3f ef       	ldi	r19, 0xFF	; 255
     500:	34 83       	std	Z+4, r19	; 0x04
     502:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     504:	96 83       	std	Z+6, r25	; 0x06
     506:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     508:	90 87       	std	Z+8, r25	; 0x08
     50a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     50c:	10 82       	st	Z, r1
     50e:	08 95       	ret

00000510 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     510:	fc 01       	movw	r30, r24
     512:	11 86       	std	Z+9, r1	; 0x09
     514:	10 86       	std	Z+8, r1	; 0x08
     516:	08 95       	ret

00000518 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     518:	cf 93       	push	r28
     51a:	df 93       	push	r29
     51c:	9c 01       	movw	r18, r24
     51e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     520:	dc 01       	movw	r26, r24
     522:	11 96       	adiw	r26, 0x01	; 1
     524:	cd 91       	ld	r28, X+
     526:	dc 91       	ld	r29, X
     528:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     52a:	d3 83       	std	Z+3, r29	; 0x03
     52c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     52e:	8c 81       	ldd	r24, Y+4	; 0x04
     530:	9d 81       	ldd	r25, Y+5	; 0x05
     532:	95 83       	std	Z+5, r25	; 0x05
     534:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     536:	8c 81       	ldd	r24, Y+4	; 0x04
     538:	9d 81       	ldd	r25, Y+5	; 0x05
     53a:	dc 01       	movw	r26, r24
     53c:	13 96       	adiw	r26, 0x03	; 3
     53e:	7c 93       	st	X, r23
     540:	6e 93       	st	-X, r22
     542:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     544:	7d 83       	std	Y+5, r23	; 0x05
     546:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     548:	31 87       	std	Z+9, r19	; 0x09
     54a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     54c:	f9 01       	movw	r30, r18
     54e:	80 81       	ld	r24, Z
     550:	8f 5f       	subi	r24, 0xFF	; 255
     552:	80 83       	st	Z, r24
}
     554:	df 91       	pop	r29
     556:	cf 91       	pop	r28
     558:	08 95       	ret

0000055a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     55a:	cf 93       	push	r28
     55c:	df 93       	push	r29
     55e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     560:	48 81       	ld	r20, Y
     562:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     564:	4f 3f       	cpi	r20, 0xFF	; 255
     566:	2f ef       	ldi	r18, 0xFF	; 255
     568:	52 07       	cpc	r21, r18
     56a:	21 f4       	brne	.+8      	; 0x574 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     56c:	fc 01       	movw	r30, r24
     56e:	a7 81       	ldd	r26, Z+7	; 0x07
     570:	b0 85       	ldd	r27, Z+8	; 0x08
     572:	0d c0       	rjmp	.+26     	; 0x58e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     574:	dc 01       	movw	r26, r24
     576:	13 96       	adiw	r26, 0x03	; 3
     578:	01 c0       	rjmp	.+2      	; 0x57c <vListInsert+0x22>
     57a:	df 01       	movw	r26, r30
     57c:	12 96       	adiw	r26, 0x02	; 2
     57e:	ed 91       	ld	r30, X+
     580:	fc 91       	ld	r31, X
     582:	13 97       	sbiw	r26, 0x03	; 3
     584:	20 81       	ld	r18, Z
     586:	31 81       	ldd	r19, Z+1	; 0x01
     588:	42 17       	cp	r20, r18
     58a:	53 07       	cpc	r21, r19
     58c:	b0 f7       	brcc	.-20     	; 0x57a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     58e:	12 96       	adiw	r26, 0x02	; 2
     590:	ed 91       	ld	r30, X+
     592:	fc 91       	ld	r31, X
     594:	13 97       	sbiw	r26, 0x03	; 3
     596:	fb 83       	std	Y+3, r31	; 0x03
     598:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     59a:	d5 83       	std	Z+5, r29	; 0x05
     59c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     59e:	bd 83       	std	Y+5, r27	; 0x05
     5a0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5a2:	13 96       	adiw	r26, 0x03	; 3
     5a4:	dc 93       	st	X, r29
     5a6:	ce 93       	st	-X, r28
     5a8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5aa:	99 87       	std	Y+9, r25	; 0x09
     5ac:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     5ae:	fc 01       	movw	r30, r24
     5b0:	20 81       	ld	r18, Z
     5b2:	2f 5f       	subi	r18, 0xFF	; 255
     5b4:	20 83       	st	Z, r18
}
     5b6:	df 91       	pop	r29
     5b8:	cf 91       	pop	r28
     5ba:	08 95       	ret

000005bc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
     5c0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     5c2:	a0 85       	ldd	r26, Z+8	; 0x08
     5c4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     5c6:	c2 81       	ldd	r28, Z+2	; 0x02
     5c8:	d3 81       	ldd	r29, Z+3	; 0x03
     5ca:	84 81       	ldd	r24, Z+4	; 0x04
     5cc:	95 81       	ldd	r25, Z+5	; 0x05
     5ce:	9d 83       	std	Y+5, r25	; 0x05
     5d0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     5d2:	c4 81       	ldd	r28, Z+4	; 0x04
     5d4:	d5 81       	ldd	r29, Z+5	; 0x05
     5d6:	82 81       	ldd	r24, Z+2	; 0x02
     5d8:	93 81       	ldd	r25, Z+3	; 0x03
     5da:	9b 83       	std	Y+3, r25	; 0x03
     5dc:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     5de:	11 96       	adiw	r26, 0x01	; 1
     5e0:	8d 91       	ld	r24, X+
     5e2:	9c 91       	ld	r25, X
     5e4:	12 97       	sbiw	r26, 0x02	; 2
     5e6:	e8 17       	cp	r30, r24
     5e8:	f9 07       	cpc	r31, r25
     5ea:	31 f4       	brne	.+12     	; 0x5f8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     5ec:	84 81       	ldd	r24, Z+4	; 0x04
     5ee:	95 81       	ldd	r25, Z+5	; 0x05
     5f0:	12 96       	adiw	r26, 0x02	; 2
     5f2:	9c 93       	st	X, r25
     5f4:	8e 93       	st	-X, r24
     5f6:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     5f8:	11 86       	std	Z+9, r1	; 0x09
     5fa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     5fc:	8c 91       	ld	r24, X
     5fe:	81 50       	subi	r24, 0x01	; 1
     600:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	08 95       	ret

00000608 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     608:	31 e1       	ldi	r19, 0x11	; 17
     60a:	fc 01       	movw	r30, r24
     60c:	30 83       	st	Z, r19
     60e:	31 97       	sbiw	r30, 0x01	; 1
     610:	22 e2       	ldi	r18, 0x22	; 34
     612:	20 83       	st	Z, r18
     614:	31 97       	sbiw	r30, 0x01	; 1
     616:	a3 e3       	ldi	r26, 0x33	; 51
     618:	a0 83       	st	Z, r26
     61a:	31 97       	sbiw	r30, 0x01	; 1
     61c:	60 83       	st	Z, r22
     61e:	31 97       	sbiw	r30, 0x01	; 1
     620:	70 83       	st	Z, r23
     622:	31 97       	sbiw	r30, 0x01	; 1
     624:	10 82       	st	Z, r1
     626:	31 97       	sbiw	r30, 0x01	; 1
     628:	60 e8       	ldi	r22, 0x80	; 128
     62a:	60 83       	st	Z, r22
     62c:	31 97       	sbiw	r30, 0x01	; 1
     62e:	10 82       	st	Z, r1
     630:	31 97       	sbiw	r30, 0x01	; 1
     632:	62 e0       	ldi	r22, 0x02	; 2
     634:	60 83       	st	Z, r22
     636:	31 97       	sbiw	r30, 0x01	; 1
     638:	63 e0       	ldi	r22, 0x03	; 3
     63a:	60 83       	st	Z, r22
     63c:	31 97       	sbiw	r30, 0x01	; 1
     63e:	64 e0       	ldi	r22, 0x04	; 4
     640:	60 83       	st	Z, r22
     642:	31 97       	sbiw	r30, 0x01	; 1
     644:	65 e0       	ldi	r22, 0x05	; 5
     646:	60 83       	st	Z, r22
     648:	31 97       	sbiw	r30, 0x01	; 1
     64a:	66 e0       	ldi	r22, 0x06	; 6
     64c:	60 83       	st	Z, r22
     64e:	31 97       	sbiw	r30, 0x01	; 1
     650:	67 e0       	ldi	r22, 0x07	; 7
     652:	60 83       	st	Z, r22
     654:	31 97       	sbiw	r30, 0x01	; 1
     656:	68 e0       	ldi	r22, 0x08	; 8
     658:	60 83       	st	Z, r22
     65a:	31 97       	sbiw	r30, 0x01	; 1
     65c:	69 e0       	ldi	r22, 0x09	; 9
     65e:	60 83       	st	Z, r22
     660:	31 97       	sbiw	r30, 0x01	; 1
     662:	60 e1       	ldi	r22, 0x10	; 16
     664:	60 83       	st	Z, r22
     666:	31 97       	sbiw	r30, 0x01	; 1
     668:	30 83       	st	Z, r19
     66a:	31 97       	sbiw	r30, 0x01	; 1
     66c:	32 e1       	ldi	r19, 0x12	; 18
     66e:	30 83       	st	Z, r19
     670:	31 97       	sbiw	r30, 0x01	; 1
     672:	33 e1       	ldi	r19, 0x13	; 19
     674:	30 83       	st	Z, r19
     676:	31 97       	sbiw	r30, 0x01	; 1
     678:	34 e1       	ldi	r19, 0x14	; 20
     67a:	30 83       	st	Z, r19
     67c:	31 97       	sbiw	r30, 0x01	; 1
     67e:	35 e1       	ldi	r19, 0x15	; 21
     680:	30 83       	st	Z, r19
     682:	31 97       	sbiw	r30, 0x01	; 1
     684:	36 e1       	ldi	r19, 0x16	; 22
     686:	30 83       	st	Z, r19
     688:	31 97       	sbiw	r30, 0x01	; 1
     68a:	37 e1       	ldi	r19, 0x17	; 23
     68c:	30 83       	st	Z, r19
     68e:	31 97       	sbiw	r30, 0x01	; 1
     690:	38 e1       	ldi	r19, 0x18	; 24
     692:	30 83       	st	Z, r19
     694:	31 97       	sbiw	r30, 0x01	; 1
     696:	39 e1       	ldi	r19, 0x19	; 25
     698:	30 83       	st	Z, r19
     69a:	31 97       	sbiw	r30, 0x01	; 1
     69c:	30 e2       	ldi	r19, 0x20	; 32
     69e:	30 83       	st	Z, r19
     6a0:	31 97       	sbiw	r30, 0x01	; 1
     6a2:	31 e2       	ldi	r19, 0x21	; 33
     6a4:	30 83       	st	Z, r19
     6a6:	31 97       	sbiw	r30, 0x01	; 1
     6a8:	20 83       	st	Z, r18
     6aa:	31 97       	sbiw	r30, 0x01	; 1
     6ac:	23 e2       	ldi	r18, 0x23	; 35
     6ae:	20 83       	st	Z, r18
     6b0:	31 97       	sbiw	r30, 0x01	; 1
     6b2:	40 83       	st	Z, r20
     6b4:	31 97       	sbiw	r30, 0x01	; 1
     6b6:	50 83       	st	Z, r21
     6b8:	31 97       	sbiw	r30, 0x01	; 1
     6ba:	26 e2       	ldi	r18, 0x26	; 38
     6bc:	20 83       	st	Z, r18
     6be:	31 97       	sbiw	r30, 0x01	; 1
     6c0:	27 e2       	ldi	r18, 0x27	; 39
     6c2:	20 83       	st	Z, r18
     6c4:	31 97       	sbiw	r30, 0x01	; 1
     6c6:	28 e2       	ldi	r18, 0x28	; 40
     6c8:	20 83       	st	Z, r18
     6ca:	31 97       	sbiw	r30, 0x01	; 1
     6cc:	29 e2       	ldi	r18, 0x29	; 41
     6ce:	20 83       	st	Z, r18
     6d0:	31 97       	sbiw	r30, 0x01	; 1
     6d2:	20 e3       	ldi	r18, 0x30	; 48
     6d4:	20 83       	st	Z, r18
     6d6:	31 97       	sbiw	r30, 0x01	; 1
     6d8:	21 e3       	ldi	r18, 0x31	; 49
     6da:	20 83       	st	Z, r18
     6dc:	86 97       	sbiw	r24, 0x26	; 38
     6de:	08 95       	ret

000006e0 <xPortStartScheduler>:
     6e0:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
     6e4:	8c e7       	ldi	r24, 0x7C	; 124
     6e6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
     6ea:	8b e0       	ldi	r24, 0x0B	; 11
     6ec:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
     6f0:	ef e6       	ldi	r30, 0x6F	; 111
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	80 81       	ld	r24, Z
     6f6:	82 60       	ori	r24, 0x02	; 2
     6f8:	80 83       	st	Z, r24
     6fa:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     6fe:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     702:	cd 91       	ld	r28, X+
     704:	cd bf       	out	0x3d, r28	; 61
     706:	dd 91       	ld	r29, X+
     708:	de bf       	out	0x3e, r29	; 62
     70a:	ff 91       	pop	r31
     70c:	ef 91       	pop	r30
     70e:	df 91       	pop	r29
     710:	cf 91       	pop	r28
     712:	bf 91       	pop	r27
     714:	af 91       	pop	r26
     716:	9f 91       	pop	r25
     718:	8f 91       	pop	r24
     71a:	7f 91       	pop	r23
     71c:	6f 91       	pop	r22
     71e:	5f 91       	pop	r21
     720:	4f 91       	pop	r20
     722:	3f 91       	pop	r19
     724:	2f 91       	pop	r18
     726:	1f 91       	pop	r17
     728:	0f 91       	pop	r16
     72a:	ff 90       	pop	r15
     72c:	ef 90       	pop	r14
     72e:	df 90       	pop	r13
     730:	cf 90       	pop	r12
     732:	bf 90       	pop	r11
     734:	af 90       	pop	r10
     736:	9f 90       	pop	r9
     738:	8f 90       	pop	r8
     73a:	7f 90       	pop	r7
     73c:	6f 90       	pop	r6
     73e:	5f 90       	pop	r5
     740:	4f 90       	pop	r4
     742:	3f 90       	pop	r3
     744:	2f 90       	pop	r2
     746:	1f 90       	pop	r1
     748:	0f 90       	pop	r0
     74a:	0f be       	out	0x3f, r0	; 63
     74c:	0f 90       	pop	r0
     74e:	08 95       	ret
     750:	81 e0       	ldi	r24, 0x01	; 1
     752:	08 95       	ret

00000754 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     754:	0f 92       	push	r0
     756:	0f b6       	in	r0, 0x3f	; 63
     758:	f8 94       	cli
     75a:	0f 92       	push	r0
     75c:	1f 92       	push	r1
     75e:	11 24       	eor	r1, r1
     760:	2f 92       	push	r2
     762:	3f 92       	push	r3
     764:	4f 92       	push	r4
     766:	5f 92       	push	r5
     768:	6f 92       	push	r6
     76a:	7f 92       	push	r7
     76c:	8f 92       	push	r8
     76e:	9f 92       	push	r9
     770:	af 92       	push	r10
     772:	bf 92       	push	r11
     774:	cf 92       	push	r12
     776:	df 92       	push	r13
     778:	ef 92       	push	r14
     77a:	ff 92       	push	r15
     77c:	0f 93       	push	r16
     77e:	1f 93       	push	r17
     780:	2f 93       	push	r18
     782:	3f 93       	push	r19
     784:	4f 93       	push	r20
     786:	5f 93       	push	r21
     788:	6f 93       	push	r22
     78a:	7f 93       	push	r23
     78c:	8f 93       	push	r24
     78e:	9f 93       	push	r25
     790:	af 93       	push	r26
     792:	bf 93       	push	r27
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	ef 93       	push	r30
     79a:	ff 93       	push	r31
     79c:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     7a0:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     7a4:	0d b6       	in	r0, 0x3d	; 61
     7a6:	0d 92       	st	X+, r0
     7a8:	0e b6       	in	r0, 0x3e	; 62
     7aa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     7ac:	0e 94 23 0b 	call	0x1646	; 0x1646 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     7b0:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     7b4:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     7b8:	cd 91       	ld	r28, X+
     7ba:	cd bf       	out	0x3d, r28	; 61
     7bc:	dd 91       	ld	r29, X+
     7be:	de bf       	out	0x3e, r29	; 62
     7c0:	ff 91       	pop	r31
     7c2:	ef 91       	pop	r30
     7c4:	df 91       	pop	r29
     7c6:	cf 91       	pop	r28
     7c8:	bf 91       	pop	r27
     7ca:	af 91       	pop	r26
     7cc:	9f 91       	pop	r25
     7ce:	8f 91       	pop	r24
     7d0:	7f 91       	pop	r23
     7d2:	6f 91       	pop	r22
     7d4:	5f 91       	pop	r21
     7d6:	4f 91       	pop	r20
     7d8:	3f 91       	pop	r19
     7da:	2f 91       	pop	r18
     7dc:	1f 91       	pop	r17
     7de:	0f 91       	pop	r16
     7e0:	ff 90       	pop	r15
     7e2:	ef 90       	pop	r14
     7e4:	df 90       	pop	r13
     7e6:	cf 90       	pop	r12
     7e8:	bf 90       	pop	r11
     7ea:	af 90       	pop	r10
     7ec:	9f 90       	pop	r9
     7ee:	8f 90       	pop	r8
     7f0:	7f 90       	pop	r7
     7f2:	6f 90       	pop	r6
     7f4:	5f 90       	pop	r5
     7f6:	4f 90       	pop	r4
     7f8:	3f 90       	pop	r3
     7fa:	2f 90       	pop	r2
     7fc:	1f 90       	pop	r1
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
     802:	0f 90       	pop	r0

	asm volatile ( "ret" );
     804:	08 95       	ret

00000806 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     806:	0f 92       	push	r0
     808:	0f b6       	in	r0, 0x3f	; 63
     80a:	f8 94       	cli
     80c:	0f 92       	push	r0
     80e:	1f 92       	push	r1
     810:	11 24       	eor	r1, r1
     812:	2f 92       	push	r2
     814:	3f 92       	push	r3
     816:	4f 92       	push	r4
     818:	5f 92       	push	r5
     81a:	6f 92       	push	r6
     81c:	7f 92       	push	r7
     81e:	8f 92       	push	r8
     820:	9f 92       	push	r9
     822:	af 92       	push	r10
     824:	bf 92       	push	r11
     826:	cf 92       	push	r12
     828:	df 92       	push	r13
     82a:	ef 92       	push	r14
     82c:	ff 92       	push	r15
     82e:	0f 93       	push	r16
     830:	1f 93       	push	r17
     832:	2f 93       	push	r18
     834:	3f 93       	push	r19
     836:	4f 93       	push	r20
     838:	5f 93       	push	r21
     83a:	6f 93       	push	r22
     83c:	7f 93       	push	r23
     83e:	8f 93       	push	r24
     840:	9f 93       	push	r25
     842:	af 93       	push	r26
     844:	bf 93       	push	r27
     846:	cf 93       	push	r28
     848:	df 93       	push	r29
     84a:	ef 93       	push	r30
     84c:	ff 93       	push	r31
     84e:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     852:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     856:	0d b6       	in	r0, 0x3d	; 61
     858:	0d 92       	st	X+, r0
     85a:	0e b6       	in	r0, 0x3e	; 62
     85c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     85e:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskIncrementTick>
     862:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     864:	0e 94 23 0b 	call	0x1646	; 0x1646 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     868:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     86c:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     870:	cd 91       	ld	r28, X+
     872:	cd bf       	out	0x3d, r28	; 61
     874:	dd 91       	ld	r29, X+
     876:	de bf       	out	0x3e, r29	; 62
     878:	ff 91       	pop	r31
     87a:	ef 91       	pop	r30
     87c:	df 91       	pop	r29
     87e:	cf 91       	pop	r28
     880:	bf 91       	pop	r27
     882:	af 91       	pop	r26
     884:	9f 91       	pop	r25
     886:	8f 91       	pop	r24
     888:	7f 91       	pop	r23
     88a:	6f 91       	pop	r22
     88c:	5f 91       	pop	r21
     88e:	4f 91       	pop	r20
     890:	3f 91       	pop	r19
     892:	2f 91       	pop	r18
     894:	1f 91       	pop	r17
     896:	0f 91       	pop	r16
     898:	ff 90       	pop	r15
     89a:	ef 90       	pop	r14
     89c:	df 90       	pop	r13
     89e:	cf 90       	pop	r12
     8a0:	bf 90       	pop	r11
     8a2:	af 90       	pop	r10
     8a4:	9f 90       	pop	r9
     8a6:	8f 90       	pop	r8
     8a8:	7f 90       	pop	r7
     8aa:	6f 90       	pop	r6
     8ac:	5f 90       	pop	r5
     8ae:	4f 90       	pop	r4
     8b0:	3f 90       	pop	r3
     8b2:	2f 90       	pop	r2
     8b4:	1f 90       	pop	r1
     8b6:	0f 90       	pop	r0
     8b8:	0f be       	out	0x3f, r0	; 63
     8ba:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8bc:	08 95       	ret

000008be <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
     8be:	0e 94 03 04 	call	0x806	; 0x806 <vPortYieldFromTick>
		asm volatile ( "reti" );
     8c2:	18 95       	reti

000008c4 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     8c4:	0f 93       	push	r16
     8c6:	1f 93       	push	r17
     8c8:	cf 93       	push	r28
     8ca:	df 93       	push	r29
     8cc:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     8ce:	0e 94 55 09 	call	0x12aa	; 0x12aa <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     8d2:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <__data_end>
     8d6:	81 11       	cpse	r24, r1
     8d8:	1d c0       	rjmp	.+58     	; 0x914 <__stack+0x15>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     8da:	ef ea       	ldi	r30, 0xAF	; 175
     8dc:	f1 e0       	ldi	r31, 0x01	; 1
     8de:	84 eb       	ldi	r24, 0xB4	; 180
     8e0:	91 e0       	ldi	r25, 0x01	; 1
     8e2:	91 83       	std	Z+1, r25	; 0x01
     8e4:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     8e6:	13 82       	std	Z+3, r1	; 0x03
     8e8:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     8ea:	eb ea       	ldi	r30, 0xAB	; 171
     8ec:	f1 e0       	ldi	r31, 0x01	; 1
     8ee:	8b ed       	ldi	r24, 0xDB	; 219
     8f0:	95 e0       	ldi	r25, 0x05	; 5
     8f2:	93 83       	std	Z+3, r25	; 0x03
     8f4:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     8f6:	11 82       	std	Z+1, r1	; 0x01
     8f8:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     8fa:	a3 eb       	ldi	r26, 0xB3	; 179
     8fc:	b1 e0       	ldi	r27, 0x01	; 1
     8fe:	14 96       	adiw	r26, 0x04	; 4
     900:	9c 93       	st	X, r25
     902:	8e 93       	st	-X, r24
     904:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     906:	12 96       	adiw	r26, 0x02	; 2
     908:	fc 93       	st	X, r31
     90a:	ee 93       	st	-X, r30
     90c:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     90e:	81 e0       	ldi	r24, 0x01	; 1
     910:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     914:	20 97       	sbiw	r28, 0x00	; 0
     916:	09 f4       	brne	.+2      	; 0x91a <__stack+0x1b>
     918:	5f c0       	rjmp	.+190    	; 0x9d8 <__stack+0xd9>
		{
			xWantedSize += heapSTRUCT_SIZE;
     91a:	9e 01       	movw	r18, r28
     91c:	2c 5f       	subi	r18, 0xFC	; 252
     91e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     920:	23 96       	adiw	r28, 0x03	; 3
     922:	ca 3d       	cpi	r28, 0xDA	; 218
     924:	d5 40       	sbci	r29, 0x05	; 5
     926:	08 f0       	brcs	.+2      	; 0x92a <__stack+0x2b>
     928:	5a c0       	rjmp	.+180    	; 0x9de <__stack+0xdf>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     92a:	e0 91 af 01 	lds	r30, 0x01AF	; 0x8001af <xStart>
     92e:	f0 91 b0 01 	lds	r31, 0x01B0	; 0x8001b0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     932:	af ea       	ldi	r26, 0xAF	; 175
     934:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     936:	02 c0       	rjmp	.+4      	; 0x93c <__stack+0x3d>
     938:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     93a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     93c:	82 81       	ldd	r24, Z+2	; 0x02
     93e:	93 81       	ldd	r25, Z+3	; 0x03
     940:	82 17       	cp	r24, r18
     942:	93 07       	cpc	r25, r19
     944:	20 f4       	brcc	.+8      	; 0x94e <__stack+0x4f>
     946:	80 81       	ld	r24, Z
     948:	91 81       	ldd	r25, Z+1	; 0x01
     94a:	00 97       	sbiw	r24, 0x00	; 0
     94c:	a9 f7       	brne	.-22     	; 0x938 <__stack+0x39>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     94e:	c1 e0       	ldi	r28, 0x01	; 1
     950:	eb 3a       	cpi	r30, 0xAB	; 171
     952:	fc 07       	cpc	r31, r28
     954:	09 f4       	brne	.+2      	; 0x958 <__stack+0x59>
     956:	46 c0       	rjmp	.+140    	; 0x9e4 <__stack+0xe5>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     958:	cd 91       	ld	r28, X+
     95a:	dc 91       	ld	r29, X
     95c:	11 97       	sbiw	r26, 0x01	; 1
     95e:	8e 01       	movw	r16, r28
     960:	0c 5f       	subi	r16, 0xFC	; 252
     962:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     964:	80 81       	ld	r24, Z
     966:	91 81       	ldd	r25, Z+1	; 0x01
     968:	8d 93       	st	X+, r24
     96a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     96c:	82 81       	ldd	r24, Z+2	; 0x02
     96e:	93 81       	ldd	r25, Z+3	; 0x03
     970:	82 1b       	sub	r24, r18
     972:	93 0b       	sbc	r25, r19
     974:	89 30       	cpi	r24, 0x09	; 9
     976:	91 05       	cpc	r25, r1
     978:	10 f1       	brcs	.+68     	; 0x9be <__stack+0xbf>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     97a:	bf 01       	movw	r22, r30
     97c:	62 0f       	add	r22, r18
     97e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     980:	db 01       	movw	r26, r22
     982:	13 96       	adiw	r26, 0x03	; 3
     984:	9c 93       	st	X, r25
     986:	8e 93       	st	-X, r24
     988:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     98a:	33 83       	std	Z+3, r19	; 0x03
     98c:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     98e:	12 96       	adiw	r26, 0x02	; 2
     990:	4d 91       	ld	r20, X+
     992:	5c 91       	ld	r21, X
     994:	13 97       	sbiw	r26, 0x03	; 3
     996:	8f ea       	ldi	r24, 0xAF	; 175
     998:	91 e0       	ldi	r25, 0x01	; 1
     99a:	01 c0       	rjmp	.+2      	; 0x99e <__stack+0x9f>
     99c:	cd 01       	movw	r24, r26
     99e:	ec 01       	movw	r28, r24
     9a0:	a8 81       	ld	r26, Y
     9a2:	b9 81       	ldd	r27, Y+1	; 0x01
     9a4:	12 96       	adiw	r26, 0x02	; 2
     9a6:	2d 91       	ld	r18, X+
     9a8:	3c 91       	ld	r19, X
     9aa:	13 97       	sbiw	r26, 0x03	; 3
     9ac:	24 17       	cp	r18, r20
     9ae:	35 07       	cpc	r19, r21
     9b0:	a8 f3       	brcs	.-22     	; 0x99c <__stack+0x9d>
     9b2:	eb 01       	movw	r28, r22
     9b4:	b9 83       	std	Y+1, r27	; 0x01
     9b6:	a8 83       	st	Y, r26
     9b8:	dc 01       	movw	r26, r24
     9ba:	6d 93       	st	X+, r22
     9bc:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     9be:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     9c2:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     9c6:	22 81       	ldd	r18, Z+2	; 0x02
     9c8:	33 81       	ldd	r19, Z+3	; 0x03
     9ca:	82 1b       	sub	r24, r18
     9cc:	93 0b       	sbc	r25, r19
     9ce:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     9d2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     9d6:	08 c0       	rjmp	.+16     	; 0x9e8 <__stack+0xe9>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     9d8:	00 e0       	ldi	r16, 0x00	; 0
     9da:	10 e0       	ldi	r17, 0x00	; 0
     9dc:	05 c0       	rjmp	.+10     	; 0x9e8 <__stack+0xe9>
     9de:	00 e0       	ldi	r16, 0x00	; 0
     9e0:	10 e0       	ldi	r17, 0x00	; 0
     9e2:	02 c0       	rjmp	.+4      	; 0x9e8 <__stack+0xe9>
     9e4:	00 e0       	ldi	r16, 0x00	; 0
     9e6:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     9e8:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     9ec:	c8 01       	movw	r24, r16
     9ee:	df 91       	pop	r29
     9f0:	cf 91       	pop	r28
     9f2:	1f 91       	pop	r17
     9f4:	0f 91       	pop	r16
     9f6:	08 95       	ret

000009f8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     9f8:	0f 93       	push	r16
     9fa:	1f 93       	push	r17
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	41 f1       	breq	.+80     	; 0xa54 <vPortFree+0x5c>
     a04:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     a06:	8c 01       	movw	r16, r24
     a08:	04 50       	subi	r16, 0x04	; 4
     a0a:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     a0c:	0e 94 55 09 	call	0x12aa	; 0x12aa <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     a10:	f8 01       	movw	r30, r16
     a12:	42 81       	ldd	r20, Z+2	; 0x02
     a14:	53 81       	ldd	r21, Z+3	; 0x03
     a16:	af ea       	ldi	r26, 0xAF	; 175
     a18:	b1 e0       	ldi	r27, 0x01	; 1
     a1a:	01 c0       	rjmp	.+2      	; 0xa1e <vPortFree+0x26>
     a1c:	df 01       	movw	r26, r30
     a1e:	ed 91       	ld	r30, X+
     a20:	fc 91       	ld	r31, X
     a22:	11 97       	sbiw	r26, 0x01	; 1
     a24:	22 81       	ldd	r18, Z+2	; 0x02
     a26:	33 81       	ldd	r19, Z+3	; 0x03
     a28:	24 17       	cp	r18, r20
     a2a:	35 07       	cpc	r19, r21
     a2c:	b8 f3       	brcs	.-18     	; 0xa1c <vPortFree+0x24>
     a2e:	24 97       	sbiw	r28, 0x04	; 4
     a30:	f9 83       	std	Y+1, r31	; 0x01
     a32:	e8 83       	st	Y, r30
     a34:	0d 93       	st	X+, r16
     a36:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     a38:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
     a3c:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
     a40:	8a 81       	ldd	r24, Y+2	; 0x02
     a42:	9b 81       	ldd	r25, Y+3	; 0x03
     a44:	82 0f       	add	r24, r18
     a46:	93 1f       	adc	r25, r19
     a48:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     a4c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     a50:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
	}
}
     a54:	df 91       	pop	r29
     a56:	cf 91       	pop	r28
     a58:	1f 91       	pop	r17
     a5a:	0f 91       	pop	r16
     a5c:	08 95       	ret

00000a5e <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     a5e:	1f 93       	push	r17
     a60:	cf 93       	push	r28
     a62:	df 93       	push	r29
     a64:	ec 01       	movw	r28, r24
     a66:	14 2f       	mov	r17, r20
     a68:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a6a:	41 11       	cpse	r20, r1
     a6c:	0c c0       	rjmp	.+24     	; 0xa86 <prvCopyDataToQueue+0x28>
     a6e:	88 81       	ld	r24, Y
     a70:	99 81       	ldd	r25, Y+1	; 0x01
     a72:	89 2b       	or	r24, r25
     a74:	09 f0       	breq	.+2      	; 0xa78 <prvCopyDataToQueue+0x1a>
     a76:	45 c0       	rjmp	.+138    	; 0xb02 <prvCopyDataToQueue+0xa4>
     a78:	8a 81       	ldd	r24, Y+2	; 0x02
     a7a:	9b 81       	ldd	r25, Y+3	; 0x03
     a7c:	0e 94 ae 0c 	call	0x195c	; 0x195c <xTaskPriorityDisinherit>
     a80:	1b 82       	std	Y+3, r1	; 0x03
     a82:	1a 82       	std	Y+2, r1	; 0x02
     a84:	45 c0       	rjmp	.+138    	; 0xb10 <prvCopyDataToQueue+0xb2>
     a86:	11 11       	cpse	r17, r1
     a88:	17 c0       	rjmp	.+46     	; 0xab8 <prvCopyDataToQueue+0x5a>
     a8a:	50 e0       	ldi	r21, 0x00	; 0
     a8c:	8c 81       	ldd	r24, Y+4	; 0x04
     a8e:	9d 81       	ldd	r25, Y+5	; 0x05
     a90:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <memcpy>
     a94:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a96:	8c 81       	ldd	r24, Y+4	; 0x04
     a98:	9d 81       	ldd	r25, Y+5	; 0x05
     a9a:	82 0f       	add	r24, r18
     a9c:	91 1d       	adc	r25, r1
     a9e:	9d 83       	std	Y+5, r25	; 0x05
     aa0:	8c 83       	std	Y+4, r24	; 0x04
     aa2:	2a 81       	ldd	r18, Y+2	; 0x02
     aa4:	3b 81       	ldd	r19, Y+3	; 0x03
     aa6:	82 17       	cp	r24, r18
     aa8:	93 07       	cpc	r25, r19
     aaa:	68 f1       	brcs	.+90     	; 0xb06 <prvCopyDataToQueue+0xa8>
     aac:	88 81       	ld	r24, Y
     aae:	99 81       	ldd	r25, Y+1	; 0x01
     ab0:	9d 83       	std	Y+5, r25	; 0x05
     ab2:	8c 83       	std	Y+4, r24	; 0x04
     ab4:	80 e0       	ldi	r24, 0x00	; 0
     ab6:	2c c0       	rjmp	.+88     	; 0xb10 <prvCopyDataToQueue+0xb2>
     ab8:	50 e0       	ldi	r21, 0x00	; 0
     aba:	8e 81       	ldd	r24, Y+6	; 0x06
     abc:	9f 81       	ldd	r25, Y+7	; 0x07
     abe:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <memcpy>
     ac2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	91 95       	neg	r25
     ac8:	81 95       	neg	r24
     aca:	91 09       	sbc	r25, r1
     acc:	2e 81       	ldd	r18, Y+6	; 0x06
     ace:	3f 81       	ldd	r19, Y+7	; 0x07
     ad0:	28 0f       	add	r18, r24
     ad2:	39 1f       	adc	r19, r25
     ad4:	3f 83       	std	Y+7, r19	; 0x07
     ad6:	2e 83       	std	Y+6, r18	; 0x06
     ad8:	48 81       	ld	r20, Y
     ada:	59 81       	ldd	r21, Y+1	; 0x01
     adc:	24 17       	cp	r18, r20
     ade:	35 07       	cpc	r19, r21
     ae0:	30 f4       	brcc	.+12     	; 0xaee <prvCopyDataToQueue+0x90>
     ae2:	2a 81       	ldd	r18, Y+2	; 0x02
     ae4:	3b 81       	ldd	r19, Y+3	; 0x03
     ae6:	82 0f       	add	r24, r18
     ae8:	93 1f       	adc	r25, r19
     aea:	9f 83       	std	Y+7, r25	; 0x07
     aec:	8e 83       	std	Y+6, r24	; 0x06
     aee:	12 30       	cpi	r17, 0x02	; 2
     af0:	61 f4       	brne	.+24     	; 0xb0a <prvCopyDataToQueue+0xac>
     af2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     af4:	88 23       	and	r24, r24
     af6:	59 f0       	breq	.+22     	; 0xb0e <prvCopyDataToQueue+0xb0>
     af8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     afa:	81 50       	subi	r24, 0x01	; 1
     afc:	8a 8f       	std	Y+26, r24	; 0x1a
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	07 c0       	rjmp	.+14     	; 0xb10 <prvCopyDataToQueue+0xb2>
     b02:	80 e0       	ldi	r24, 0x00	; 0
     b04:	05 c0       	rjmp	.+10     	; 0xb10 <prvCopyDataToQueue+0xb2>
     b06:	80 e0       	ldi	r24, 0x00	; 0
     b08:	03 c0       	rjmp	.+6      	; 0xb10 <prvCopyDataToQueue+0xb2>
     b0a:	80 e0       	ldi	r24, 0x00	; 0
     b0c:	01 c0       	rjmp	.+2      	; 0xb10 <prvCopyDataToQueue+0xb2>
     b0e:	80 e0       	ldi	r24, 0x00	; 0
     b10:	9a 8d       	ldd	r25, Y+26	; 0x1a
     b12:	9f 5f       	subi	r25, 0xFF	; 255
     b14:	9a 8f       	std	Y+26, r25	; 0x1a
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	1f 91       	pop	r17
     b1c:	08 95       	ret

00000b1e <prvCopyDataFromQueue>:
     b1e:	fc 01       	movw	r30, r24
     b20:	44 8d       	ldd	r20, Z+28	; 0x1c
     b22:	44 23       	and	r20, r20
     b24:	a9 f0       	breq	.+42     	; 0xb50 <prvCopyDataFromQueue+0x32>
     b26:	50 e0       	ldi	r21, 0x00	; 0
     b28:	26 81       	ldd	r18, Z+6	; 0x06
     b2a:	37 81       	ldd	r19, Z+7	; 0x07
     b2c:	24 0f       	add	r18, r20
     b2e:	35 1f       	adc	r19, r21
     b30:	37 83       	std	Z+7, r19	; 0x07
     b32:	26 83       	std	Z+6, r18	; 0x06
     b34:	82 81       	ldd	r24, Z+2	; 0x02
     b36:	93 81       	ldd	r25, Z+3	; 0x03
     b38:	28 17       	cp	r18, r24
     b3a:	39 07       	cpc	r19, r25
     b3c:	20 f0       	brcs	.+8      	; 0xb46 <prvCopyDataFromQueue+0x28>
     b3e:	80 81       	ld	r24, Z
     b40:	91 81       	ldd	r25, Z+1	; 0x01
     b42:	97 83       	std	Z+7, r25	; 0x07
     b44:	86 83       	std	Z+6, r24	; 0x06
     b46:	cb 01       	movw	r24, r22
     b48:	66 81       	ldd	r22, Z+6	; 0x06
     b4a:	77 81       	ldd	r23, Z+7	; 0x07
     b4c:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <memcpy>
     b50:	08 95       	ret

00000b52 <prvUnlockQueue>:
     b52:	0f 93       	push	r16
     b54:	1f 93       	push	r17
     b56:	cf 93       	push	r28
     b58:	df 93       	push	r29
     b5a:	ec 01       	movw	r28, r24
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	0f 92       	push	r0
     b62:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b64:	18 16       	cp	r1, r24
     b66:	bc f4       	brge	.+46     	; 0xb96 <prvUnlockQueue+0x44>
     b68:	89 89       	ldd	r24, Y+17	; 0x11
     b6a:	81 11       	cpse	r24, r1
     b6c:	05 c0       	rjmp	.+10     	; 0xb78 <prvUnlockQueue+0x26>
     b6e:	13 c0       	rjmp	.+38     	; 0xb96 <prvUnlockQueue+0x44>
     b70:	89 89       	ldd	r24, Y+17	; 0x11
     b72:	81 11       	cpse	r24, r1
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <prvUnlockQueue+0x2c>
     b76:	0f c0       	rjmp	.+30     	; 0xb96 <prvUnlockQueue+0x44>
     b78:	8e 01       	movw	r16, r28
     b7a:	0f 5e       	subi	r16, 0xEF	; 239
     b7c:	1f 4f       	sbci	r17, 0xFF	; 255
     b7e:	c8 01       	movw	r24, r16
     b80:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskRemoveFromEventList>
     b84:	81 11       	cpse	r24, r1
     b86:	0e 94 48 0c 	call	0x1890	; 0x1890 <vTaskMissedYield>
     b8a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b8c:	81 50       	subi	r24, 0x01	; 1
     b8e:	8e 8f       	std	Y+30, r24	; 0x1e
     b90:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b92:	18 16       	cp	r1, r24
     b94:	6c f3       	brlt	.-38     	; 0xb70 <prvUnlockQueue+0x1e>
     b96:	8f ef       	ldi	r24, 0xFF	; 255
     b98:	8e 8f       	std	Y+30, r24	; 0x1e
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63
     b9e:	0f b6       	in	r0, 0x3f	; 63
     ba0:	f8 94       	cli
     ba2:	0f 92       	push	r0
     ba4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ba6:	18 16       	cp	r1, r24
     ba8:	bc f4       	brge	.+46     	; 0xbd8 <prvUnlockQueue+0x86>
     baa:	88 85       	ldd	r24, Y+8	; 0x08
     bac:	81 11       	cpse	r24, r1
     bae:	05 c0       	rjmp	.+10     	; 0xbba <prvUnlockQueue+0x68>
     bb0:	13 c0       	rjmp	.+38     	; 0xbd8 <prvUnlockQueue+0x86>
     bb2:	88 85       	ldd	r24, Y+8	; 0x08
     bb4:	81 11       	cpse	r24, r1
     bb6:	04 c0       	rjmp	.+8      	; 0xbc0 <prvUnlockQueue+0x6e>
     bb8:	0f c0       	rjmp	.+30     	; 0xbd8 <prvUnlockQueue+0x86>
     bba:	8e 01       	movw	r16, r28
     bbc:	08 5f       	subi	r16, 0xF8	; 248
     bbe:	1f 4f       	sbci	r17, 0xFF	; 255
     bc0:	c8 01       	movw	r24, r16
     bc2:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskRemoveFromEventList>
     bc6:	81 11       	cpse	r24, r1
     bc8:	0e 94 48 0c 	call	0x1890	; 0x1890 <vTaskMissedYield>
     bcc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     bce:	81 50       	subi	r24, 0x01	; 1
     bd0:	8d 8f       	std	Y+29, r24	; 0x1d
     bd2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     bd4:	18 16       	cp	r1, r24
     bd6:	6c f3       	brlt	.-38     	; 0xbb2 <prvUnlockQueue+0x60>
     bd8:	8f ef       	ldi	r24, 0xFF	; 255
     bda:	8d 8f       	std	Y+29, r24	; 0x1d
     bdc:	0f 90       	pop	r0
     bde:	0f be       	out	0x3f, r0	; 63
     be0:	df 91       	pop	r29
     be2:	cf 91       	pop	r28
     be4:	1f 91       	pop	r17
     be6:	0f 91       	pop	r16
     be8:	08 95       	ret

00000bea <xQueueGenericReset>:
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
     bee:	ec 01       	movw	r28, r24
     bf0:	0f b6       	in	r0, 0x3f	; 63
     bf2:	f8 94       	cli
     bf4:	0f 92       	push	r0
     bf6:	48 81       	ld	r20, Y
     bf8:	59 81       	ldd	r21, Y+1	; 0x01
     bfa:	2c 8d       	ldd	r18, Y+28	; 0x1c
     bfc:	30 e0       	ldi	r19, 0x00	; 0
     bfe:	7b 8d       	ldd	r23, Y+27	; 0x1b
     c00:	72 9f       	mul	r23, r18
     c02:	c0 01       	movw	r24, r0
     c04:	73 9f       	mul	r23, r19
     c06:	90 0d       	add	r25, r0
     c08:	11 24       	eor	r1, r1
     c0a:	fa 01       	movw	r30, r20
     c0c:	e8 0f       	add	r30, r24
     c0e:	f9 1f       	adc	r31, r25
     c10:	fb 83       	std	Y+3, r31	; 0x03
     c12:	ea 83       	std	Y+2, r30	; 0x02
     c14:	1a 8e       	std	Y+26, r1	; 0x1a
     c16:	5d 83       	std	Y+5, r21	; 0x05
     c18:	4c 83       	std	Y+4, r20	; 0x04
     c1a:	82 1b       	sub	r24, r18
     c1c:	93 0b       	sbc	r25, r19
     c1e:	84 0f       	add	r24, r20
     c20:	95 1f       	adc	r25, r21
     c22:	9f 83       	std	Y+7, r25	; 0x07
     c24:	8e 83       	std	Y+6, r24	; 0x06
     c26:	8f ef       	ldi	r24, 0xFF	; 255
     c28:	8d 8f       	std	Y+29, r24	; 0x1d
     c2a:	8e 8f       	std	Y+30, r24	; 0x1e
     c2c:	61 11       	cpse	r22, r1
     c2e:	0c c0       	rjmp	.+24     	; 0xc48 <xQueueGenericReset+0x5e>
     c30:	88 85       	ldd	r24, Y+8	; 0x08
     c32:	88 23       	and	r24, r24
     c34:	89 f0       	breq	.+34     	; 0xc58 <xQueueGenericReset+0x6e>
     c36:	ce 01       	movw	r24, r28
     c38:	08 96       	adiw	r24, 0x08	; 8
     c3a:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskRemoveFromEventList>
     c3e:	81 30       	cpi	r24, 0x01	; 1
     c40:	59 f4       	brne	.+22     	; 0xc58 <xQueueGenericReset+0x6e>
     c42:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
     c46:	08 c0       	rjmp	.+16     	; 0xc58 <xQueueGenericReset+0x6e>
     c48:	ce 01       	movw	r24, r28
     c4a:	08 96       	adiw	r24, 0x08	; 8
     c4c:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
     c50:	ce 01       	movw	r24, r28
     c52:	41 96       	adiw	r24, 0x11	; 17
     c54:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
     c58:	0f 90       	pop	r0
     c5a:	0f be       	out	0x3f, r0	; 63
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	df 91       	pop	r29
     c60:	cf 91       	pop	r28
     c62:	08 95       	ret

00000c64 <xQueueGenericCreate>:
     c64:	0f 93       	push	r16
     c66:	1f 93       	push	r17
     c68:	cf 93       	push	r28
     c6a:	df 93       	push	r29
     c6c:	08 2f       	mov	r16, r24
     c6e:	16 2f       	mov	r17, r22
     c70:	66 23       	and	r22, r22
     c72:	b9 f0       	breq	.+46     	; 0xca2 <xQueueGenericCreate+0x3e>
     c74:	86 9f       	mul	r24, r22
     c76:	c0 01       	movw	r24, r0
     c78:	11 24       	eor	r1, r1
     c7a:	80 96       	adiw	r24, 0x20	; 32
     c7c:	0e 94 62 04 	call	0x8c4	; 0x8c4 <pvPortMalloc>
     c80:	ec 01       	movw	r28, r24
     c82:	00 97       	sbiw	r24, 0x00	; 0
     c84:	21 f4       	brne	.+8      	; 0xc8e <xQueueGenericCreate+0x2a>
     c86:	14 c0       	rjmp	.+40     	; 0xcb0 <xQueueGenericCreate+0x4c>
     c88:	d9 83       	std	Y+1, r29	; 0x01
     c8a:	c8 83       	st	Y, r28
     c8c:	03 c0       	rjmp	.+6      	; 0xc94 <xQueueGenericCreate+0x30>
     c8e:	4f 96       	adiw	r24, 0x1f	; 31
     c90:	99 83       	std	Y+1, r25	; 0x01
     c92:	88 83       	st	Y, r24
     c94:	0b 8f       	std	Y+27, r16	; 0x1b
     c96:	1c 8f       	std	Y+28, r17	; 0x1c
     c98:	61 e0       	ldi	r22, 0x01	; 1
     c9a:	ce 01       	movw	r24, r28
     c9c:	0e 94 f5 05 	call	0xbea	; 0xbea <xQueueGenericReset>
     ca0:	07 c0       	rjmp	.+14     	; 0xcb0 <xQueueGenericCreate+0x4c>
     ca2:	8f e1       	ldi	r24, 0x1F	; 31
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	0e 94 62 04 	call	0x8c4	; 0x8c4 <pvPortMalloc>
     caa:	ec 01       	movw	r28, r24
     cac:	89 2b       	or	r24, r25
     cae:	61 f7       	brne	.-40     	; 0xc88 <xQueueGenericCreate+0x24>
     cb0:	ce 01       	movw	r24, r28
     cb2:	df 91       	pop	r29
     cb4:	cf 91       	pop	r28
     cb6:	1f 91       	pop	r17
     cb8:	0f 91       	pop	r16
     cba:	08 95       	ret

00000cbc <xQueueGenericSend>:
     cbc:	9f 92       	push	r9
     cbe:	af 92       	push	r10
     cc0:	bf 92       	push	r11
     cc2:	cf 92       	push	r12
     cc4:	df 92       	push	r13
     cc6:	ef 92       	push	r14
     cc8:	ff 92       	push	r15
     cca:	0f 93       	push	r16
     ccc:	1f 93       	push	r17
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	00 d0       	rcall	.+0      	; 0xcd4 <xQueueGenericSend+0x18>
     cd4:	00 d0       	rcall	.+0      	; 0xcd6 <xQueueGenericSend+0x1a>
     cd6:	1f 92       	push	r1
     cd8:	cd b7       	in	r28, 0x3d	; 61
     cda:	de b7       	in	r29, 0x3e	; 62
     cdc:	8c 01       	movw	r16, r24
     cde:	6b 01       	movw	r12, r22
     ce0:	5d 83       	std	Y+5, r21	; 0x05
     ce2:	4c 83       	std	Y+4, r20	; 0x04
     ce4:	a2 2e       	mov	r10, r18
     ce6:	b1 2c       	mov	r11, r1
     ce8:	99 24       	eor	r9, r9
     cea:	93 94       	inc	r9
     cec:	7c 01       	movw	r14, r24
     cee:	88 e0       	ldi	r24, 0x08	; 8
     cf0:	e8 0e       	add	r14, r24
     cf2:	f1 1c       	adc	r15, r1
     cf4:	0f b6       	in	r0, 0x3f	; 63
     cf6:	f8 94       	cli
     cf8:	0f 92       	push	r0
     cfa:	f8 01       	movw	r30, r16
     cfc:	92 8d       	ldd	r25, Z+26	; 0x1a
     cfe:	83 8d       	ldd	r24, Z+27	; 0x1b
     d00:	98 17       	cp	r25, r24
     d02:	18 f0       	brcs	.+6      	; 0xd0a <xQueueGenericSend+0x4e>
     d04:	f2 e0       	ldi	r31, 0x02	; 2
     d06:	af 12       	cpse	r10, r31
     d08:	19 c0       	rjmp	.+50     	; 0xd3c <xQueueGenericSend+0x80>
     d0a:	4a 2d       	mov	r20, r10
     d0c:	b6 01       	movw	r22, r12
     d0e:	c8 01       	movw	r24, r16
     d10:	0e 94 2f 05 	call	0xa5e	; 0xa5e <prvCopyDataToQueue>
     d14:	f8 01       	movw	r30, r16
     d16:	91 89       	ldd	r25, Z+17	; 0x11
     d18:	99 23       	and	r25, r25
     d1a:	49 f0       	breq	.+18     	; 0xd2e <xQueueGenericSend+0x72>
     d1c:	c8 01       	movw	r24, r16
     d1e:	41 96       	adiw	r24, 0x11	; 17
     d20:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskRemoveFromEventList>
     d24:	81 30       	cpi	r24, 0x01	; 1
     d26:	31 f4       	brne	.+12     	; 0xd34 <xQueueGenericSend+0x78>
     d28:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
     d2c:	03 c0       	rjmp	.+6      	; 0xd34 <xQueueGenericSend+0x78>
     d2e:	81 11       	cpse	r24, r1
     d30:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
     d34:	0f 90       	pop	r0
     d36:	0f be       	out	0x3f, r0	; 63
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	50 c0       	rjmp	.+160    	; 0xddc <xQueueGenericSend+0x120>
     d3c:	8c 81       	ldd	r24, Y+4	; 0x04
     d3e:	9d 81       	ldd	r25, Y+5	; 0x05
     d40:	89 2b       	or	r24, r25
     d42:	21 f4       	brne	.+8      	; 0xd4c <xQueueGenericSend+0x90>
     d44:	0f 90       	pop	r0
     d46:	0f be       	out	0x3f, r0	; 63
     d48:	80 e0       	ldi	r24, 0x00	; 0
     d4a:	48 c0       	rjmp	.+144    	; 0xddc <xQueueGenericSend+0x120>
     d4c:	b1 10       	cpse	r11, r1
     d4e:	05 c0       	rjmp	.+10     	; 0xd5a <xQueueGenericSend+0x9e>
     d50:	ce 01       	movw	r24, r28
     d52:	01 96       	adiw	r24, 0x01	; 1
     d54:	0e 94 04 0c 	call	0x1808	; 0x1808 <vTaskSetTimeOutState>
     d58:	b9 2c       	mov	r11, r9
     d5a:	0f 90       	pop	r0
     d5c:	0f be       	out	0x3f, r0	; 63
     d5e:	0e 94 55 09 	call	0x12aa	; 0x12aa <vTaskSuspendAll>
     d62:	0f b6       	in	r0, 0x3f	; 63
     d64:	f8 94       	cli
     d66:	0f 92       	push	r0
     d68:	f8 01       	movw	r30, r16
     d6a:	85 8d       	ldd	r24, Z+29	; 0x1d
     d6c:	8f 3f       	cpi	r24, 0xFF	; 255
     d6e:	09 f4       	brne	.+2      	; 0xd72 <xQueueGenericSend+0xb6>
     d70:	15 8e       	std	Z+29, r1	; 0x1d
     d72:	f8 01       	movw	r30, r16
     d74:	86 8d       	ldd	r24, Z+30	; 0x1e
     d76:	8f 3f       	cpi	r24, 0xFF	; 255
     d78:	09 f4       	brne	.+2      	; 0xd7c <xQueueGenericSend+0xc0>
     d7a:	16 8e       	std	Z+30, r1	; 0x1e
     d7c:	0f 90       	pop	r0
     d7e:	0f be       	out	0x3f, r0	; 63
     d80:	be 01       	movw	r22, r28
     d82:	6c 5f       	subi	r22, 0xFC	; 252
     d84:	7f 4f       	sbci	r23, 0xFF	; 255
     d86:	ce 01       	movw	r24, r28
     d88:	01 96       	adiw	r24, 0x01	; 1
     d8a:	0e 94 0f 0c 	call	0x181e	; 0x181e <xTaskCheckForTimeOut>
     d8e:	81 11       	cpse	r24, r1
     d90:	1f c0       	rjmp	.+62     	; 0xdd0 <xQueueGenericSend+0x114>
     d92:	0f b6       	in	r0, 0x3f	; 63
     d94:	f8 94       	cli
     d96:	0f 92       	push	r0
     d98:	f8 01       	movw	r30, r16
     d9a:	92 8d       	ldd	r25, Z+26	; 0x1a
     d9c:	0f 90       	pop	r0
     d9e:	0f be       	out	0x3f, r0	; 63
     da0:	83 8d       	ldd	r24, Z+27	; 0x1b
     da2:	98 13       	cpse	r25, r24
     da4:	0f c0       	rjmp	.+30     	; 0xdc4 <xQueueGenericSend+0x108>
     da6:	6c 81       	ldd	r22, Y+4	; 0x04
     da8:	7d 81       	ldd	r23, Y+5	; 0x05
     daa:	c7 01       	movw	r24, r14
     dac:	0e 94 90 0b 	call	0x1720	; 0x1720 <vTaskPlaceOnEventList>
     db0:	c8 01       	movw	r24, r16
     db2:	0e 94 a9 05 	call	0xb52	; 0xb52 <prvUnlockQueue>
     db6:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
     dba:	81 11       	cpse	r24, r1
     dbc:	9b cf       	rjmp	.-202    	; 0xcf4 <xQueueGenericSend+0x38>
     dbe:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
     dc2:	98 cf       	rjmp	.-208    	; 0xcf4 <xQueueGenericSend+0x38>
     dc4:	c8 01       	movw	r24, r16
     dc6:	0e 94 a9 05 	call	0xb52	; 0xb52 <prvUnlockQueue>
     dca:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
     dce:	92 cf       	rjmp	.-220    	; 0xcf4 <xQueueGenericSend+0x38>
     dd0:	c8 01       	movw	r24, r16
     dd2:	0e 94 a9 05 	call	0xb52	; 0xb52 <prvUnlockQueue>
     dd6:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	0f 90       	pop	r0
     dde:	0f 90       	pop	r0
     de0:	0f 90       	pop	r0
     de2:	0f 90       	pop	r0
     de4:	0f 90       	pop	r0
     de6:	df 91       	pop	r29
     de8:	cf 91       	pop	r28
     dea:	1f 91       	pop	r17
     dec:	0f 91       	pop	r16
     dee:	ff 90       	pop	r15
     df0:	ef 90       	pop	r14
     df2:	df 90       	pop	r13
     df4:	cf 90       	pop	r12
     df6:	bf 90       	pop	r11
     df8:	af 90       	pop	r10
     dfa:	9f 90       	pop	r9
     dfc:	08 95       	ret

00000dfe <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     dfe:	9f 92       	push	r9
     e00:	af 92       	push	r10
     e02:	bf 92       	push	r11
     e04:	cf 92       	push	r12
     e06:	df 92       	push	r13
     e08:	ef 92       	push	r14
     e0a:	ff 92       	push	r15
     e0c:	0f 93       	push	r16
     e0e:	1f 93       	push	r17
     e10:	cf 93       	push	r28
     e12:	df 93       	push	r29
     e14:	00 d0       	rcall	.+0      	; 0xe16 <xQueueGenericReceive+0x18>
     e16:	00 d0       	rcall	.+0      	; 0xe18 <xQueueGenericReceive+0x1a>
     e18:	1f 92       	push	r1
     e1a:	cd b7       	in	r28, 0x3d	; 61
     e1c:	de b7       	in	r29, 0x3e	; 62
     e1e:	8c 01       	movw	r16, r24
     e20:	6b 01       	movw	r12, r22
     e22:	5d 83       	std	Y+5, r21	; 0x05
     e24:	4c 83       	std	Y+4, r20	; 0x04
     e26:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE;
     e28:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     e2a:	aa 24       	eor	r10, r10
     e2c:	a3 94       	inc	r10
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e2e:	7c 01       	movw	r14, r24
     e30:	81 e1       	ldi	r24, 0x11	; 17
     e32:	e8 0e       	add	r14, r24
     e34:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     e36:	0f b6       	in	r0, 0x3f	; 63
     e38:	f8 94       	cli
     e3a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     e3c:	f8 01       	movw	r30, r16
     e3e:	82 8d       	ldd	r24, Z+26	; 0x1a
     e40:	88 23       	and	r24, r24
     e42:	99 f1       	breq	.+102    	; 0xeaa <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     e44:	e6 80       	ldd	r14, Z+6	; 0x06
     e46:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     e48:	b6 01       	movw	r22, r12
     e4a:	c8 01       	movw	r24, r16
     e4c:	0e 94 8f 05 	call	0xb1e	; 0xb1e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     e50:	91 10       	cpse	r9, r1
     e52:	1a c0       	rjmp	.+52     	; 0xe88 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     e54:	f8 01       	movw	r30, r16
     e56:	82 8d       	ldd	r24, Z+26	; 0x1a
     e58:	81 50       	subi	r24, 0x01	; 1
     e5a:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e5c:	80 81       	ld	r24, Z
     e5e:	91 81       	ldd	r25, Z+1	; 0x01
     e60:	89 2b       	or	r24, r25
     e62:	29 f4       	brne	.+10     	; 0xe6e <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     e64:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <pvTaskIncrementMutexHeldCount>
     e68:	f8 01       	movw	r30, r16
     e6a:	93 83       	std	Z+3, r25	; 0x03
     e6c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e6e:	f8 01       	movw	r30, r16
     e70:	80 85       	ldd	r24, Z+8	; 0x08
     e72:	88 23       	and	r24, r24
     e74:	b1 f0       	breq	.+44     	; 0xea2 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     e76:	c8 01       	movw	r24, r16
     e78:	08 96       	adiw	r24, 0x08	; 8
     e7a:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskRemoveFromEventList>
     e7e:	81 30       	cpi	r24, 0x01	; 1
     e80:	81 f4       	brne	.+32     	; 0xea2 <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     e82:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
     e86:	0d c0       	rjmp	.+26     	; 0xea2 <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     e88:	f8 01       	movw	r30, r16
     e8a:	f7 82       	std	Z+7, r15	; 0x07
     e8c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e8e:	81 89       	ldd	r24, Z+17	; 0x11
     e90:	88 23       	and	r24, r24
     e92:	39 f0       	breq	.+14     	; 0xea2 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e94:	c8 01       	movw	r24, r16
     e96:	41 96       	adiw	r24, 0x11	; 17
     e98:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskRemoveFromEventList>
     e9c:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     e9e:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     ea2:	0f 90       	pop	r0
     ea4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     ea6:	81 e0       	ldi	r24, 0x01	; 1
     ea8:	5c c0       	rjmp	.+184    	; 0xf62 <xQueueGenericReceive+0x164>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     eaa:	8c 81       	ldd	r24, Y+4	; 0x04
     eac:	9d 81       	ldd	r25, Y+5	; 0x05
     eae:	89 2b       	or	r24, r25
     eb0:	21 f4       	brne	.+8      	; 0xeba <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     eb2:	0f 90       	pop	r0
     eb4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     eb6:	80 e0       	ldi	r24, 0x00	; 0
     eb8:	54 c0       	rjmp	.+168    	; 0xf62 <xQueueGenericReceive+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
     eba:	b1 10       	cpse	r11, r1
     ebc:	05 c0       	rjmp	.+10     	; 0xec8 <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     ebe:	ce 01       	movw	r24, r28
     ec0:	01 96       	adiw	r24, 0x01	; 1
     ec2:	0e 94 04 0c 	call	0x1808	; 0x1808 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     ec6:	ba 2c       	mov	r11, r10
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     ec8:	0f 90       	pop	r0
     eca:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     ecc:	0e 94 55 09 	call	0x12aa	; 0x12aa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ed0:	0f b6       	in	r0, 0x3f	; 63
     ed2:	f8 94       	cli
     ed4:	0f 92       	push	r0
     ed6:	f8 01       	movw	r30, r16
     ed8:	85 8d       	ldd	r24, Z+29	; 0x1d
     eda:	8f 3f       	cpi	r24, 0xFF	; 255
     edc:	09 f4       	brne	.+2      	; 0xee0 <xQueueGenericReceive+0xe2>
     ede:	15 8e       	std	Z+29, r1	; 0x1d
     ee0:	f8 01       	movw	r30, r16
     ee2:	86 8d       	ldd	r24, Z+30	; 0x1e
     ee4:	8f 3f       	cpi	r24, 0xFF	; 255
     ee6:	09 f4       	brne	.+2      	; 0xeea <xQueueGenericReceive+0xec>
     ee8:	16 8e       	std	Z+30, r1	; 0x1e
     eea:	0f 90       	pop	r0
     eec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     eee:	be 01       	movw	r22, r28
     ef0:	6c 5f       	subi	r22, 0xFC	; 252
     ef2:	7f 4f       	sbci	r23, 0xFF	; 255
     ef4:	ce 01       	movw	r24, r28
     ef6:	01 96       	adiw	r24, 0x01	; 1
     ef8:	0e 94 0f 0c 	call	0x181e	; 0x181e <xTaskCheckForTimeOut>
     efc:	81 11       	cpse	r24, r1
     efe:	2b c0       	rjmp	.+86     	; 0xf56 <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     f00:	0f b6       	in	r0, 0x3f	; 63
     f02:	f8 94       	cli
     f04:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     f06:	f8 01       	movw	r30, r16
     f08:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     f0a:	0f 90       	pop	r0
     f0c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f0e:	81 11       	cpse	r24, r1
     f10:	1c c0       	rjmp	.+56     	; 0xf4a <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     f12:	80 81       	ld	r24, Z
     f14:	91 81       	ldd	r25, Z+1	; 0x01
     f16:	89 2b       	or	r24, r25
     f18:	49 f4       	brne	.+18     	; 0xf2c <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
     f1a:	0f b6       	in	r0, 0x3f	; 63
     f1c:	f8 94       	cli
     f1e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     f20:	82 81       	ldd	r24, Z+2	; 0x02
     f22:	93 81       	ldd	r25, Z+3	; 0x03
     f24:	0e 94 4c 0c 	call	0x1898	; 0x1898 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     f28:	0f 90       	pop	r0
     f2a:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f2c:	6c 81       	ldd	r22, Y+4	; 0x04
     f2e:	7d 81       	ldd	r23, Y+5	; 0x05
     f30:	c7 01       	movw	r24, r14
     f32:	0e 94 90 0b 	call	0x1720	; 0x1720 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     f36:	c8 01       	movw	r24, r16
     f38:	0e 94 a9 05 	call	0xb52	; 0xb52 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     f3c:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
     f40:	81 11       	cpse	r24, r1
     f42:	79 cf       	rjmp	.-270    	; 0xe36 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     f44:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
     f48:	76 cf       	rjmp	.-276    	; 0xe36 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f4a:	c8 01       	movw	r24, r16
     f4c:	0e 94 a9 05 	call	0xb52	; 0xb52 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f50:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
     f54:	70 cf       	rjmp	.-288    	; 0xe36 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     f56:	c8 01       	movw	r24, r16
     f58:	0e 94 a9 05 	call	0xb52	; 0xb52 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f5c:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     f60:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     f62:	0f 90       	pop	r0
     f64:	0f 90       	pop	r0
     f66:	0f 90       	pop	r0
     f68:	0f 90       	pop	r0
     f6a:	0f 90       	pop	r0
     f6c:	df 91       	pop	r29
     f6e:	cf 91       	pop	r28
     f70:	1f 91       	pop	r17
     f72:	0f 91       	pop	r16
     f74:	ff 90       	pop	r15
     f76:	ef 90       	pop	r14
     f78:	df 90       	pop	r13
     f7a:	cf 90       	pop	r12
     f7c:	bf 90       	pop	r11
     f7e:	af 90       	pop	r10
     f80:	9f 90       	pop	r9
     f82:	08 95       	ret

00000f84 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     f84:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
     f88:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
     f8c:	80 81       	ld	r24, Z
     f8e:	81 11       	cpse	r24, r1
     f90:	07 c0       	rjmp	.+14     	; 0xfa0 <prvResetNextTaskUnblockTime+0x1c>
     f92:	8f ef       	ldi	r24, 0xFF	; 255
     f94:	9f ef       	ldi	r25, 0xFF	; 255
     f96:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     f9a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     f9e:	08 95       	ret
     fa0:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
     fa4:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
     fa8:	05 80       	ldd	r0, Z+5	; 0x05
     faa:	f6 81       	ldd	r31, Z+6	; 0x06
     fac:	e0 2d       	mov	r30, r0
     fae:	06 80       	ldd	r0, Z+6	; 0x06
     fb0:	f7 81       	ldd	r31, Z+7	; 0x07
     fb2:	e0 2d       	mov	r30, r0
     fb4:	82 81       	ldd	r24, Z+2	; 0x02
     fb6:	93 81       	ldd	r25, Z+3	; 0x03
     fb8:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     fbc:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     fc0:	08 95       	ret

00000fc2 <prvAddCurrentTaskToDelayedList>:
     fc2:	cf 93       	push	r28
     fc4:	df 93       	push	r29
     fc6:	ec 01       	movw	r28, r24
     fc8:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     fcc:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     fd0:	93 83       	std	Z+3, r25	; 0x03
     fd2:	82 83       	std	Z+2, r24	; 0x02
     fd4:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
     fd8:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
     fdc:	c8 17       	cp	r28, r24
     fde:	d9 07       	cpc	r29, r25
     fe0:	68 f4       	brcc	.+26     	; 0xffc <prvAddCurrentTaskToDelayedList+0x3a>
     fe2:	60 91 e8 07 	lds	r22, 0x07E8	; 0x8007e8 <pxCurrentTCB>
     fe6:	70 91 e9 07 	lds	r23, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
     fea:	80 91 b7 07 	lds	r24, 0x07B7	; 0x8007b7 <pxOverflowDelayedTaskList>
     fee:	90 91 b8 07 	lds	r25, 0x07B8	; 0x8007b8 <pxOverflowDelayedTaskList+0x1>
     ff2:	6e 5f       	subi	r22, 0xFE	; 254
     ff4:	7f 4f       	sbci	r23, 0xFF	; 255
     ff6:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsert>
     ffa:	17 c0       	rjmp	.+46     	; 0x102a <prvAddCurrentTaskToDelayedList+0x68>
     ffc:	60 91 e8 07 	lds	r22, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1000:	70 91 e9 07 	lds	r23, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1004:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
    1008:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
    100c:	6e 5f       	subi	r22, 0xFE	; 254
    100e:	7f 4f       	sbci	r23, 0xFF	; 255
    1010:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsert>
    1014:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
    1018:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
    101c:	c8 17       	cp	r28, r24
    101e:	d9 07       	cpc	r29, r25
    1020:	20 f4       	brcc	.+8      	; 0x102a <prvAddCurrentTaskToDelayedList+0x68>
    1022:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <xNextTaskUnblockTime+0x1>
    1026:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <xNextTaskUnblockTime>
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	08 95       	ret

00001030 <xTaskGenericCreate>:
    1030:	4f 92       	push	r4
    1032:	5f 92       	push	r5
    1034:	6f 92       	push	r6
    1036:	7f 92       	push	r7
    1038:	8f 92       	push	r8
    103a:	9f 92       	push	r9
    103c:	af 92       	push	r10
    103e:	bf 92       	push	r11
    1040:	cf 92       	push	r12
    1042:	df 92       	push	r13
    1044:	ef 92       	push	r14
    1046:	ff 92       	push	r15
    1048:	0f 93       	push	r16
    104a:	1f 93       	push	r17
    104c:	cf 93       	push	r28
    104e:	df 93       	push	r29
    1050:	4c 01       	movw	r8, r24
    1052:	eb 01       	movw	r28, r22
    1054:	5a 01       	movw	r10, r20
    1056:	29 01       	movw	r4, r18
    1058:	c1 14       	cp	r12, r1
    105a:	d1 04       	cpc	r13, r1
    105c:	39 f4       	brne	.+14     	; 0x106c <xTaskGenericCreate+0x3c>
    105e:	ca 01       	movw	r24, r20
    1060:	0e 94 62 04 	call	0x8c4	; 0x8c4 <pvPortMalloc>
    1064:	6c 01       	movw	r12, r24
    1066:	89 2b       	or	r24, r25
    1068:	09 f4       	brne	.+2      	; 0x106c <xTaskGenericCreate+0x3c>
    106a:	de c0       	rjmp	.+444    	; 0x1228 <xTaskGenericCreate+0x1f8>
    106c:	88 e2       	ldi	r24, 0x28	; 40
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	0e 94 62 04 	call	0x8c4	; 0x8c4 <pvPortMalloc>
    1074:	3c 01       	movw	r6, r24
    1076:	00 97       	sbiw	r24, 0x00	; 0
    1078:	79 f0       	breq	.+30     	; 0x1098 <xTaskGenericCreate+0x68>
    107a:	fc 01       	movw	r30, r24
    107c:	d0 8e       	std	Z+24, r13	; 0x18
    107e:	c7 8a       	std	Z+23, r12	; 0x17
    1080:	f1 e0       	ldi	r31, 0x01	; 1
    1082:	af 1a       	sub	r10, r31
    1084:	b1 08       	sbc	r11, r1
    1086:	ca 0c       	add	r12, r10
    1088:	db 1c       	adc	r13, r11
    108a:	88 81       	ld	r24, Y
    108c:	f3 01       	movw	r30, r6
    108e:	81 8f       	std	Z+25, r24	; 0x19
    1090:	88 81       	ld	r24, Y
    1092:	81 11       	cpse	r24, r1
    1094:	05 c0       	rjmp	.+10     	; 0x10a0 <xTaskGenericCreate+0x70>
    1096:	14 c0       	rjmp	.+40     	; 0x10c0 <xTaskGenericCreate+0x90>
    1098:	c6 01       	movw	r24, r12
    109a:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <vPortFree>
    109e:	c4 c0       	rjmp	.+392    	; 0x1228 <xTaskGenericCreate+0x1f8>
    10a0:	d3 01       	movw	r26, r6
    10a2:	5a 96       	adiw	r26, 0x1a	; 26
    10a4:	fe 01       	movw	r30, r28
    10a6:	31 96       	adiw	r30, 0x01	; 1
    10a8:	9e 01       	movw	r18, r28
    10aa:	28 5f       	subi	r18, 0xF8	; 248
    10ac:	3f 4f       	sbci	r19, 0xFF	; 255
    10ae:	ef 01       	movw	r28, r30
    10b0:	81 91       	ld	r24, Z+
    10b2:	8d 93       	st	X+, r24
    10b4:	88 81       	ld	r24, Y
    10b6:	88 23       	and	r24, r24
    10b8:	19 f0       	breq	.+6      	; 0x10c0 <xTaskGenericCreate+0x90>
    10ba:	e2 17       	cp	r30, r18
    10bc:	f3 07       	cpc	r31, r19
    10be:	b9 f7       	brne	.-18     	; 0x10ae <xTaskGenericCreate+0x7e>
    10c0:	f3 01       	movw	r30, r6
    10c2:	10 a2       	std	Z+32, r1	; 0x20
    10c4:	10 2f       	mov	r17, r16
    10c6:	03 30       	cpi	r16, 0x03	; 3
    10c8:	08 f0       	brcs	.+2      	; 0x10cc <xTaskGenericCreate+0x9c>
    10ca:	12 e0       	ldi	r17, 0x02	; 2
    10cc:	f3 01       	movw	r30, r6
    10ce:	16 8b       	std	Z+22, r17	; 0x16
    10d0:	11 a3       	std	Z+33, r17	; 0x21
    10d2:	12 a2       	std	Z+34, r1	; 0x22
    10d4:	e3 01       	movw	r28, r6
    10d6:	22 96       	adiw	r28, 0x02	; 2
    10d8:	ce 01       	movw	r24, r28
    10da:	0e 94 88 02 	call	0x510	; 0x510 <vListInitialiseItem>
    10de:	c3 01       	movw	r24, r6
    10e0:	0c 96       	adiw	r24, 0x0c	; 12
    10e2:	0e 94 88 02 	call	0x510	; 0x510 <vListInitialiseItem>
    10e6:	f3 01       	movw	r30, r6
    10e8:	71 86       	std	Z+9, r7	; 0x09
    10ea:	60 86       	std	Z+8, r6	; 0x08
    10ec:	83 e0       	ldi	r24, 0x03	; 3
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	81 1b       	sub	r24, r17
    10f2:	91 09       	sbc	r25, r1
    10f4:	95 87       	std	Z+13, r25	; 0x0d
    10f6:	84 87       	std	Z+12, r24	; 0x0c
    10f8:	73 8a       	std	Z+19, r7	; 0x13
    10fa:	62 8a       	std	Z+18, r6	; 0x12
    10fc:	13 a2       	std	Z+35, r1	; 0x23
    10fe:	14 a2       	std	Z+36, r1	; 0x24
    1100:	15 a2       	std	Z+37, r1	; 0x25
    1102:	16 a2       	std	Z+38, r1	; 0x26
    1104:	17 a2       	std	Z+39, r1	; 0x27
    1106:	a2 01       	movw	r20, r4
    1108:	b4 01       	movw	r22, r8
    110a:	c6 01       	movw	r24, r12
    110c:	0e 94 04 03 	call	0x608	; 0x608 <pxPortInitialiseStack>
    1110:	f3 01       	movw	r30, r6
    1112:	91 83       	std	Z+1, r25	; 0x01
    1114:	80 83       	st	Z, r24
    1116:	e1 14       	cp	r14, r1
    1118:	f1 04       	cpc	r15, r1
    111a:	19 f0       	breq	.+6      	; 0x1122 <xTaskGenericCreate+0xf2>
    111c:	f7 01       	movw	r30, r14
    111e:	71 82       	std	Z+1, r7	; 0x01
    1120:	60 82       	st	Z, r6
    1122:	0f b6       	in	r0, 0x3f	; 63
    1124:	f8 94       	cli
    1126:	0f 92       	push	r0
    1128:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uxCurrentNumberOfTasks>
    112c:	8f 5f       	subi	r24, 0xFF	; 255
    112e:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxCurrentNumberOfTasks>
    1132:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1136:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    113a:	89 2b       	or	r24, r25
    113c:	a9 f5       	brne	.+106    	; 0x11a8 <xTaskGenericCreate+0x178>
    113e:	70 92 e9 07 	sts	0x07E9, r7	; 0x8007e9 <pxCurrentTCB+0x1>
    1142:	60 92 e8 07 	sts	0x07E8, r6	; 0x8007e8 <pxCurrentTCB>
    1146:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uxCurrentNumberOfTasks>
    114a:	81 30       	cpi	r24, 0x01	; 1
    114c:	e1 f5       	brne	.+120    	; 0x11c6 <xTaskGenericCreate+0x196>
    114e:	8d ec       	ldi	r24, 0xCD	; 205
    1150:	97 e0       	ldi	r25, 0x07	; 7
    1152:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
    1156:	86 ed       	ldi	r24, 0xD6	; 214
    1158:	97 e0       	ldi	r25, 0x07	; 7
    115a:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
    115e:	8f ed       	ldi	r24, 0xDF	; 223
    1160:	97 e0       	ldi	r25, 0x07	; 7
    1162:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
    1166:	84 ec       	ldi	r24, 0xC4	; 196
    1168:	97 e0       	ldi	r25, 0x07	; 7
    116a:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
    116e:	8b eb       	ldi	r24, 0xBB	; 187
    1170:	97 e0       	ldi	r25, 0x07	; 7
    1172:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
    1176:	8e ea       	ldi	r24, 0xAE	; 174
    1178:	97 e0       	ldi	r25, 0x07	; 7
    117a:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
    117e:	85 ea       	ldi	r24, 0xA5	; 165
    1180:	97 e0       	ldi	r25, 0x07	; 7
    1182:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
    1186:	8b e9       	ldi	r24, 0x9B	; 155
    1188:	97 e0       	ldi	r25, 0x07	; 7
    118a:	0e 94 7a 02 	call	0x4f4	; 0x4f4 <vListInitialise>
    118e:	84 ec       	ldi	r24, 0xC4	; 196
    1190:	97 e0       	ldi	r25, 0x07	; 7
    1192:	90 93 ba 07 	sts	0x07BA, r25	; 0x8007ba <pxDelayedTaskList+0x1>
    1196:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <pxDelayedTaskList>
    119a:	8b eb       	ldi	r24, 0xBB	; 187
    119c:	97 e0       	ldi	r25, 0x07	; 7
    119e:	90 93 b8 07 	sts	0x07B8, r25	; 0x8007b8 <pxOverflowDelayedTaskList+0x1>
    11a2:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <pxOverflowDelayedTaskList>
    11a6:	0f c0       	rjmp	.+30     	; 0x11c6 <xTaskGenericCreate+0x196>
    11a8:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <xSchedulerRunning>
    11ac:	81 11       	cpse	r24, r1
    11ae:	0b c0       	rjmp	.+22     	; 0x11c6 <xTaskGenericCreate+0x196>
    11b0:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    11b4:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    11b8:	86 89       	ldd	r24, Z+22	; 0x16
    11ba:	08 17       	cp	r16, r24
    11bc:	20 f0       	brcs	.+8      	; 0x11c6 <xTaskGenericCreate+0x196>
    11be:	70 92 e9 07 	sts	0x07E9, r7	; 0x8007e9 <pxCurrentTCB+0x1>
    11c2:	60 92 e8 07 	sts	0x07E8, r6	; 0x8007e8 <pxCurrentTCB>
    11c6:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <uxTaskNumber>
    11ca:	8f 5f       	subi	r24, 0xFF	; 255
    11cc:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <uxTaskNumber>
    11d0:	f3 01       	movw	r30, r6
    11d2:	86 89       	ldd	r24, Z+22	; 0x16
    11d4:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    11d8:	98 17       	cp	r25, r24
    11da:	10 f4       	brcc	.+4      	; 0x11e0 <xTaskGenericCreate+0x1b0>
    11dc:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	9c 01       	movw	r18, r24
    11e4:	22 0f       	add	r18, r18
    11e6:	33 1f       	adc	r19, r19
    11e8:	22 0f       	add	r18, r18
    11ea:	33 1f       	adc	r19, r19
    11ec:	22 0f       	add	r18, r18
    11ee:	33 1f       	adc	r19, r19
    11f0:	82 0f       	add	r24, r18
    11f2:	93 1f       	adc	r25, r19
    11f4:	be 01       	movw	r22, r28
    11f6:	83 53       	subi	r24, 0x33	; 51
    11f8:	98 4f       	sbci	r25, 0xF8	; 248
    11fa:	0e 94 8c 02 	call	0x518	; 0x518 <vListInsertEnd>
    11fe:	0f 90       	pop	r0
    1200:	0f be       	out	0x3f, r0	; 63
    1202:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <xSchedulerRunning>
    1206:	88 23       	and	r24, r24
    1208:	59 f0       	breq	.+22     	; 0x1220 <xTaskGenericCreate+0x1f0>
    120a:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    120e:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1212:	86 89       	ldd	r24, Z+22	; 0x16
    1214:	80 17       	cp	r24, r16
    1216:	30 f4       	brcc	.+12     	; 0x1224 <xTaskGenericCreate+0x1f4>
    1218:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
    121c:	81 e0       	ldi	r24, 0x01	; 1
    121e:	05 c0       	rjmp	.+10     	; 0x122a <xTaskGenericCreate+0x1fa>
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	03 c0       	rjmp	.+6      	; 0x122a <xTaskGenericCreate+0x1fa>
    1224:	81 e0       	ldi	r24, 0x01	; 1
    1226:	01 c0       	rjmp	.+2      	; 0x122a <xTaskGenericCreate+0x1fa>
    1228:	8f ef       	ldi	r24, 0xFF	; 255
    122a:	df 91       	pop	r29
    122c:	cf 91       	pop	r28
    122e:	1f 91       	pop	r17
    1230:	0f 91       	pop	r16
    1232:	ff 90       	pop	r15
    1234:	ef 90       	pop	r14
    1236:	df 90       	pop	r13
    1238:	cf 90       	pop	r12
    123a:	bf 90       	pop	r11
    123c:	af 90       	pop	r10
    123e:	9f 90       	pop	r9
    1240:	8f 90       	pop	r8
    1242:	7f 90       	pop	r7
    1244:	6f 90       	pop	r6
    1246:	5f 90       	pop	r5
    1248:	4f 90       	pop	r4
    124a:	08 95       	ret

0000124c <vTaskStartScheduler>:
    124c:	af 92       	push	r10
    124e:	bf 92       	push	r11
    1250:	cf 92       	push	r12
    1252:	df 92       	push	r13
    1254:	ef 92       	push	r14
    1256:	ff 92       	push	r15
    1258:	0f 93       	push	r16
    125a:	a1 2c       	mov	r10, r1
    125c:	b1 2c       	mov	r11, r1
    125e:	c1 2c       	mov	r12, r1
    1260:	d1 2c       	mov	r13, r1
    1262:	0f 2e       	mov	r0, r31
    1264:	f9 e9       	ldi	r31, 0x99	; 153
    1266:	ef 2e       	mov	r14, r31
    1268:	f7 e0       	ldi	r31, 0x07	; 7
    126a:	ff 2e       	mov	r15, r31
    126c:	f0 2d       	mov	r31, r0
    126e:	00 e0       	ldi	r16, 0x00	; 0
    1270:	20 e0       	ldi	r18, 0x00	; 0
    1272:	30 e0       	ldi	r19, 0x00	; 0
    1274:	45 e5       	ldi	r20, 0x55	; 85
    1276:	50 e0       	ldi	r21, 0x00	; 0
    1278:	64 ea       	ldi	r22, 0xA4	; 164
    127a:	71 e0       	ldi	r23, 0x01	; 1
    127c:	86 ee       	ldi	r24, 0xE6	; 230
    127e:	9a e0       	ldi	r25, 0x0A	; 10
    1280:	0e 94 18 08 	call	0x1030	; 0x1030 <xTaskGenericCreate>
    1284:	81 30       	cpi	r24, 0x01	; 1
    1286:	49 f4       	brne	.+18     	; 0x129a <vTaskStartScheduler+0x4e>
    1288:	f8 94       	cli
    128a:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <xSchedulerRunning>
    128e:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <xTickCount+0x1>
    1292:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <xTickCount>
    1296:	0e 94 70 03 	call	0x6e0	; 0x6e0 <xPortStartScheduler>
    129a:	0f 91       	pop	r16
    129c:	ff 90       	pop	r15
    129e:	ef 90       	pop	r14
    12a0:	df 90       	pop	r13
    12a2:	cf 90       	pop	r12
    12a4:	bf 90       	pop	r11
    12a6:	af 90       	pop	r10
    12a8:	08 95       	ret

000012aa <vTaskSuspendAll>:
    12aa:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    12ae:	8f 5f       	subi	r24, 0xFF	; 255
    12b0:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxSchedulerSuspended>
    12b4:	08 95       	ret

000012b6 <xTaskGetTickCount>:
    12b6:	0f b6       	in	r0, 0x3f	; 63
    12b8:	f8 94       	cli
    12ba:	0f 92       	push	r0
    12bc:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
    12c0:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
    12c4:	0f 90       	pop	r0
    12c6:	0f be       	out	0x3f, r0	; 63
    12c8:	08 95       	ret

000012ca <xTaskIncrementTick>:
    12ca:	cf 92       	push	r12
    12cc:	df 92       	push	r13
    12ce:	ef 92       	push	r14
    12d0:	ff 92       	push	r15
    12d2:	0f 93       	push	r16
    12d4:	1f 93       	push	r17
    12d6:	cf 93       	push	r28
    12d8:	df 93       	push	r29
    12da:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    12de:	81 11       	cpse	r24, r1
    12e0:	9b c0       	rjmp	.+310    	; 0x1418 <xTaskIncrementTick+0x14e>
    12e2:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
    12e6:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
    12ea:	01 96       	adiw	r24, 0x01	; 1
    12ec:	90 93 97 07 	sts	0x0797, r25	; 0x800797 <xTickCount+0x1>
    12f0:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <xTickCount>
    12f4:	e0 90 96 07 	lds	r14, 0x0796	; 0x800796 <xTickCount>
    12f8:	f0 90 97 07 	lds	r15, 0x0797	; 0x800797 <xTickCount+0x1>
    12fc:	e1 14       	cp	r14, r1
    12fe:	f1 04       	cpc	r15, r1
    1300:	b9 f4       	brne	.+46     	; 0x1330 <xTaskIncrementTick+0x66>
    1302:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
    1306:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
    130a:	20 91 b7 07 	lds	r18, 0x07B7	; 0x8007b7 <pxOverflowDelayedTaskList>
    130e:	30 91 b8 07 	lds	r19, 0x07B8	; 0x8007b8 <pxOverflowDelayedTaskList+0x1>
    1312:	30 93 ba 07 	sts	0x07BA, r19	; 0x8007ba <pxDelayedTaskList+0x1>
    1316:	20 93 b9 07 	sts	0x07B9, r18	; 0x8007b9 <pxDelayedTaskList>
    131a:	90 93 b8 07 	sts	0x07B8, r25	; 0x8007b8 <pxOverflowDelayedTaskList+0x1>
    131e:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <pxOverflowDelayedTaskList>
    1322:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <xNumOfOverflows>
    1326:	8f 5f       	subi	r24, 0xFF	; 255
    1328:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNumOfOverflows>
    132c:	0e 94 c2 07 	call	0xf84	; 0xf84 <prvResetNextTaskUnblockTime>
    1330:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
    1334:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
    1338:	e8 16       	cp	r14, r24
    133a:	f9 06       	cpc	r15, r25
    133c:	10 f4       	brcc	.+4      	; 0x1342 <xTaskIncrementTick+0x78>
    133e:	d1 2c       	mov	r13, r1
    1340:	53 c0       	rjmp	.+166    	; 0x13e8 <xTaskIncrementTick+0x11e>
    1342:	d1 2c       	mov	r13, r1
    1344:	cc 24       	eor	r12, r12
    1346:	c3 94       	inc	r12
    1348:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
    134c:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
    1350:	80 81       	ld	r24, Z
    1352:	81 11       	cpse	r24, r1
    1354:	07 c0       	rjmp	.+14     	; 0x1364 <xTaskIncrementTick+0x9a>
    1356:	8f ef       	ldi	r24, 0xFF	; 255
    1358:	9f ef       	ldi	r25, 0xFF	; 255
    135a:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    135e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    1362:	42 c0       	rjmp	.+132    	; 0x13e8 <xTaskIncrementTick+0x11e>
    1364:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <pxDelayedTaskList>
    1368:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <pxDelayedTaskList+0x1>
    136c:	05 80       	ldd	r0, Z+5	; 0x05
    136e:	f6 81       	ldd	r31, Z+6	; 0x06
    1370:	e0 2d       	mov	r30, r0
    1372:	c6 81       	ldd	r28, Z+6	; 0x06
    1374:	d7 81       	ldd	r29, Z+7	; 0x07
    1376:	8a 81       	ldd	r24, Y+2	; 0x02
    1378:	9b 81       	ldd	r25, Y+3	; 0x03
    137a:	e8 16       	cp	r14, r24
    137c:	f9 06       	cpc	r15, r25
    137e:	28 f4       	brcc	.+10     	; 0x138a <xTaskIncrementTick+0xc0>
    1380:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    1384:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    1388:	2f c0       	rjmp	.+94     	; 0x13e8 <xTaskIncrementTick+0x11e>
    138a:	8e 01       	movw	r16, r28
    138c:	0e 5f       	subi	r16, 0xFE	; 254
    138e:	1f 4f       	sbci	r17, 0xFF	; 255
    1390:	c8 01       	movw	r24, r16
    1392:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    1396:	8c 89       	ldd	r24, Y+20	; 0x14
    1398:	9d 89       	ldd	r25, Y+21	; 0x15
    139a:	89 2b       	or	r24, r25
    139c:	21 f0       	breq	.+8      	; 0x13a6 <xTaskIncrementTick+0xdc>
    139e:	ce 01       	movw	r24, r28
    13a0:	0c 96       	adiw	r24, 0x0c	; 12
    13a2:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    13a6:	8e 89       	ldd	r24, Y+22	; 0x16
    13a8:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    13ac:	98 17       	cp	r25, r24
    13ae:	10 f4       	brcc	.+4      	; 0x13b4 <xTaskIncrementTick+0xea>
    13b0:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	9c 01       	movw	r18, r24
    13b8:	22 0f       	add	r18, r18
    13ba:	33 1f       	adc	r19, r19
    13bc:	22 0f       	add	r18, r18
    13be:	33 1f       	adc	r19, r19
    13c0:	22 0f       	add	r18, r18
    13c2:	33 1f       	adc	r19, r19
    13c4:	82 0f       	add	r24, r18
    13c6:	93 1f       	adc	r25, r19
    13c8:	b8 01       	movw	r22, r16
    13ca:	83 53       	subi	r24, 0x33	; 51
    13cc:	98 4f       	sbci	r25, 0xF8	; 248
    13ce:	0e 94 8c 02 	call	0x518	; 0x518 <vListInsertEnd>
    13d2:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    13d6:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    13da:	9e 89       	ldd	r25, Y+22	; 0x16
    13dc:	86 89       	ldd	r24, Z+22	; 0x16
    13de:	98 17       	cp	r25, r24
    13e0:	08 f4       	brcc	.+2      	; 0x13e4 <xTaskIncrementTick+0x11a>
    13e2:	b2 cf       	rjmp	.-156    	; 0x1348 <xTaskIncrementTick+0x7e>
    13e4:	dc 2c       	mov	r13, r12
    13e6:	b0 cf       	rjmp	.-160    	; 0x1348 <xTaskIncrementTick+0x7e>
    13e8:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    13ec:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    13f0:	86 89       	ldd	r24, Z+22	; 0x16
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	fc 01       	movw	r30, r24
    13f6:	ee 0f       	add	r30, r30
    13f8:	ff 1f       	adc	r31, r31
    13fa:	ee 0f       	add	r30, r30
    13fc:	ff 1f       	adc	r31, r31
    13fe:	ee 0f       	add	r30, r30
    1400:	ff 1f       	adc	r31, r31
    1402:	8e 0f       	add	r24, r30
    1404:	9f 1f       	adc	r25, r31
    1406:	fc 01       	movw	r30, r24
    1408:	e3 53       	subi	r30, 0x33	; 51
    140a:	f8 4f       	sbci	r31, 0xF8	; 248
    140c:	80 81       	ld	r24, Z
    140e:	82 30       	cpi	r24, 0x02	; 2
    1410:	48 f0       	brcs	.+18     	; 0x1424 <xTaskIncrementTick+0x15a>
    1412:	dd 24       	eor	r13, r13
    1414:	d3 94       	inc	r13
    1416:	06 c0       	rjmp	.+12     	; 0x1424 <xTaskIncrementTick+0x15a>
    1418:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    141c:	8f 5f       	subi	r24, 0xFF	; 255
    141e:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <uxPendedTicks>
    1422:	d1 2c       	mov	r13, r1
    1424:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <xYieldPending>
    1428:	88 23       	and	r24, r24
    142a:	11 f0       	breq	.+4      	; 0x1430 <xTaskIncrementTick+0x166>
    142c:	dd 24       	eor	r13, r13
    142e:	d3 94       	inc	r13
    1430:	8d 2d       	mov	r24, r13
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	1f 91       	pop	r17
    1438:	0f 91       	pop	r16
    143a:	ff 90       	pop	r15
    143c:	ef 90       	pop	r14
    143e:	df 90       	pop	r13
    1440:	cf 90       	pop	r12
    1442:	08 95       	ret

00001444 <xTaskResumeAll>:
    1444:	df 92       	push	r13
    1446:	ef 92       	push	r14
    1448:	ff 92       	push	r15
    144a:	0f 93       	push	r16
    144c:	1f 93       	push	r17
    144e:	cf 93       	push	r28
    1450:	df 93       	push	r29
    1452:	0f b6       	in	r0, 0x3f	; 63
    1454:	f8 94       	cli
    1456:	0f 92       	push	r0
    1458:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    145c:	81 50       	subi	r24, 0x01	; 1
    145e:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxSchedulerSuspended>
    1462:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    1466:	81 11       	cpse	r24, r1
    1468:	62 c0       	rjmp	.+196    	; 0x152e <xTaskResumeAll+0xea>
    146a:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uxCurrentNumberOfTasks>
    146e:	81 11       	cpse	r24, r1
    1470:	33 c0       	rjmp	.+102    	; 0x14d8 <xTaskResumeAll+0x94>
    1472:	60 c0       	rjmp	.+192    	; 0x1534 <xTaskResumeAll+0xf0>
    1474:	d7 01       	movw	r26, r14
    1476:	15 96       	adiw	r26, 0x05	; 5
    1478:	ed 91       	ld	r30, X+
    147a:	fc 91       	ld	r31, X
    147c:	16 97       	sbiw	r26, 0x06	; 6
    147e:	c6 81       	ldd	r28, Z+6	; 0x06
    1480:	d7 81       	ldd	r29, Z+7	; 0x07
    1482:	ce 01       	movw	r24, r28
    1484:	0c 96       	adiw	r24, 0x0c	; 12
    1486:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    148a:	8e 01       	movw	r16, r28
    148c:	0e 5f       	subi	r16, 0xFE	; 254
    148e:	1f 4f       	sbci	r17, 0xFF	; 255
    1490:	c8 01       	movw	r24, r16
    1492:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    1496:	8e 89       	ldd	r24, Y+22	; 0x16
    1498:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    149c:	98 17       	cp	r25, r24
    149e:	10 f4       	brcc	.+4      	; 0x14a4 <xTaskResumeAll+0x60>
    14a0:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    14a4:	90 e0       	ldi	r25, 0x00	; 0
    14a6:	9c 01       	movw	r18, r24
    14a8:	22 0f       	add	r18, r18
    14aa:	33 1f       	adc	r19, r19
    14ac:	22 0f       	add	r18, r18
    14ae:	33 1f       	adc	r19, r19
    14b0:	22 0f       	add	r18, r18
    14b2:	33 1f       	adc	r19, r19
    14b4:	82 0f       	add	r24, r18
    14b6:	93 1f       	adc	r25, r19
    14b8:	b8 01       	movw	r22, r16
    14ba:	83 53       	subi	r24, 0x33	; 51
    14bc:	98 4f       	sbci	r25, 0xF8	; 248
    14be:	0e 94 8c 02 	call	0x518	; 0x518 <vListInsertEnd>
    14c2:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    14c6:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    14ca:	9e 89       	ldd	r25, Y+22	; 0x16
    14cc:	86 89       	ldd	r24, Z+22	; 0x16
    14ce:	98 17       	cp	r25, r24
    14d0:	58 f0       	brcs	.+22     	; 0x14e8 <xTaskResumeAll+0xa4>
    14d2:	d0 92 92 07 	sts	0x0792, r13	; 0x800792 <xYieldPending>
    14d6:	08 c0       	rjmp	.+16     	; 0x14e8 <xTaskResumeAll+0xa4>
    14d8:	0f 2e       	mov	r0, r31
    14da:	fe ea       	ldi	r31, 0xAE	; 174
    14dc:	ef 2e       	mov	r14, r31
    14de:	f7 e0       	ldi	r31, 0x07	; 7
    14e0:	ff 2e       	mov	r15, r31
    14e2:	f0 2d       	mov	r31, r0
    14e4:	dd 24       	eor	r13, r13
    14e6:	d3 94       	inc	r13
    14e8:	f7 01       	movw	r30, r14
    14ea:	80 81       	ld	r24, Z
    14ec:	81 11       	cpse	r24, r1
    14ee:	c2 cf       	rjmp	.-124    	; 0x1474 <xTaskResumeAll+0x30>
    14f0:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    14f4:	88 23       	and	r24, r24
    14f6:	99 f0       	breq	.+38     	; 0x151e <xTaskResumeAll+0xda>
    14f8:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    14fc:	88 23       	and	r24, r24
    14fe:	79 f0       	breq	.+30     	; 0x151e <xTaskResumeAll+0xda>
    1500:	c1 e0       	ldi	r28, 0x01	; 1
    1502:	0e 94 65 09 	call	0x12ca	; 0x12ca <xTaskIncrementTick>
    1506:	81 11       	cpse	r24, r1
    1508:	c0 93 92 07 	sts	0x0792, r28	; 0x800792 <xYieldPending>
    150c:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    1510:	81 50       	subi	r24, 0x01	; 1
    1512:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <uxPendedTicks>
    1516:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxPendedTicks>
    151a:	81 11       	cpse	r24, r1
    151c:	f2 cf       	rjmp	.-28     	; 0x1502 <xTaskResumeAll+0xbe>
    151e:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <xYieldPending>
    1522:	81 30       	cpi	r24, 0x01	; 1
    1524:	31 f4       	brne	.+12     	; 0x1532 <xTaskResumeAll+0xee>
    1526:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	03 c0       	rjmp	.+6      	; 0x1534 <xTaskResumeAll+0xf0>
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	01 c0       	rjmp	.+2      	; 0x1534 <xTaskResumeAll+0xf0>
    1532:	80 e0       	ldi	r24, 0x00	; 0
    1534:	0f 90       	pop	r0
    1536:	0f be       	out	0x3f, r0	; 63
    1538:	df 91       	pop	r29
    153a:	cf 91       	pop	r28
    153c:	1f 91       	pop	r17
    153e:	0f 91       	pop	r16
    1540:	ff 90       	pop	r15
    1542:	ef 90       	pop	r14
    1544:	df 90       	pop	r13
    1546:	08 95       	ret

00001548 <vTaskDelayUntil>:
    1548:	0f 93       	push	r16
    154a:	1f 93       	push	r17
    154c:	cf 93       	push	r28
    154e:	df 93       	push	r29
    1550:	8c 01       	movw	r16, r24
    1552:	eb 01       	movw	r28, r22
    1554:	0e 94 55 09 	call	0x12aa	; 0x12aa <vTaskSuspendAll>
    1558:	20 91 96 07 	lds	r18, 0x0796	; 0x800796 <xTickCount>
    155c:	30 91 97 07 	lds	r19, 0x0797	; 0x800797 <xTickCount+0x1>
    1560:	f8 01       	movw	r30, r16
    1562:	80 81       	ld	r24, Z
    1564:	91 81       	ldd	r25, Z+1	; 0x01
    1566:	c8 0f       	add	r28, r24
    1568:	d9 1f       	adc	r29, r25
    156a:	28 17       	cp	r18, r24
    156c:	39 07       	cpc	r19, r25
    156e:	48 f4       	brcc	.+18     	; 0x1582 <vTaskDelayUntil+0x3a>
    1570:	c8 17       	cp	r28, r24
    1572:	d9 07       	cpc	r29, r25
    1574:	10 f5       	brcc	.+68     	; 0x15ba <vTaskDelayUntil+0x72>
    1576:	d1 83       	std	Z+1, r29	; 0x01
    1578:	c0 83       	st	Z, r28
    157a:	2c 17       	cp	r18, r28
    157c:	3d 07       	cpc	r19, r29
    157e:	90 f4       	brcc	.+36     	; 0x15a4 <vTaskDelayUntil+0x5c>
    1580:	07 c0       	rjmp	.+14     	; 0x1590 <vTaskDelayUntil+0x48>
    1582:	c8 17       	cp	r28, r24
    1584:	d9 07       	cpc	r29, r25
    1586:	a8 f0       	brcs	.+42     	; 0x15b2 <vTaskDelayUntil+0x6a>
    1588:	2c 17       	cp	r18, r28
    158a:	3d 07       	cpc	r19, r29
    158c:	90 f0       	brcs	.+36     	; 0x15b2 <vTaskDelayUntil+0x6a>
    158e:	15 c0       	rjmp	.+42     	; 0x15ba <vTaskDelayUntil+0x72>
    1590:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1594:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1598:	02 96       	adiw	r24, 0x02	; 2
    159a:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    159e:	ce 01       	movw	r24, r28
    15a0:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <prvAddCurrentTaskToDelayedList>
    15a4:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
    15a8:	81 11       	cpse	r24, r1
    15aa:	0b c0       	rjmp	.+22     	; 0x15c2 <vTaskDelayUntil+0x7a>
    15ac:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
    15b0:	08 c0       	rjmp	.+16     	; 0x15c2 <vTaskDelayUntil+0x7a>
    15b2:	f8 01       	movw	r30, r16
    15b4:	d1 83       	std	Z+1, r29	; 0x01
    15b6:	c0 83       	st	Z, r28
    15b8:	eb cf       	rjmp	.-42     	; 0x1590 <vTaskDelayUntil+0x48>
    15ba:	f8 01       	movw	r30, r16
    15bc:	d1 83       	std	Z+1, r29	; 0x01
    15be:	c0 83       	st	Z, r28
    15c0:	f1 cf       	rjmp	.-30     	; 0x15a4 <vTaskDelayUntil+0x5c>
    15c2:	df 91       	pop	r29
    15c4:	cf 91       	pop	r28
    15c6:	1f 91       	pop	r17
    15c8:	0f 91       	pop	r16
    15ca:	08 95       	ret

000015cc <prvIdleTask>:
    15cc:	05 ea       	ldi	r16, 0xA5	; 165
    15ce:	17 e0       	ldi	r17, 0x07	; 7
    15d0:	0f 2e       	mov	r0, r31
    15d2:	fd ec       	ldi	r31, 0xCD	; 205
    15d4:	ef 2e       	mov	r14, r31
    15d6:	f7 e0       	ldi	r31, 0x07	; 7
    15d8:	ff 2e       	mov	r15, r31
    15da:	f0 2d       	mov	r31, r0
    15dc:	29 c0       	rjmp	.+82     	; 0x1630 <prvIdleTask+0x64>
    15de:	0e 94 55 09 	call	0x12aa	; 0x12aa <vTaskSuspendAll>
    15e2:	d8 01       	movw	r26, r16
    15e4:	cc 91       	ld	r28, X
    15e6:	0e 94 22 0a 	call	0x1444	; 0x1444 <xTaskResumeAll>
    15ea:	cc 23       	and	r28, r28
    15ec:	09 f1       	breq	.+66     	; 0x1630 <prvIdleTask+0x64>
    15ee:	0f b6       	in	r0, 0x3f	; 63
    15f0:	f8 94       	cli
    15f2:	0f 92       	push	r0
    15f4:	d8 01       	movw	r26, r16
    15f6:	15 96       	adiw	r26, 0x05	; 5
    15f8:	ed 91       	ld	r30, X+
    15fa:	fc 91       	ld	r31, X
    15fc:	16 97       	sbiw	r26, 0x06	; 6
    15fe:	c6 81       	ldd	r28, Z+6	; 0x06
    1600:	d7 81       	ldd	r29, Z+7	; 0x07
    1602:	ce 01       	movw	r24, r28
    1604:	02 96       	adiw	r24, 0x02	; 2
    1606:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    160a:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <uxCurrentNumberOfTasks>
    160e:	81 50       	subi	r24, 0x01	; 1
    1610:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxCurrentNumberOfTasks>
    1614:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <uxTasksDeleted>
    1618:	81 50       	subi	r24, 0x01	; 1
    161a:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <uxTasksDeleted>
    161e:	0f 90       	pop	r0
    1620:	0f be       	out	0x3f, r0	; 63
    1622:	8f 89       	ldd	r24, Y+23	; 0x17
    1624:	98 8d       	ldd	r25, Y+24	; 0x18
    1626:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <vPortFree>
    162a:	ce 01       	movw	r24, r28
    162c:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <vPortFree>
    1630:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <uxTasksDeleted>
    1634:	81 11       	cpse	r24, r1
    1636:	d3 cf       	rjmp	.-90     	; 0x15de <prvIdleTask+0x12>
    1638:	f7 01       	movw	r30, r14
    163a:	80 81       	ld	r24, Z
    163c:	82 30       	cpi	r24, 0x02	; 2
    163e:	c0 f3       	brcs	.-16     	; 0x1630 <prvIdleTask+0x64>
    1640:	0e 94 aa 03 	call	0x754	; 0x754 <vPortYield>
    1644:	f5 cf       	rjmp	.-22     	; 0x1630 <prvIdleTask+0x64>

00001646 <vTaskSwitchContext>:
    1646:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    164a:	88 23       	and	r24, r24
    164c:	21 f0       	breq	.+8      	; 0x1656 <vTaskSwitchContext+0x10>
    164e:	81 e0       	ldi	r24, 0x01	; 1
    1650:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xYieldPending>
    1654:	08 95       	ret
    1656:	10 92 92 07 	sts	0x0792, r1	; 0x800792 <xYieldPending>
    165a:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uxTopReadyPriority>
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	fc 01       	movw	r30, r24
    1662:	ee 0f       	add	r30, r30
    1664:	ff 1f       	adc	r31, r31
    1666:	ee 0f       	add	r30, r30
    1668:	ff 1f       	adc	r31, r31
    166a:	ee 0f       	add	r30, r30
    166c:	ff 1f       	adc	r31, r31
    166e:	8e 0f       	add	r24, r30
    1670:	9f 1f       	adc	r25, r31
    1672:	fc 01       	movw	r30, r24
    1674:	e3 53       	subi	r30, 0x33	; 51
    1676:	f8 4f       	sbci	r31, 0xF8	; 248
    1678:	80 81       	ld	r24, Z
    167a:	81 11       	cpse	r24, r1
    167c:	17 c0       	rjmp	.+46     	; 0x16ac <vTaskSwitchContext+0x66>
    167e:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uxTopReadyPriority>
    1682:	81 50       	subi	r24, 0x01	; 1
    1684:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    1688:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uxTopReadyPriority>
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	fc 01       	movw	r30, r24
    1690:	ee 0f       	add	r30, r30
    1692:	ff 1f       	adc	r31, r31
    1694:	ee 0f       	add	r30, r30
    1696:	ff 1f       	adc	r31, r31
    1698:	ee 0f       	add	r30, r30
    169a:	ff 1f       	adc	r31, r31
    169c:	8e 0f       	add	r24, r30
    169e:	9f 1f       	adc	r25, r31
    16a0:	fc 01       	movw	r30, r24
    16a2:	e3 53       	subi	r30, 0x33	; 51
    16a4:	f8 4f       	sbci	r31, 0xF8	; 248
    16a6:	80 81       	ld	r24, Z
    16a8:	88 23       	and	r24, r24
    16aa:	49 f3       	breq	.-46     	; 0x167e <vTaskSwitchContext+0x38>
    16ac:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <uxTopReadyPriority>
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	9c 01       	movw	r18, r24
    16b4:	22 0f       	add	r18, r18
    16b6:	33 1f       	adc	r19, r19
    16b8:	22 0f       	add	r18, r18
    16ba:	33 1f       	adc	r19, r19
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	28 0f       	add	r18, r24
    16c2:	39 1f       	adc	r19, r25
    16c4:	d9 01       	movw	r26, r18
    16c6:	a3 53       	subi	r26, 0x33	; 51
    16c8:	b8 4f       	sbci	r27, 0xF8	; 248
    16ca:	11 96       	adiw	r26, 0x01	; 1
    16cc:	ed 91       	ld	r30, X+
    16ce:	fc 91       	ld	r31, X
    16d0:	12 97       	sbiw	r26, 0x02	; 2
    16d2:	02 80       	ldd	r0, Z+2	; 0x02
    16d4:	f3 81       	ldd	r31, Z+3	; 0x03
    16d6:	e0 2d       	mov	r30, r0
    16d8:	12 96       	adiw	r26, 0x02	; 2
    16da:	fc 93       	st	X, r31
    16dc:	ee 93       	st	-X, r30
    16de:	11 97       	sbiw	r26, 0x01	; 1
    16e0:	20 53       	subi	r18, 0x30	; 48
    16e2:	38 4f       	sbci	r19, 0xF8	; 248
    16e4:	e2 17       	cp	r30, r18
    16e6:	f3 07       	cpc	r31, r19
    16e8:	29 f4       	brne	.+10     	; 0x16f4 <vTaskSwitchContext+0xae>
    16ea:	22 81       	ldd	r18, Z+2	; 0x02
    16ec:	33 81       	ldd	r19, Z+3	; 0x03
    16ee:	fd 01       	movw	r30, r26
    16f0:	32 83       	std	Z+2, r19	; 0x02
    16f2:	21 83       	std	Z+1, r18	; 0x01
    16f4:	fc 01       	movw	r30, r24
    16f6:	ee 0f       	add	r30, r30
    16f8:	ff 1f       	adc	r31, r31
    16fa:	ee 0f       	add	r30, r30
    16fc:	ff 1f       	adc	r31, r31
    16fe:	ee 0f       	add	r30, r30
    1700:	ff 1f       	adc	r31, r31
    1702:	8e 0f       	add	r24, r30
    1704:	9f 1f       	adc	r25, r31
    1706:	fc 01       	movw	r30, r24
    1708:	e3 53       	subi	r30, 0x33	; 51
    170a:	f8 4f       	sbci	r31, 0xF8	; 248
    170c:	01 80       	ldd	r0, Z+1	; 0x01
    170e:	f2 81       	ldd	r31, Z+2	; 0x02
    1710:	e0 2d       	mov	r30, r0
    1712:	86 81       	ldd	r24, Z+6	; 0x06
    1714:	97 81       	ldd	r25, Z+7	; 0x07
    1716:	90 93 e9 07 	sts	0x07E9, r25	; 0x8007e9 <pxCurrentTCB+0x1>
    171a:	80 93 e8 07 	sts	0x07E8, r24	; 0x8007e8 <pxCurrentTCB>
    171e:	08 95       	ret

00001720 <vTaskPlaceOnEventList>:
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	eb 01       	movw	r28, r22
    1726:	60 91 e8 07 	lds	r22, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    172a:	70 91 e9 07 	lds	r23, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    172e:	64 5f       	subi	r22, 0xF4	; 244
    1730:	7f 4f       	sbci	r23, 0xFF	; 255
    1732:	0e 94 ad 02 	call	0x55a	; 0x55a <vListInsert>
    1736:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    173a:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    173e:	02 96       	adiw	r24, 0x02	; 2
    1740:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    1744:	cf 3f       	cpi	r28, 0xFF	; 255
    1746:	8f ef       	ldi	r24, 0xFF	; 255
    1748:	d8 07       	cpc	r29, r24
    174a:	59 f4       	brne	.+22     	; 0x1762 <vTaskPlaceOnEventList+0x42>
    174c:	60 91 e8 07 	lds	r22, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1750:	70 91 e9 07 	lds	r23, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1754:	6e 5f       	subi	r22, 0xFE	; 254
    1756:	7f 4f       	sbci	r23, 0xFF	; 255
    1758:	8b e9       	ldi	r24, 0x9B	; 155
    175a:	97 e0       	ldi	r25, 0x07	; 7
    175c:	0e 94 8c 02 	call	0x518	; 0x518 <vListInsertEnd>
    1760:	08 c0       	rjmp	.+16     	; 0x1772 <vTaskPlaceOnEventList+0x52>
    1762:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xTickCount>
    1766:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <xTickCount+0x1>
    176a:	8c 0f       	add	r24, r28
    176c:	9d 1f       	adc	r25, r29
    176e:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <prvAddCurrentTaskToDelayedList>
    1772:	df 91       	pop	r29
    1774:	cf 91       	pop	r28
    1776:	08 95       	ret

00001778 <xTaskRemoveFromEventList>:
    1778:	0f 93       	push	r16
    177a:	1f 93       	push	r17
    177c:	cf 93       	push	r28
    177e:	df 93       	push	r29
    1780:	dc 01       	movw	r26, r24
    1782:	15 96       	adiw	r26, 0x05	; 5
    1784:	ed 91       	ld	r30, X+
    1786:	fc 91       	ld	r31, X
    1788:	16 97       	sbiw	r26, 0x06	; 6
    178a:	c6 81       	ldd	r28, Z+6	; 0x06
    178c:	d7 81       	ldd	r29, Z+7	; 0x07
    178e:	8e 01       	movw	r16, r28
    1790:	04 5f       	subi	r16, 0xF4	; 244
    1792:	1f 4f       	sbci	r17, 0xFF	; 255
    1794:	c8 01       	movw	r24, r16
    1796:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    179a:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    179e:	81 11       	cpse	r24, r1
    17a0:	1c c0       	rjmp	.+56     	; 0x17da <xTaskRemoveFromEventList+0x62>
    17a2:	0a 50       	subi	r16, 0x0A	; 10
    17a4:	11 09       	sbc	r17, r1
    17a6:	c8 01       	movw	r24, r16
    17a8:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    17ac:	8e 89       	ldd	r24, Y+22	; 0x16
    17ae:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    17b2:	98 17       	cp	r25, r24
    17b4:	10 f4       	brcc	.+4      	; 0x17ba <xTaskRemoveFromEventList+0x42>
    17b6:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	9c 01       	movw	r18, r24
    17be:	22 0f       	add	r18, r18
    17c0:	33 1f       	adc	r19, r19
    17c2:	22 0f       	add	r18, r18
    17c4:	33 1f       	adc	r19, r19
    17c6:	22 0f       	add	r18, r18
    17c8:	33 1f       	adc	r19, r19
    17ca:	82 0f       	add	r24, r18
    17cc:	93 1f       	adc	r25, r19
    17ce:	b8 01       	movw	r22, r16
    17d0:	83 53       	subi	r24, 0x33	; 51
    17d2:	98 4f       	sbci	r25, 0xF8	; 248
    17d4:	0e 94 8c 02 	call	0x518	; 0x518 <vListInsertEnd>
    17d8:	05 c0       	rjmp	.+10     	; 0x17e4 <xTaskRemoveFromEventList+0x6c>
    17da:	b8 01       	movw	r22, r16
    17dc:	8e ea       	ldi	r24, 0xAE	; 174
    17de:	97 e0       	ldi	r25, 0x07	; 7
    17e0:	0e 94 8c 02 	call	0x518	; 0x518 <vListInsertEnd>
    17e4:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    17e8:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    17ec:	9e 89       	ldd	r25, Y+22	; 0x16
    17ee:	86 89       	ldd	r24, Z+22	; 0x16
    17f0:	89 17       	cp	r24, r25
    17f2:	20 f4       	brcc	.+8      	; 0x17fc <xTaskRemoveFromEventList+0x84>
    17f4:	81 e0       	ldi	r24, 0x01	; 1
    17f6:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xYieldPending>
    17fa:	01 c0       	rjmp	.+2      	; 0x17fe <xTaskRemoveFromEventList+0x86>
    17fc:	80 e0       	ldi	r24, 0x00	; 0
    17fe:	df 91       	pop	r29
    1800:	cf 91       	pop	r28
    1802:	1f 91       	pop	r17
    1804:	0f 91       	pop	r16
    1806:	08 95       	ret

00001808 <vTaskSetTimeOutState>:
    1808:	20 91 91 07 	lds	r18, 0x0791	; 0x800791 <xNumOfOverflows>
    180c:	fc 01       	movw	r30, r24
    180e:	20 83       	st	Z, r18
    1810:	20 91 96 07 	lds	r18, 0x0796	; 0x800796 <xTickCount>
    1814:	30 91 97 07 	lds	r19, 0x0797	; 0x800797 <xTickCount+0x1>
    1818:	32 83       	std	Z+2, r19	; 0x02
    181a:	21 83       	std	Z+1, r18	; 0x01
    181c:	08 95       	ret

0000181e <xTaskCheckForTimeOut>:
    181e:	0f b6       	in	r0, 0x3f	; 63
    1820:	f8 94       	cli
    1822:	0f 92       	push	r0
    1824:	40 91 96 07 	lds	r20, 0x0796	; 0x800796 <xTickCount>
    1828:	50 91 97 07 	lds	r21, 0x0797	; 0x800797 <xTickCount+0x1>
    182c:	db 01       	movw	r26, r22
    182e:	2d 91       	ld	r18, X+
    1830:	3c 91       	ld	r19, X
    1832:	2f 3f       	cpi	r18, 0xFF	; 255
    1834:	bf ef       	ldi	r27, 0xFF	; 255
    1836:	3b 07       	cpc	r19, r27
    1838:	19 f1       	breq	.+70     	; 0x1880 <xTaskCheckForTimeOut+0x62>
    183a:	e0 91 91 07 	lds	r30, 0x0791	; 0x800791 <xNumOfOverflows>
    183e:	dc 01       	movw	r26, r24
    1840:	fc 91       	ld	r31, X
    1842:	fe 17       	cp	r31, r30
    1844:	39 f0       	breq	.+14     	; 0x1854 <xTaskCheckForTimeOut+0x36>
    1846:	11 96       	adiw	r26, 0x01	; 1
    1848:	ed 91       	ld	r30, X+
    184a:	fc 91       	ld	r31, X
    184c:	12 97       	sbiw	r26, 0x02	; 2
    184e:	4e 17       	cp	r20, r30
    1850:	5f 07       	cpc	r21, r31
    1852:	c0 f4       	brcc	.+48     	; 0x1884 <xTaskCheckForTimeOut+0x66>
    1854:	dc 01       	movw	r26, r24
    1856:	11 96       	adiw	r26, 0x01	; 1
    1858:	ed 91       	ld	r30, X+
    185a:	fc 91       	ld	r31, X
    185c:	12 97       	sbiw	r26, 0x02	; 2
    185e:	da 01       	movw	r26, r20
    1860:	ae 1b       	sub	r26, r30
    1862:	bf 0b       	sbc	r27, r31
    1864:	a2 17       	cp	r26, r18
    1866:	b3 07       	cpc	r27, r19
    1868:	78 f4       	brcc	.+30     	; 0x1888 <xTaskCheckForTimeOut+0x6a>
    186a:	db 01       	movw	r26, r22
    186c:	e4 1b       	sub	r30, r20
    186e:	f5 0b       	sbc	r31, r21
    1870:	2e 0f       	add	r18, r30
    1872:	3f 1f       	adc	r19, r31
    1874:	2d 93       	st	X+, r18
    1876:	3c 93       	st	X, r19
    1878:	0e 94 04 0c 	call	0x1808	; 0x1808 <vTaskSetTimeOutState>
    187c:	80 e0       	ldi	r24, 0x00	; 0
    187e:	05 c0       	rjmp	.+10     	; 0x188a <xTaskCheckForTimeOut+0x6c>
    1880:	80 e0       	ldi	r24, 0x00	; 0
    1882:	03 c0       	rjmp	.+6      	; 0x188a <xTaskCheckForTimeOut+0x6c>
    1884:	81 e0       	ldi	r24, 0x01	; 1
    1886:	01 c0       	rjmp	.+2      	; 0x188a <xTaskCheckForTimeOut+0x6c>
    1888:	81 e0       	ldi	r24, 0x01	; 1
    188a:	0f 90       	pop	r0
    188c:	0f be       	out	0x3f, r0	; 63
    188e:	08 95       	ret

00001890 <vTaskMissedYield>:
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xYieldPending>
    1896:	08 95       	ret

00001898 <vTaskPriorityInherit>:
    1898:	0f 93       	push	r16
    189a:	1f 93       	push	r17
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
    18a0:	fc 01       	movw	r30, r24
    18a2:	89 2b       	or	r24, r25
    18a4:	09 f4       	brne	.+2      	; 0x18a8 <vTaskPriorityInherit+0x10>
    18a6:	55 c0       	rjmp	.+170    	; 0x1952 <vTaskPriorityInherit+0xba>
    18a8:	26 89       	ldd	r18, Z+22	; 0x16
    18aa:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    18ae:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    18b2:	56 96       	adiw	r26, 0x16	; 22
    18b4:	8c 91       	ld	r24, X
    18b6:	28 17       	cp	r18, r24
    18b8:	08 f0       	brcs	.+2      	; 0x18bc <vTaskPriorityInherit+0x24>
    18ba:	4b c0       	rjmp	.+150    	; 0x1952 <vTaskPriorityInherit+0xba>
    18bc:	84 85       	ldd	r24, Z+12	; 0x0c
    18be:	95 85       	ldd	r25, Z+13	; 0x0d
    18c0:	99 23       	and	r25, r25
    18c2:	64 f0       	brlt	.+24     	; 0x18dc <vTaskPriorityInherit+0x44>
    18c4:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    18c8:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    18cc:	56 96       	adiw	r26, 0x16	; 22
    18ce:	3c 91       	ld	r19, X
    18d0:	83 e0       	ldi	r24, 0x03	; 3
    18d2:	90 e0       	ldi	r25, 0x00	; 0
    18d4:	83 1b       	sub	r24, r19
    18d6:	91 09       	sbc	r25, r1
    18d8:	95 87       	std	Z+13, r25	; 0x0d
    18da:	84 87       	std	Z+12, r24	; 0x0c
    18dc:	30 e0       	ldi	r19, 0x00	; 0
    18de:	c9 01       	movw	r24, r18
    18e0:	88 0f       	add	r24, r24
    18e2:	99 1f       	adc	r25, r25
    18e4:	88 0f       	add	r24, r24
    18e6:	99 1f       	adc	r25, r25
    18e8:	88 0f       	add	r24, r24
    18ea:	99 1f       	adc	r25, r25
    18ec:	28 0f       	add	r18, r24
    18ee:	39 1f       	adc	r19, r25
    18f0:	23 53       	subi	r18, 0x33	; 51
    18f2:	38 4f       	sbci	r19, 0xF8	; 248
    18f4:	82 85       	ldd	r24, Z+10	; 0x0a
    18f6:	93 85       	ldd	r25, Z+11	; 0x0b
    18f8:	82 17       	cp	r24, r18
    18fa:	93 07       	cpc	r25, r19
    18fc:	19 f5       	brne	.+70     	; 0x1944 <vTaskPriorityInherit+0xac>
    18fe:	8f 01       	movw	r16, r30
    1900:	ef 01       	movw	r28, r30
    1902:	22 96       	adiw	r28, 0x02	; 2
    1904:	ce 01       	movw	r24, r28
    1906:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    190a:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    190e:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    1912:	86 89       	ldd	r24, Z+22	; 0x16
    1914:	f8 01       	movw	r30, r16
    1916:	86 8b       	std	Z+22, r24	; 0x16
    1918:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    191c:	98 17       	cp	r25, r24
    191e:	10 f4       	brcc	.+4      	; 0x1924 <vTaskPriorityInherit+0x8c>
    1920:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    1924:	90 e0       	ldi	r25, 0x00	; 0
    1926:	9c 01       	movw	r18, r24
    1928:	22 0f       	add	r18, r18
    192a:	33 1f       	adc	r19, r19
    192c:	22 0f       	add	r18, r18
    192e:	33 1f       	adc	r19, r19
    1930:	22 0f       	add	r18, r18
    1932:	33 1f       	adc	r19, r19
    1934:	82 0f       	add	r24, r18
    1936:	93 1f       	adc	r25, r19
    1938:	be 01       	movw	r22, r28
    193a:	83 53       	subi	r24, 0x33	; 51
    193c:	98 4f       	sbci	r25, 0xF8	; 248
    193e:	0e 94 8c 02 	call	0x518	; 0x518 <vListInsertEnd>
    1942:	07 c0       	rjmp	.+14     	; 0x1952 <vTaskPriorityInherit+0xba>
    1944:	a0 91 e8 07 	lds	r26, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    1948:	b0 91 e9 07 	lds	r27, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    194c:	56 96       	adiw	r26, 0x16	; 22
    194e:	8c 91       	ld	r24, X
    1950:	86 8b       	std	Z+22, r24	; 0x16
    1952:	df 91       	pop	r29
    1954:	cf 91       	pop	r28
    1956:	1f 91       	pop	r17
    1958:	0f 91       	pop	r16
    195a:	08 95       	ret

0000195c <xTaskPriorityDisinherit>:
    195c:	0f 93       	push	r16
    195e:	1f 93       	push	r17
    1960:	cf 93       	push	r28
    1962:	df 93       	push	r29
    1964:	fc 01       	movw	r30, r24
    1966:	89 2b       	or	r24, r25
    1968:	79 f1       	breq	.+94     	; 0x19c8 <xTaskPriorityDisinherit+0x6c>
    196a:	82 a1       	ldd	r24, Z+34	; 0x22
    196c:	81 50       	subi	r24, 0x01	; 1
    196e:	82 a3       	std	Z+34, r24	; 0x22
    1970:	26 89       	ldd	r18, Z+22	; 0x16
    1972:	91 a1       	ldd	r25, Z+33	; 0x21
    1974:	29 17       	cp	r18, r25
    1976:	51 f1       	breq	.+84     	; 0x19cc <xTaskPriorityDisinherit+0x70>
    1978:	81 11       	cpse	r24, r1
    197a:	2a c0       	rjmp	.+84     	; 0x19d0 <xTaskPriorityDisinherit+0x74>
    197c:	ef 01       	movw	r28, r30
    197e:	8f 01       	movw	r16, r30
    1980:	0e 5f       	subi	r16, 0xFE	; 254
    1982:	1f 4f       	sbci	r17, 0xFF	; 255
    1984:	c8 01       	movw	r24, r16
    1986:	0e 94 de 02 	call	0x5bc	; 0x5bc <uxListRemove>
    198a:	89 a1       	ldd	r24, Y+33	; 0x21
    198c:	8e 8b       	std	Y+22, r24	; 0x16
    198e:	23 e0       	ldi	r18, 0x03	; 3
    1990:	30 e0       	ldi	r19, 0x00	; 0
    1992:	28 1b       	sub	r18, r24
    1994:	31 09       	sbc	r19, r1
    1996:	3d 87       	std	Y+13, r19	; 0x0d
    1998:	2c 87       	std	Y+12, r18	; 0x0c
    199a:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <uxTopReadyPriority>
    199e:	98 17       	cp	r25, r24
    19a0:	10 f4       	brcc	.+4      	; 0x19a6 <xTaskPriorityDisinherit+0x4a>
    19a2:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <uxTopReadyPriority>
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	9c 01       	movw	r18, r24
    19aa:	22 0f       	add	r18, r18
    19ac:	33 1f       	adc	r19, r19
    19ae:	22 0f       	add	r18, r18
    19b0:	33 1f       	adc	r19, r19
    19b2:	22 0f       	add	r18, r18
    19b4:	33 1f       	adc	r19, r19
    19b6:	82 0f       	add	r24, r18
    19b8:	93 1f       	adc	r25, r19
    19ba:	b8 01       	movw	r22, r16
    19bc:	83 53       	subi	r24, 0x33	; 51
    19be:	98 4f       	sbci	r25, 0xF8	; 248
    19c0:	0e 94 8c 02 	call	0x518	; 0x518 <vListInsertEnd>
    19c4:	81 e0       	ldi	r24, 0x01	; 1
    19c6:	05 c0       	rjmp	.+10     	; 0x19d2 <xTaskPriorityDisinherit+0x76>
    19c8:	80 e0       	ldi	r24, 0x00	; 0
    19ca:	03 c0       	rjmp	.+6      	; 0x19d2 <xTaskPriorityDisinherit+0x76>
    19cc:	80 e0       	ldi	r24, 0x00	; 0
    19ce:	01 c0       	rjmp	.+2      	; 0x19d2 <xTaskPriorityDisinherit+0x76>
    19d0:	80 e0       	ldi	r24, 0x00	; 0
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	1f 91       	pop	r17
    19d8:	0f 91       	pop	r16
    19da:	08 95       	ret

000019dc <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    19dc:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    19e0:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    19e4:	89 2b       	or	r24, r25
    19e6:	39 f0       	breq	.+14     	; 0x19f6 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    19e8:	e0 91 e8 07 	lds	r30, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    19ec:	f0 91 e9 07 	lds	r31, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
    19f0:	82 a1       	ldd	r24, Z+34	; 0x22
    19f2:	8f 5f       	subi	r24, 0xFF	; 255
    19f4:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    19f6:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <pxCurrentTCB>
    19fa:	90 91 e9 07 	lds	r25, 0x07E9	; 0x8007e9 <pxCurrentTCB+0x1>
	}
    19fe:	08 95       	ret

00001a00 <attachInterrupt>:
    #endif
      break;
#endif
    }
      
    intFunc[interruptNum] = 0;
    1a00:	82 30       	cpi	r24, 0x02	; 2
    1a02:	00 f5       	brcc	.+64     	; 0x1a44 <attachInterrupt+0x44>
    1a04:	e8 2f       	mov	r30, r24
    1a06:	f0 e0       	ldi	r31, 0x00	; 0
    1a08:	ee 0f       	add	r30, r30
    1a0a:	ff 1f       	adc	r31, r31
    1a0c:	e6 51       	subi	r30, 0x16	; 22
    1a0e:	f8 4f       	sbci	r31, 0xF8	; 248
    1a10:	71 83       	std	Z+1, r23	; 0x01
    1a12:	60 83       	st	Z, r22
    1a14:	88 23       	and	r24, r24
    1a16:	19 f0       	breq	.+6      	; 0x1a1e <attachInterrupt+0x1e>
    1a18:	81 30       	cpi	r24, 0x01	; 1
    1a1a:	49 f0       	breq	.+18     	; 0x1a2e <attachInterrupt+0x2e>
    1a1c:	08 95       	ret
    1a1e:	e9 e6       	ldi	r30, 0x69	; 105
    1a20:	f0 e0       	ldi	r31, 0x00	; 0
    1a22:	80 81       	ld	r24, Z
    1a24:	8c 7f       	andi	r24, 0xFC	; 252
    1a26:	48 2b       	or	r20, r24
    1a28:	40 83       	st	Z, r20
    1a2a:	e8 9a       	sbi	0x1d, 0	; 29
    1a2c:	08 95       	ret
    1a2e:	e9 e6       	ldi	r30, 0x69	; 105
    1a30:	f0 e0       	ldi	r31, 0x00	; 0
    1a32:	80 81       	ld	r24, Z
    1a34:	83 7f       	andi	r24, 0xF3	; 243
    1a36:	44 0f       	add	r20, r20
    1a38:	55 1f       	adc	r21, r21
    1a3a:	44 0f       	add	r20, r20
    1a3c:	55 1f       	adc	r21, r21
    1a3e:	48 2b       	or	r20, r24
    1a40:	40 83       	st	Z, r20
    1a42:	e9 9a       	sbi	0x1d, 1	; 29
    1a44:	08 95       	ret

00001a46 <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

ISR(INT0_vect) {
    1a46:	1f 92       	push	r1
    1a48:	0f 92       	push	r0
    1a4a:	0f b6       	in	r0, 0x3f	; 63
    1a4c:	0f 92       	push	r0
    1a4e:	11 24       	eor	r1, r1
    1a50:	2f 93       	push	r18
    1a52:	3f 93       	push	r19
    1a54:	4f 93       	push	r20
    1a56:	5f 93       	push	r21
    1a58:	6f 93       	push	r22
    1a5a:	7f 93       	push	r23
    1a5c:	8f 93       	push	r24
    1a5e:	9f 93       	push	r25
    1a60:	af 93       	push	r26
    1a62:	bf 93       	push	r27
    1a64:	ef 93       	push	r30
    1a66:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_0])
    1a68:	80 91 ea 07 	lds	r24, 0x07EA	; 0x8007ea <intFunc>
    1a6c:	90 91 eb 07 	lds	r25, 0x07EB	; 0x8007eb <intFunc+0x1>
    1a70:	89 2b       	or	r24, r25
    1a72:	29 f0       	breq	.+10     	; 0x1a7e <__vector_1+0x38>
    intFunc[EXTERNAL_INT_0]();
    1a74:	e0 91 ea 07 	lds	r30, 0x07EA	; 0x8007ea <intFunc>
    1a78:	f0 91 eb 07 	lds	r31, 0x07EB	; 0x8007eb <intFunc+0x1>
    1a7c:	09 95       	icall
}
    1a7e:	ff 91       	pop	r31
    1a80:	ef 91       	pop	r30
    1a82:	bf 91       	pop	r27
    1a84:	af 91       	pop	r26
    1a86:	9f 91       	pop	r25
    1a88:	8f 91       	pop	r24
    1a8a:	7f 91       	pop	r23
    1a8c:	6f 91       	pop	r22
    1a8e:	5f 91       	pop	r21
    1a90:	4f 91       	pop	r20
    1a92:	3f 91       	pop	r19
    1a94:	2f 91       	pop	r18
    1a96:	0f 90       	pop	r0
    1a98:	0f be       	out	0x3f, r0	; 63
    1a9a:	0f 90       	pop	r0
    1a9c:	1f 90       	pop	r1
    1a9e:	18 95       	reti

00001aa0 <__vector_2>:

ISR(INT1_vect) {
    1aa0:	1f 92       	push	r1
    1aa2:	0f 92       	push	r0
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	0f 92       	push	r0
    1aa8:	11 24       	eor	r1, r1
    1aaa:	2f 93       	push	r18
    1aac:	3f 93       	push	r19
    1aae:	4f 93       	push	r20
    1ab0:	5f 93       	push	r21
    1ab2:	6f 93       	push	r22
    1ab4:	7f 93       	push	r23
    1ab6:	8f 93       	push	r24
    1ab8:	9f 93       	push	r25
    1aba:	af 93       	push	r26
    1abc:	bf 93       	push	r27
    1abe:	ef 93       	push	r30
    1ac0:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_1])
    1ac2:	80 91 ec 07 	lds	r24, 0x07EC	; 0x8007ec <intFunc+0x2>
    1ac6:	90 91 ed 07 	lds	r25, 0x07ED	; 0x8007ed <intFunc+0x3>
    1aca:	89 2b       	or	r24, r25
    1acc:	29 f0       	breq	.+10     	; 0x1ad8 <__vector_2+0x38>
    intFunc[EXTERNAL_INT_1]();
    1ace:	e0 91 ec 07 	lds	r30, 0x07EC	; 0x8007ec <intFunc+0x2>
    1ad2:	f0 91 ed 07 	lds	r31, 0x07ED	; 0x8007ed <intFunc+0x3>
    1ad6:	09 95       	icall
}
    1ad8:	ff 91       	pop	r31
    1ada:	ef 91       	pop	r30
    1adc:	bf 91       	pop	r27
    1ade:	af 91       	pop	r26
    1ae0:	9f 91       	pop	r25
    1ae2:	8f 91       	pop	r24
    1ae4:	7f 91       	pop	r23
    1ae6:	6f 91       	pop	r22
    1ae8:	5f 91       	pop	r21
    1aea:	4f 91       	pop	r20
    1aec:	3f 91       	pop	r19
    1aee:	2f 91       	pop	r18
    1af0:	0f 90       	pop	r0
    1af2:	0f be       	out	0x3f, r0	; 63
    1af4:	0f 90       	pop	r0
    1af6:	1f 90       	pop	r1
    1af8:	18 95       	reti

00001afa <__divsf3>:
    1afa:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <__divsf3x>
    1afe:	0c 94 43 0e 	jmp	0x1c86	; 0x1c86 <__fp_round>
    1b02:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <__fp_pscB>
    1b06:	58 f0       	brcs	.+22     	; 0x1b1e <__divsf3+0x24>
    1b08:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <__fp_pscA>
    1b0c:	40 f0       	brcs	.+16     	; 0x1b1e <__divsf3+0x24>
    1b0e:	29 f4       	brne	.+10     	; 0x1b1a <__divsf3+0x20>
    1b10:	5f 3f       	cpi	r21, 0xFF	; 255
    1b12:	29 f0       	breq	.+10     	; 0x1b1e <__divsf3+0x24>
    1b14:	0c 94 2c 0e 	jmp	0x1c58	; 0x1c58 <__fp_inf>
    1b18:	51 11       	cpse	r21, r1
    1b1a:	0c 94 77 0e 	jmp	0x1cee	; 0x1cee <__fp_szero>
    1b1e:	0c 94 32 0e 	jmp	0x1c64	; 0x1c64 <__fp_nan>

00001b22 <__divsf3x>:
    1b22:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <__fp_split3>
    1b26:	68 f3       	brcs	.-38     	; 0x1b02 <__divsf3+0x8>

00001b28 <__divsf3_pse>:
    1b28:	99 23       	and	r25, r25
    1b2a:	b1 f3       	breq	.-20     	; 0x1b18 <__divsf3+0x1e>
    1b2c:	55 23       	and	r21, r21
    1b2e:	91 f3       	breq	.-28     	; 0x1b14 <__divsf3+0x1a>
    1b30:	95 1b       	sub	r25, r21
    1b32:	55 0b       	sbc	r21, r21
    1b34:	bb 27       	eor	r27, r27
    1b36:	aa 27       	eor	r26, r26
    1b38:	62 17       	cp	r22, r18
    1b3a:	73 07       	cpc	r23, r19
    1b3c:	84 07       	cpc	r24, r20
    1b3e:	38 f0       	brcs	.+14     	; 0x1b4e <__divsf3_pse+0x26>
    1b40:	9f 5f       	subi	r25, 0xFF	; 255
    1b42:	5f 4f       	sbci	r21, 0xFF	; 255
    1b44:	22 0f       	add	r18, r18
    1b46:	33 1f       	adc	r19, r19
    1b48:	44 1f       	adc	r20, r20
    1b4a:	aa 1f       	adc	r26, r26
    1b4c:	a9 f3       	breq	.-22     	; 0x1b38 <__divsf3_pse+0x10>
    1b4e:	35 d0       	rcall	.+106    	; 0x1bba <__divsf3_pse+0x92>
    1b50:	0e 2e       	mov	r0, r30
    1b52:	3a f0       	brmi	.+14     	; 0x1b62 <__divsf3_pse+0x3a>
    1b54:	e0 e8       	ldi	r30, 0x80	; 128
    1b56:	32 d0       	rcall	.+100    	; 0x1bbc <__divsf3_pse+0x94>
    1b58:	91 50       	subi	r25, 0x01	; 1
    1b5a:	50 40       	sbci	r21, 0x00	; 0
    1b5c:	e6 95       	lsr	r30
    1b5e:	00 1c       	adc	r0, r0
    1b60:	ca f7       	brpl	.-14     	; 0x1b54 <__divsf3_pse+0x2c>
    1b62:	2b d0       	rcall	.+86     	; 0x1bba <__divsf3_pse+0x92>
    1b64:	fe 2f       	mov	r31, r30
    1b66:	29 d0       	rcall	.+82     	; 0x1bba <__divsf3_pse+0x92>
    1b68:	66 0f       	add	r22, r22
    1b6a:	77 1f       	adc	r23, r23
    1b6c:	88 1f       	adc	r24, r24
    1b6e:	bb 1f       	adc	r27, r27
    1b70:	26 17       	cp	r18, r22
    1b72:	37 07       	cpc	r19, r23
    1b74:	48 07       	cpc	r20, r24
    1b76:	ab 07       	cpc	r26, r27
    1b78:	b0 e8       	ldi	r27, 0x80	; 128
    1b7a:	09 f0       	breq	.+2      	; 0x1b7e <__divsf3_pse+0x56>
    1b7c:	bb 0b       	sbc	r27, r27
    1b7e:	80 2d       	mov	r24, r0
    1b80:	bf 01       	movw	r22, r30
    1b82:	ff 27       	eor	r31, r31
    1b84:	93 58       	subi	r25, 0x83	; 131
    1b86:	5f 4f       	sbci	r21, 0xFF	; 255
    1b88:	3a f0       	brmi	.+14     	; 0x1b98 <__divsf3_pse+0x70>
    1b8a:	9e 3f       	cpi	r25, 0xFE	; 254
    1b8c:	51 05       	cpc	r21, r1
    1b8e:	78 f0       	brcs	.+30     	; 0x1bae <__divsf3_pse+0x86>
    1b90:	0c 94 2c 0e 	jmp	0x1c58	; 0x1c58 <__fp_inf>
    1b94:	0c 94 77 0e 	jmp	0x1cee	; 0x1cee <__fp_szero>
    1b98:	5f 3f       	cpi	r21, 0xFF	; 255
    1b9a:	e4 f3       	brlt	.-8      	; 0x1b94 <__divsf3_pse+0x6c>
    1b9c:	98 3e       	cpi	r25, 0xE8	; 232
    1b9e:	d4 f3       	brlt	.-12     	; 0x1b94 <__divsf3_pse+0x6c>
    1ba0:	86 95       	lsr	r24
    1ba2:	77 95       	ror	r23
    1ba4:	67 95       	ror	r22
    1ba6:	b7 95       	ror	r27
    1ba8:	f7 95       	ror	r31
    1baa:	9f 5f       	subi	r25, 0xFF	; 255
    1bac:	c9 f7       	brne	.-14     	; 0x1ba0 <__divsf3_pse+0x78>
    1bae:	88 0f       	add	r24, r24
    1bb0:	91 1d       	adc	r25, r1
    1bb2:	96 95       	lsr	r25
    1bb4:	87 95       	ror	r24
    1bb6:	97 f9       	bld	r25, 7
    1bb8:	08 95       	ret
    1bba:	e1 e0       	ldi	r30, 0x01	; 1
    1bbc:	66 0f       	add	r22, r22
    1bbe:	77 1f       	adc	r23, r23
    1bc0:	88 1f       	adc	r24, r24
    1bc2:	bb 1f       	adc	r27, r27
    1bc4:	62 17       	cp	r22, r18
    1bc6:	73 07       	cpc	r23, r19
    1bc8:	84 07       	cpc	r24, r20
    1bca:	ba 07       	cpc	r27, r26
    1bcc:	20 f0       	brcs	.+8      	; 0x1bd6 <__divsf3_pse+0xae>
    1bce:	62 1b       	sub	r22, r18
    1bd0:	73 0b       	sbc	r23, r19
    1bd2:	84 0b       	sbc	r24, r20
    1bd4:	ba 0b       	sbc	r27, r26
    1bd6:	ee 1f       	adc	r30, r30
    1bd8:	88 f7       	brcc	.-30     	; 0x1bbc <__divsf3_pse+0x94>
    1bda:	e0 95       	com	r30
    1bdc:	08 95       	ret

00001bde <__floatunsisf>:
    1bde:	e8 94       	clt
    1be0:	09 c0       	rjmp	.+18     	; 0x1bf4 <__floatsisf+0x12>

00001be2 <__floatsisf>:
    1be2:	97 fb       	bst	r25, 7
    1be4:	3e f4       	brtc	.+14     	; 0x1bf4 <__floatsisf+0x12>
    1be6:	90 95       	com	r25
    1be8:	80 95       	com	r24
    1bea:	70 95       	com	r23
    1bec:	61 95       	neg	r22
    1bee:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf0:	8f 4f       	sbci	r24, 0xFF	; 255
    1bf2:	9f 4f       	sbci	r25, 0xFF	; 255
    1bf4:	99 23       	and	r25, r25
    1bf6:	a9 f0       	breq	.+42     	; 0x1c22 <__floatsisf+0x40>
    1bf8:	f9 2f       	mov	r31, r25
    1bfa:	96 e9       	ldi	r25, 0x96	; 150
    1bfc:	bb 27       	eor	r27, r27
    1bfe:	93 95       	inc	r25
    1c00:	f6 95       	lsr	r31
    1c02:	87 95       	ror	r24
    1c04:	77 95       	ror	r23
    1c06:	67 95       	ror	r22
    1c08:	b7 95       	ror	r27
    1c0a:	f1 11       	cpse	r31, r1
    1c0c:	f8 cf       	rjmp	.-16     	; 0x1bfe <__floatsisf+0x1c>
    1c0e:	fa f4       	brpl	.+62     	; 0x1c4e <__floatsisf+0x6c>
    1c10:	bb 0f       	add	r27, r27
    1c12:	11 f4       	brne	.+4      	; 0x1c18 <__floatsisf+0x36>
    1c14:	60 ff       	sbrs	r22, 0
    1c16:	1b c0       	rjmp	.+54     	; 0x1c4e <__floatsisf+0x6c>
    1c18:	6f 5f       	subi	r22, 0xFF	; 255
    1c1a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c1c:	8f 4f       	sbci	r24, 0xFF	; 255
    1c1e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c20:	16 c0       	rjmp	.+44     	; 0x1c4e <__floatsisf+0x6c>
    1c22:	88 23       	and	r24, r24
    1c24:	11 f0       	breq	.+4      	; 0x1c2a <__floatsisf+0x48>
    1c26:	96 e9       	ldi	r25, 0x96	; 150
    1c28:	11 c0       	rjmp	.+34     	; 0x1c4c <__floatsisf+0x6a>
    1c2a:	77 23       	and	r23, r23
    1c2c:	21 f0       	breq	.+8      	; 0x1c36 <__floatsisf+0x54>
    1c2e:	9e e8       	ldi	r25, 0x8E	; 142
    1c30:	87 2f       	mov	r24, r23
    1c32:	76 2f       	mov	r23, r22
    1c34:	05 c0       	rjmp	.+10     	; 0x1c40 <__floatsisf+0x5e>
    1c36:	66 23       	and	r22, r22
    1c38:	71 f0       	breq	.+28     	; 0x1c56 <__floatsisf+0x74>
    1c3a:	96 e8       	ldi	r25, 0x86	; 134
    1c3c:	86 2f       	mov	r24, r22
    1c3e:	70 e0       	ldi	r23, 0x00	; 0
    1c40:	60 e0       	ldi	r22, 0x00	; 0
    1c42:	2a f0       	brmi	.+10     	; 0x1c4e <__floatsisf+0x6c>
    1c44:	9a 95       	dec	r25
    1c46:	66 0f       	add	r22, r22
    1c48:	77 1f       	adc	r23, r23
    1c4a:	88 1f       	adc	r24, r24
    1c4c:	da f7       	brpl	.-10     	; 0x1c44 <__floatsisf+0x62>
    1c4e:	88 0f       	add	r24, r24
    1c50:	96 95       	lsr	r25
    1c52:	87 95       	ror	r24
    1c54:	97 f9       	bld	r25, 7
    1c56:	08 95       	ret

00001c58 <__fp_inf>:
    1c58:	97 f9       	bld	r25, 7
    1c5a:	9f 67       	ori	r25, 0x7F	; 127
    1c5c:	80 e8       	ldi	r24, 0x80	; 128
    1c5e:	70 e0       	ldi	r23, 0x00	; 0
    1c60:	60 e0       	ldi	r22, 0x00	; 0
    1c62:	08 95       	ret

00001c64 <__fp_nan>:
    1c64:	9f ef       	ldi	r25, 0xFF	; 255
    1c66:	80 ec       	ldi	r24, 0xC0	; 192
    1c68:	08 95       	ret

00001c6a <__fp_pscA>:
    1c6a:	00 24       	eor	r0, r0
    1c6c:	0a 94       	dec	r0
    1c6e:	16 16       	cp	r1, r22
    1c70:	17 06       	cpc	r1, r23
    1c72:	18 06       	cpc	r1, r24
    1c74:	09 06       	cpc	r0, r25
    1c76:	08 95       	ret

00001c78 <__fp_pscB>:
    1c78:	00 24       	eor	r0, r0
    1c7a:	0a 94       	dec	r0
    1c7c:	12 16       	cp	r1, r18
    1c7e:	13 06       	cpc	r1, r19
    1c80:	14 06       	cpc	r1, r20
    1c82:	05 06       	cpc	r0, r21
    1c84:	08 95       	ret

00001c86 <__fp_round>:
    1c86:	09 2e       	mov	r0, r25
    1c88:	03 94       	inc	r0
    1c8a:	00 0c       	add	r0, r0
    1c8c:	11 f4       	brne	.+4      	; 0x1c92 <__fp_round+0xc>
    1c8e:	88 23       	and	r24, r24
    1c90:	52 f0       	brmi	.+20     	; 0x1ca6 <__fp_round+0x20>
    1c92:	bb 0f       	add	r27, r27
    1c94:	40 f4       	brcc	.+16     	; 0x1ca6 <__fp_round+0x20>
    1c96:	bf 2b       	or	r27, r31
    1c98:	11 f4       	brne	.+4      	; 0x1c9e <__fp_round+0x18>
    1c9a:	60 ff       	sbrs	r22, 0
    1c9c:	04 c0       	rjmp	.+8      	; 0x1ca6 <__fp_round+0x20>
    1c9e:	6f 5f       	subi	r22, 0xFF	; 255
    1ca0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ca2:	8f 4f       	sbci	r24, 0xFF	; 255
    1ca4:	9f 4f       	sbci	r25, 0xFF	; 255
    1ca6:	08 95       	ret

00001ca8 <__fp_split3>:
    1ca8:	57 fd       	sbrc	r21, 7
    1caa:	90 58       	subi	r25, 0x80	; 128
    1cac:	44 0f       	add	r20, r20
    1cae:	55 1f       	adc	r21, r21
    1cb0:	59 f0       	breq	.+22     	; 0x1cc8 <__fp_splitA+0x10>
    1cb2:	5f 3f       	cpi	r21, 0xFF	; 255
    1cb4:	71 f0       	breq	.+28     	; 0x1cd2 <__fp_splitA+0x1a>
    1cb6:	47 95       	ror	r20

00001cb8 <__fp_splitA>:
    1cb8:	88 0f       	add	r24, r24
    1cba:	97 fb       	bst	r25, 7
    1cbc:	99 1f       	adc	r25, r25
    1cbe:	61 f0       	breq	.+24     	; 0x1cd8 <__fp_splitA+0x20>
    1cc0:	9f 3f       	cpi	r25, 0xFF	; 255
    1cc2:	79 f0       	breq	.+30     	; 0x1ce2 <__fp_splitA+0x2a>
    1cc4:	87 95       	ror	r24
    1cc6:	08 95       	ret
    1cc8:	12 16       	cp	r1, r18
    1cca:	13 06       	cpc	r1, r19
    1ccc:	14 06       	cpc	r1, r20
    1cce:	55 1f       	adc	r21, r21
    1cd0:	f2 cf       	rjmp	.-28     	; 0x1cb6 <__fp_split3+0xe>
    1cd2:	46 95       	lsr	r20
    1cd4:	f1 df       	rcall	.-30     	; 0x1cb8 <__fp_splitA>
    1cd6:	08 c0       	rjmp	.+16     	; 0x1ce8 <__fp_splitA+0x30>
    1cd8:	16 16       	cp	r1, r22
    1cda:	17 06       	cpc	r1, r23
    1cdc:	18 06       	cpc	r1, r24
    1cde:	99 1f       	adc	r25, r25
    1ce0:	f1 cf       	rjmp	.-30     	; 0x1cc4 <__fp_splitA+0xc>
    1ce2:	86 95       	lsr	r24
    1ce4:	71 05       	cpc	r23, r1
    1ce6:	61 05       	cpc	r22, r1
    1ce8:	08 94       	sec
    1cea:	08 95       	ret

00001cec <__fp_zero>:
    1cec:	e8 94       	clt

00001cee <__fp_szero>:
    1cee:	bb 27       	eor	r27, r27
    1cf0:	66 27       	eor	r22, r22
    1cf2:	77 27       	eor	r23, r23
    1cf4:	cb 01       	movw	r24, r22
    1cf6:	97 f9       	bld	r25, 7
    1cf8:	08 95       	ret

00001cfa <__mulsf3>:
    1cfa:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <__mulsf3x>
    1cfe:	0c 94 43 0e 	jmp	0x1c86	; 0x1c86 <__fp_round>
    1d02:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <__fp_pscA>
    1d06:	38 f0       	brcs	.+14     	; 0x1d16 <__mulsf3+0x1c>
    1d08:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <__fp_pscB>
    1d0c:	20 f0       	brcs	.+8      	; 0x1d16 <__mulsf3+0x1c>
    1d0e:	95 23       	and	r25, r21
    1d10:	11 f0       	breq	.+4      	; 0x1d16 <__mulsf3+0x1c>
    1d12:	0c 94 2c 0e 	jmp	0x1c58	; 0x1c58 <__fp_inf>
    1d16:	0c 94 32 0e 	jmp	0x1c64	; 0x1c64 <__fp_nan>
    1d1a:	11 24       	eor	r1, r1
    1d1c:	0c 94 77 0e 	jmp	0x1cee	; 0x1cee <__fp_szero>

00001d20 <__mulsf3x>:
    1d20:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <__fp_split3>
    1d24:	70 f3       	brcs	.-36     	; 0x1d02 <__mulsf3+0x8>

00001d26 <__mulsf3_pse>:
    1d26:	95 9f       	mul	r25, r21
    1d28:	c1 f3       	breq	.-16     	; 0x1d1a <__mulsf3+0x20>
    1d2a:	95 0f       	add	r25, r21
    1d2c:	50 e0       	ldi	r21, 0x00	; 0
    1d2e:	55 1f       	adc	r21, r21
    1d30:	62 9f       	mul	r22, r18
    1d32:	f0 01       	movw	r30, r0
    1d34:	72 9f       	mul	r23, r18
    1d36:	bb 27       	eor	r27, r27
    1d38:	f0 0d       	add	r31, r0
    1d3a:	b1 1d       	adc	r27, r1
    1d3c:	63 9f       	mul	r22, r19
    1d3e:	aa 27       	eor	r26, r26
    1d40:	f0 0d       	add	r31, r0
    1d42:	b1 1d       	adc	r27, r1
    1d44:	aa 1f       	adc	r26, r26
    1d46:	64 9f       	mul	r22, r20
    1d48:	66 27       	eor	r22, r22
    1d4a:	b0 0d       	add	r27, r0
    1d4c:	a1 1d       	adc	r26, r1
    1d4e:	66 1f       	adc	r22, r22
    1d50:	82 9f       	mul	r24, r18
    1d52:	22 27       	eor	r18, r18
    1d54:	b0 0d       	add	r27, r0
    1d56:	a1 1d       	adc	r26, r1
    1d58:	62 1f       	adc	r22, r18
    1d5a:	73 9f       	mul	r23, r19
    1d5c:	b0 0d       	add	r27, r0
    1d5e:	a1 1d       	adc	r26, r1
    1d60:	62 1f       	adc	r22, r18
    1d62:	83 9f       	mul	r24, r19
    1d64:	a0 0d       	add	r26, r0
    1d66:	61 1d       	adc	r22, r1
    1d68:	22 1f       	adc	r18, r18
    1d6a:	74 9f       	mul	r23, r20
    1d6c:	33 27       	eor	r19, r19
    1d6e:	a0 0d       	add	r26, r0
    1d70:	61 1d       	adc	r22, r1
    1d72:	23 1f       	adc	r18, r19
    1d74:	84 9f       	mul	r24, r20
    1d76:	60 0d       	add	r22, r0
    1d78:	21 1d       	adc	r18, r1
    1d7a:	82 2f       	mov	r24, r18
    1d7c:	76 2f       	mov	r23, r22
    1d7e:	6a 2f       	mov	r22, r26
    1d80:	11 24       	eor	r1, r1
    1d82:	9f 57       	subi	r25, 0x7F	; 127
    1d84:	50 40       	sbci	r21, 0x00	; 0
    1d86:	9a f0       	brmi	.+38     	; 0x1dae <__mulsf3_pse+0x88>
    1d88:	f1 f0       	breq	.+60     	; 0x1dc6 <__mulsf3_pse+0xa0>
    1d8a:	88 23       	and	r24, r24
    1d8c:	4a f0       	brmi	.+18     	; 0x1da0 <__mulsf3_pse+0x7a>
    1d8e:	ee 0f       	add	r30, r30
    1d90:	ff 1f       	adc	r31, r31
    1d92:	bb 1f       	adc	r27, r27
    1d94:	66 1f       	adc	r22, r22
    1d96:	77 1f       	adc	r23, r23
    1d98:	88 1f       	adc	r24, r24
    1d9a:	91 50       	subi	r25, 0x01	; 1
    1d9c:	50 40       	sbci	r21, 0x00	; 0
    1d9e:	a9 f7       	brne	.-22     	; 0x1d8a <__mulsf3_pse+0x64>
    1da0:	9e 3f       	cpi	r25, 0xFE	; 254
    1da2:	51 05       	cpc	r21, r1
    1da4:	80 f0       	brcs	.+32     	; 0x1dc6 <__mulsf3_pse+0xa0>
    1da6:	0c 94 2c 0e 	jmp	0x1c58	; 0x1c58 <__fp_inf>
    1daa:	0c 94 77 0e 	jmp	0x1cee	; 0x1cee <__fp_szero>
    1dae:	5f 3f       	cpi	r21, 0xFF	; 255
    1db0:	e4 f3       	brlt	.-8      	; 0x1daa <__mulsf3_pse+0x84>
    1db2:	98 3e       	cpi	r25, 0xE8	; 232
    1db4:	d4 f3       	brlt	.-12     	; 0x1daa <__mulsf3_pse+0x84>
    1db6:	86 95       	lsr	r24
    1db8:	77 95       	ror	r23
    1dba:	67 95       	ror	r22
    1dbc:	b7 95       	ror	r27
    1dbe:	f7 95       	ror	r31
    1dc0:	e7 95       	ror	r30
    1dc2:	9f 5f       	subi	r25, 0xFF	; 255
    1dc4:	c1 f7       	brne	.-16     	; 0x1db6 <__mulsf3_pse+0x90>
    1dc6:	fe 2b       	or	r31, r30
    1dc8:	88 0f       	add	r24, r24
    1dca:	91 1d       	adc	r25, r1
    1dcc:	96 95       	lsr	r25
    1dce:	87 95       	ror	r24
    1dd0:	97 f9       	bld	r25, 7
    1dd2:	08 95       	ret

00001dd4 <memcpy>:
    1dd4:	fb 01       	movw	r30, r22
    1dd6:	dc 01       	movw	r26, r24
    1dd8:	02 c0       	rjmp	.+4      	; 0x1dde <memcpy+0xa>
    1dda:	01 90       	ld	r0, Z+
    1ddc:	0d 92       	st	X+, r0
    1dde:	41 50       	subi	r20, 0x01	; 1
    1de0:	50 40       	sbci	r21, 0x00	; 0
    1de2:	d8 f7       	brcc	.-10     	; 0x1dda <memcpy+0x6>
    1de4:	08 95       	ret

00001de6 <_exit>:
    1de6:	f8 94       	cli

00001de8 <__stop_program>:
    1de8:	ff cf       	rjmp	.-2      	; 0x1de8 <__stop_program>
